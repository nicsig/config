# OPTIONS {{{1
# Server {{{2

# Why `-s` instead of `-g`? {{{
#
# Since tmux 2.1, `default-terminal` is a server option, not a session option.
#
#         As a side-effect this changes default-terminal to be a server rather
#         than a session option.
#
# https://github.com/tmux/tmux/commit/7382ba82c5b366be84ca55c7842426bcf3d1f521
# Confirmed by the  fact that `default-terminal` is described in  the section of
# the server options in the man page.
# Also confirmed by the fact that it's listed in the output of:
#
#         tmux show-options -s
#
# However, according to `nicm` (contributor of `tmux`):
#
#     You do not have to use -s or -w for set-option except for user options.
#     Tmux can work it out from the option name.
#     For show-option you do need it.
#
# So, we could omit `-s`, but I prefer to be explicit.
#}}}
# Why not let tmux use the default value `screen` (for `$TERM`)?{{{
#
# By default, most terminals set `$TERM` to `xterm` because the `xterm` entry is
# present and set in the terminfo db of most machines.
# `tmux` set it to `screen`, again, because  it's a popular entry (more than the
# `tmux` one).
# The `xterm`/`screen` value implies that the terminal will declare supporting
# only 8 colors. Confirmed by:    tput colors
#
# Because of this, the theme of some programs may be off (including Vim and the
# terminal itself). We want the terminal to declare it supports 256 colors,
# which anyway is usually true.
#}}}
# Do we need `$TERM` to contain `tmux`?{{{
#
# Yes. To support italics:
#
# The `screen-256color` entry in the terminfo db doesn't have a `sitm` field.
# IOW, the db reports that screen is unable to support italics, which is true.
# So, if we set `$TERM` to `screen-256color`, when an application will want to
# make some text appear italicized, it will think it's not possible.
# But it IS possible, because we use tmux, not screen. And tmux DOES support
# the italics style.
# The solution is to set `$TERM`  to `tmux-256color` so that when an application
# queries  the terminfo  db, it  finds  the field  `sitm` with  the right  value
# `\E[3m`.
#
# See also:
#
#     • https://github.com/tmux/tmux/wiki/FAQ#i-dont-see-italics-or-italics-and-reverse-are-the-wrong-way-round
#     • https://github.com/tmux/tmux/issues/175#issuecomment-152719805
#}}}
# Do we need `$TERM` to contain `256color`?{{{
#
# For a Vim colorscheme to be correctly applied, no.
# Because  it seems  that our  current theme  automatically sets  the number  of
# colors to 256:
#
#     runtime colors/seoul256.vim
#     echo &t_Co
#
# But, for the colorschemes of other programs, maybe.
#}}}
set -s default-terminal tmux-256color

# If the terminal supports focus events, they will be requested by the tmux
# client and passed through to the tmux server, then to the programs it runs.
# Necessary to be able to listen to `FocusGained` and `FocusLost` in Vim.
set -s focus-events on

# history of tmux commands (pfx :)
set -s history-file '~/.tmux/command_history'

# Before we begin appending values to 'terminal-overrides', we reset it, so that
# when we reload the configuration, old values don't pile up.
set -s terminal-overrides ''

# Why?{{{
#
# The 'guicursor'  option of Neovim relies  on the terminfo extensions  `Ss` and
# `Se` being correctly set to change  the shape of the cursor.  Neovim correctly
# sets them when `$TERM` contains `xterm` in the outer terminal.
#
# But not if it's `rxvt-unicode-256color`.  And the terminfo entry of the latter
# doesn't have any description for the `Ss` and `Se` capabilities.
#
# So, if  we don't set  `Ss` and `Se` here,  tmux won't recognize  the sequences
# sent by Neovim.
#}}}
#    ┌ append
#    │┌ server option
#    ││
set -as terminal-overrides ',*:Ss=\E[%p1%d q:Se=\E[2 q'
#                            │ └┤ └────────┤ └┤ └────┤{{{
#                            │  │          │  │      └ override with this keysequence;
#                            │  │          │  │        restore the cursor shape to a block
#                            │  │          │  │
#                            │  │          │  └ `Se` capability in `terminfo` db
#                            │  │          │
#                            │  │          └ override the current value with this new one;
#                            │  │            set the cursor shape to the one specified by
#                            │  │            the digit `%d`
#                            │  │
#                            │  └ `Ss` capability in the `terminfo` db (see `:h tui-cursor-shape`)
#                            │
#                            └ for all terminals (no matter `$TERM`)
#}}}

# Why?{{{
#
# So that tmux understands  a sequence sent by a program to  the terminal to set
# the cursor color.
#}}}
# Is it necessary for all terminal?{{{
#
# No.
# It's useless for xfce4-terminal and guake. But it's necessary for urxvt.
#}}}
# When is it useless?{{{
#
# It's useless  for some terminals,  on the  condition that they  understand the
# sequences changing  the cursor color, AND  that their `$TERM` is  `xterm` or a
# derivative.
# Because if it's `xterm`, `tmux` will  automatically add and set the unofficial
# extensions `Cs` and `Cr` in the terminfo db.
#}}}
# How did you found the value?{{{
#
#     $ TERM=xterm tmux -Ltest -f/dev/null
#     $ tmux info V
#     /Cs
#
# See also:
#     http://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Operating-System-Commands
#
#     OSC Ps ; Pt BEL
#     Ps = 1 2  -> Change text cursor color to Pt.  (Cs)
#     Ps = 1 1 2  -> Reset text cursor color.       (Cr)
#}}}
set -as terminal-overrides ',*:Cs=\E]12;%p1%s\007:Cr=\E]112\007'
#                                 └─┤└┤ └───┤└──┤{{{
#                                   │ │     │   └ BEL
#                                   │ │     └ Pt
#                                   │ └ Ps
#                                   └ OSC
#}}}

# strikethrough
set -as terminal-overrides ',xterm*:smxx=\E[9m'

# true colors
# Why `*-256color`?{{{
#
# It will match `xterm-256color` (useful for genuine xterm, xfce4-terminal, konsole),
# and `rxvt-unicode-256color` (useful for urxvt).
#}}}
# set -as terminal-overrides ',*-256color:Tc'
# FIXME:{{{ 
# This setting prevents two other settings to work:
#
#         set -gw window-style             'bg=#cacaca'
#         set -gw window-active-style      'bg=#dbd6d1'
#
# MWE:
#       $ cat /tmp/tmux.conf
#
#             set -gw window-style         'bg=#000000'
#             set -gw window-active-style  'bg=#ffffff'
#             set -g prefix 'M-space'

#             unbind '"'
#             bind _ splitw -v
#             unbind %
#             bind | splitw -h

#             bind M-space last-pane

#             set -as terminal-overrides ',*-256color:Tc'
#
#      $ tmux -Ltest -f/tmp/tmux.conf
#
#             pfx _
#             pfx SPC
#             pfx SPC
#
# IOW,  atm, we  have to  choose between  true colors  and different  colors for
# inactive vs active panes.
# Alternatively,  we could  use `colour123`  instead of  `#ab1234` when  setting
# `window-style` and `window-active-style`.
# }}}

# Session {{{2

# When we create a new window, tmux looks for an unused index, starting from 0.
# I prefer 1.
set -g base-index 1
#    │
#    └ must be applied globally to all sessions

# same thing for the panes
set -gw pane-base-index 1
#    ││
#    │└ window option
#    └ must be applied globally to all windows

# Why?{{{
#
# If a new window is created without any command to execute, tmux reads the
# session option `default-command` to find one.
# By default, its value is an empty string which instructs tmux to create
# a LOGIN shell using the value of the default-shell option.
# The default value of the latter is $SHELL (atm: /bin/zsh).
#
# When we create  a new window, we  want a NON-login shell, because  a login zsh
# shell  sources `~/.zprofile`,  which  we use  to execute  code  specific to  a
# virtual CONSOLE (set the background to white in the console).
# This code is not suited to a virtual TERMINAL.
#
# More  generally,  we don't  want  a  NON-login  shell  to source  LOGIN  files
# (`.profile`, `.zprofile`, `.zlogin`).
#
# So, we give the value zsh to `default-command` to prevent tmux to start
# a login shell.
#}}}
set -g default-command zsh

# Don't detach the client when the current session is killed.
set -g detach-on-destroy off

#
# display status line messages and other on-screen indicators for 4s
# (or until a key is pressed)
set -g display-time 4000

# increase scrollback buffer (2000 → 50000)
#
# `history-limit` has nothing to do with the history of executed tmux commands.
# It controls the amount of lines you can scroll back when you enter copy mode.
set -g history-limit 50000

# Renumber windows, when one is destroyed, to prevent a hole in the numbering
set -g renumber-windows on

# update the status line every 5 seconds (instead of 15s by default)
set -g status-interval 5

# Window {{{2

# FIXME:
# How to remove the index in the windows titles?
# It seems that it's controlled by the option 'automatic-rename-format':
#
#         tmux show-options -gw automatic-rename-format
#
# Its current value is:

#         "#{?pane_in_mode,[tmux],#{pane_current_command}}#{?pane_dead,[dead],}"
#
# I don't see any index. Does that mean it's hard coded and can't be removed?
#
# Also, how to hide `*` (current), `-` (previous), `#` (active) symbols?
#
#@         set -gw automatic-rename-format ""    ✘



# colors for the border separating 2 panes
set -gw pane-active-border-style fg=black,bg=yellow

# When we press a modified arrow key, urxvt emits a sequence containing a number
# indicating the modifier which was used:
#
#         S-Up  →  \e[1;2A
#
# We want it to be passed to the foreground program (Vim, shell, …).
# If `xterm-keys`  is not set, nothing  is transmitted to the  program, probably
# because tmux doesn't recognize the sequence.
set -gw xterm-keys on

# HOOKS {{{1

# When we split a pane horizontally, we want all the panes to be equally resized.
# Warning:
# Because of this hook, we can't split vertically anymore.
# Splitting vertically will result in an horizontal split no matter what.

#@ set-hook -g after-split-window 'selectl even-vertical'

# KEY BINDINGS {{{1

# TODO:
# If possible, implement the key binding `pfx + L` to move a horizontal pane
# into a vertical one to the right.
# Implement similar ones with `H`, `J` and `K`, to gain consistency between Vim
# and tmux.

# NOTE:
# `C-\` is free.
#
# By default, the terminal driver interprets `C-\` as the order to send the
# `SIGQUIT` signal to the foreground process. The latter can react to this
# signal however it wants. Usually, it quits.
#
# We've disabled it, by adding `stty quit undef` in `~/.shrc`.

# We use `M-space` as a prefix.
set -g prefix 'M-space'

# emacs key bindings in tmux command prompt (prefix + :) are better than vi keys,
# even for vim users.
set -g status-keys emacs

bind  -T copy-mode-vi  _  send -X start-of-line

# It seems Google is blocking my research on their search engine.
# ixquick gets its result from Google, and doesn't block me.
# Besides, it should be more anonymous.
#
# mnemonics: g for Google
bind g neww -n ixquick -c $HOME \; \
       send ' ~/bin/search-engine.sh' 'Enter'
#            │
#            └─ the space is useful to prevent zsh from saving
#            the command in the history when we cancel the search
#            with `c-c` or `c-d` (setopt HIST_IGNORE_SPACE)

# Look  for the  previous shell  prompt, to  get to  the beginning  of the  last
# command output. After pressing `pfx + b`,  you can visit all the other prompts
# by pressing `n` or `N`.
#
# If the search  often matches non-prompt lines, you could  include an invisible
# non-breaking space  inside your shell prompt,  and use it here  as your search
# pattern.
#
# Inspiration: https://www.youtube.com/watch?v=uglorjY0Ntg
#
#     ┌ mnemonic: back
#     │
bind  b  copy-mode\; send -X start-of-line\; send -X search-backward 'jean%'
#        │           │                       │
#        │           │                       └ search backward for the pattern `jean%`
#        │           └ move cursor at the beginning of the line
#        └ enter copy-mode

# TODO:
# Find a way to conceal the control sequences for the terminal.{{{
# This code uses the regex `[[:cntrl:]].\{-}m`:
#
#         augroup conceal_tmux_log
#             au!
#             au BufWinEnter *.tmux.log call s:setup_tmux_log()
#         augroup END
#         fu! s:setup_tmux_log() abort
#             call matchadd('Conceal', '[[:cntrl:]].\{-}m', 0, -1, {'conceal': 'x'})
#             setl cole=3
#             setl cocu=nc
#         endfu
#
# It's not enough; it doesn't match all control sequences.
#
#         https://superuser.com/q/380772
#         https://stackoverflow.com/q/7857352/9690698
#
# For other inspiration:
#         https://github.com/vim-scripts/AnsiEsc.vim
#
# See also the PR which has not been merged, for possible improvement.
#}}}
bind C pipe-pane -o 'cat >>/tmp/#W.tmux.log' \; display 'Toggled logging to /tmp/#W.tmux.log'

bind C-l send C-l \; run 'tmux clear-history'
#             │           │
#             │           └── delete tmux scrollback buffer
#             └── clear terminal screen

# bookMarks + fzf

#            ┌── window-name
#            │            ┌── start-directory
#            │            │
bind m neww -n bookmarks -c $HOME \; \
       send ' fzf_sr && tmux killw' 'Enter'
#               │
#               └── custom function to fuzzy search bookmarks
#                          and then open selected entry in GUI browser

# reload tmux config with `r`
bind r source ~/.tmux.conf \; display "Configuration reloaded."

unbind {
unbind }
bind x swapp -U
bind X swapp -D

# split pane vertically / horizontally
unbind '"'
bind _ splitw -v
unbind %
bind | splitw -h

# split window vertically / horizontally
#
# FIXME:
# find better hotkeys, using `AltGr`
# when we'll have remapped it to the space bar, we should have access to easy
# chords like `Space + v` and `Space + b`
#
# mnemonics: fv = Full Vertical ?
bind ` splitw -fv
bind ® splitw -fh

# FIXME:
# these key bindings could allow us to get rid of `M-j` and `M-l`
# the latter is used by readline and zle to lower the case of a word
# try to use `pfx n` and `pfx N` instead
# if it doesn't work, remove them
bind -r n next
bind -r N prev

# We could use `q` instead to be more consistent with Vim, but the problem is
# that we often type pfx + q by accident.
# So we use `d` instead for the moment; but `d` was used by `detach`, so we move
# it to `@`. Why `@`? I didn't find anything better, and it seems hard to hit by
# accident …
bind d killp
bind D killw
bind @ detach

# We use `*` instead of `q` because it's more consistent with `#`.
# They both show information. Besides, if I hit `pfx + q` by accident (which
# happen often), I won't be distracted by the panes numbers.
unbind q
bind * displayp

# unbind keys handling resizing of panes
unbind M-up
unbind M-down
unbind M-left
unbind M-right

# downward
unbind J
bind -r C-j resizep -D 5

# upward
unbind K
bind -r C-k resizep -U 5

# resize pane to the left
unbind H
bind -r C-h resizep -L 5

# to the right
unbind L
bind -r C-l resizep -R 5

# fait reculer la fenêtre courante d'un cran
# "    avancer "
bind -n M-j swapw -t -1
bind -n M-k swapw -t +1

# pfx escape = cycle through predefined layouts
bind -r Escape nextl

# bring arbitrary pane in current window
bind [ command-prompt -p "join pane from:"  "join-pane -s '%%'"
# send current pane in arbitrary window
bind ] command-prompt -p "send pane to:"  "join-pane -t '%%'"

unbind !
bind T breakp

bind M-1 rename -t 0 fun \; \
    renamew -t 1 music \; \
    send ' cmus' 'Enter' '2' 'Enter' 'Enter' \; \
    new -s study \; \
    send ' nv' 'Enter' \; \
    neww -n fm -c $HOME \; \
    send ' fm' 'Enter' \; \
    select-window -t 1

# NAVIGATION {{{1

# h     give focus to left pane
bind h select-pane -L
# j     give focus to bottom pane
bind j select-pane -D
# k     give focus to upper pane
bind k select-pane -U
# l     give focus to right pane
bind l select-pane -R

# give focus to last pane
bind M-space last-pane

# OLD CODE to review:
# Raccourcis C-hjkl pour se déplacer entre les panes de tmux et les viewports de vim.
# Raccourci C-\ pour alterner entre les derniers panes / viewports (équivalent de alt-tab en gui).
# Nécessite l'installation du plugin Vim Tmux Navigator : https://github.com/christoomey/vim-tmux-navigator

# Remarque : pour que ces raccourcis fonctionnent avec les viewports de Vim,
# Vim doit avoir été lancé depuis le shell courant, pas depuis un sous-shell
# ex :
#         v        fasd
#
# En effet dans ce cas, le résultat de la commande:
#
#         :echo system('tmux -S /tmp/tmux-1000/default display -p "#{pane_current_command}"')
#
# … est `sh`.
# La commande shell contenue dans la variable `is_vim` va donc échouer car elle
# cherche (via un grep) la présence de la chaîne Vim.
# Et comme elle échouera, tmux pensera qu'on est dans un pane tmux et exécutera
# donc une commande:
#
#         select-pane -LDURl
# Update:
# Le pb a peut-être été corrigé depuis:
# https://github.com/christoomey/vim-tmux-navigator/pull/117

# The command 'echo "#{pane_current_command}" | grep -iqE pattern' is a tmux command.
# To test it manually in the shell, you have to send it to the tmux server (tmux -S /path/to/socket).
# It can be tested with the following command (modulo the path to the socket):
#
#         tmux -S /tmp/tmux-1000/default display -p #{pane_current_command}
#
# To test it in Vim, you have to type something like:
# :echo system('tmux -S /tmp/tmux-1000/default display -p "#{pane_current_command}"')
#
# If this tmux command succeeds, it means we are in a vim pane because the grep
# looks for all the possible patterns.
# There are several possible patterns because you can start Vim in different ways:
# vim, vimdiff, nvim, gvim …
# In this case, tmux will simply pass  the received key (C-hjkl) to Vim (through
# the command 'send').
# Otherwise, it will execute the command: 'select-pane -LDURl'
#
#        L = Left
#        D = Down
#        U = Up
#        R = Right
#        l = previous

# If, for example, you want to change the binding C-h, simply replace both C-h
# with a new one.
#
# The shell command stored in `is_vim` will be used in the next key bindings.
# The latter will act differently, depending on whether it succeeds.
# Note that tmux expands "#{…}" BEFORE passing the command to the shell.
is_vim='echo "#{pane_current_command}" | grep -iqE "(^|\/)g?(view|n?vim?)(diff)?$"'

# bind C-h if-shell "$is_vim" "send C-h" "select-pane -L"
# bind C-j if-shell "$is_vim" "send C-j" "select-pane -D"
# bind C-k if-shell "$is_vim" "send C-k" "select-pane -U"
# bind C-l if-shell "$is_vim" "send C-l" "select-pane -R"
# bind C-\ if-shell "$is_vim" "send C-\\" "select-pane -l"


# donner le focus à la fenêtre suivante
bind -n M-l next
# donner le focus à la fenêtre précédente
bind -n M-h prev

# FIXME:
# How to use `h` and `l` to expand/collapse a menu item (example: pfx s, or pfx w)?
# Previously we had this:
#
#     bind -t vi-choice h tree-collapse
#     bind -t vi-choice l tree-expand
#
# It  doesn't   work  anymore,   because  `-t`,   `vi-choice`,  `tree-collapse`,
# `tree-expand` don't exist anymore.
# Now,the keys are hardcoded, see `man tmux` and search for `choose-tree`.
# By default, we need to press the left and right arrow keys.
#
# See here for a possible solution (to rebind those keys):
#         https://github.com/tmux/tmux/issues/592#issuecomment-299739274
#
# Doesn't work:
#
#         bind -n l if -F '#{==:#{pane_mode},choose-mode}' 'send Right' 'send l'
#         bind -n h if -F '#{==:#{pane_mode},choose-mode}' 'send Left' 'send h'

# COLORS {{{1

# color for inactive pane
set -gw window-style             'bg=#cacaca'
# color for active pane
set -gw window-active-style      'bg=#dbd6d1'

# colors for borders of inactive pane
set -gw pane-border-style 'fg=black,bg=#cacaca'
# colors for borders of active pane
set -gw pane-active-border-style 'fg=black,bg=#cacaca'

# VIM {{{1

# Support raccourcis VIM

# activer les raccourcis Vim quand on est en mode copie ou sélection
set -gw mode-keys vi

# Time  in  milliseconds for  which  tmux  waits after  an  escape  is input  to
# determine if it is part of a function or meta key sequences.
# The default is 500 milliseconds.
#
# This timeout introduces lag  when we use Vim and escape  from insert to normal
# mode.  Reduce the timeout.
# Why not 0 ?{{{
#
#         Some  people set  it  to zero  but  I consider  that  risky if  you're
#         connecting over  a wide-area  network or there  is anything  else that
#         might insert  small delays  between the  delivery of  chars in  such a
#         sequence.
#
# Source:
#     https://github.com/tmux/tmux/issues/353#issuecomment-294570322
#
# Basically, we should still  let a few ms to be sure all  the keys in a control
# sequence will have enough time to reach tmux.
#}}}
set -s escape-time 10

# Shell vi mode compatibility ; nécessaire pour que le raccourci ’pfx y’ du
# plugin tmux-yank fonctionne.
set -g @shell_mode 'vi'

# COPY-PASTE {{{1

# prefix + space to switch to copy-mode
bind Space copy-mode

bind -T copy-mode-vi  v    send -X begin-selection
bind -T copy-mode-vi  V    send -X select-line
bind -T copy-mode-vi  C-v  send -X rectangle-toggle
# How to use C-v :{{{
#
# You can't begin selecting a block right from copy-mode, by pressing C-v.
# `rectangle-toggle` does NOT select a text;  it TOGGLES the type of the current
# selection from characterwise/linewise to blockwise.
# IOW, you  need first to  press `v` or  `V` to select  some text, then  you can
# press `C-v` if you want a block.
#
# }}}

# FIXME:
# When do we need to unbind a key?
# Why do we unbind `]` and `=`?
#
# Update:
# I think the only time we should unbind a key, is when it becomes redundant.
# For example, by default `pfx ]` is bound to `paste-buffer`.
# So if we bind `paste-buffer` to `p`, then `]` becomes redundant.
unbind =

# coller le dernier buffer tmux
bind p paste-buffer

# coller le buffer de son choix
bind P choose-buffer

# write system clipboard inside tmux buffer
bind + run 'tmux set-buffer -- "$(xsel -o -b)"'

# MOUSE {{{1

# enable mouse support (scrolling, pane resize, select pane/window).
set -g mouse on

# Toggle mouse.
# Temporarily preventing tmux from handling the mouse can be useful in some
# terminals to copy text in system clipboard.

bind C-m \
  set -g mouse on \;\
  display 'Mouse: ON'

bind M-m \
  set -g mouse off \;\
  display 'Mouse: OFF'

# STATUSBAR {{{1

# alerte visuelle persistante en cas d'activité dans une autre fenêtre
# sous la forme d'un changement de couleur du fond de son titre
set -gw monitor-activity on

# # alerte visuelle temporaire en cas d'activité dans une autre fenêtre# {{{
# # sous la forme d'un message
# set -g visual-activity on
# # couleur police message
# set -g message-fg blue
# # couleur fond message
# set -g message-bg yellow

# }}}

# FIXME:
# read `man tmux` to find another syntax allowing us to use hex code
# this way we would have more colors to choose from

# couleur de la police d'écriture dans la barre
set -g status-fg white
# couleur du fond de la barre
set -g status-bg magenta

# couleur police titres fenêtres inactives
set -gw window-status-fg black
# couleur fond titres fenêtres inactives
set -gw window-status-bg default

# couleur police titre fenêtre active
set -gw window-status-current-fg black
# couleur fond titre fenêtre active
set -gw window-status-current-bg white

set -g status-justify centre
# Agrandit l'espace alloué aux infos de gauche pour pouvoir afficher de longs
# noms de sessions.
set -g status-left-length 40

# FIXME:
# If I inverse the white and black colors in the satus line, the `bold` style
# doesn't work as expected. Find a fix, and test a status line where these
# colors are inversed.

# #S = nom de la session ;
# on peut afficher d'autres infos (#I = n° de la fenêtre active, #P = n° du pane actif)
set -g status-left "#[fg=white,bold] #S"

# agrandit l'espace alloué aux infos de droite, autrement une partie est tronquée
set -g status-right-length 70

# The `nobold` value is necessary to get a proper black:
# without it, it's gray, because we used `bold` before.
# Yes, it seems that a style applied on an item of the status bar can have
# an effect on the style appliedd on the next one.
set -g status-right '#[fg=black] M #[fg=white,bold]#(get-mem-used.sh) #[fg=black,nobold] C #[fg=white,bold]#(get-cpu-load.sh) '

# You could also use `%` items:
#
#         %a = day of week
#         %d = day of month
#         %b = month
#         %R = hour
#
# See `man date` and `man tmux`.

# PLUGINS {{{1

# List of plugins

# TODO:
# See:
#     https://github.com/tmux-plugins/tmux-continuum

set -g @plugin 'tmux-plugins/tpm'
set -g @plugin 'tmux-plugins/tmux-copycat'
set -g @plugin 'tmux-plugins/tmux-open'

# By default, `tmux-open` binds the function which passes the selection
# to `xdg-open` to the key `o`. This leads to frequent errors, because
# we're used to press `o` to change the focused corner of the selection.
# So, we change the re-bind the function to `x` (`Xdg-open`).
set -g @open 'x'
# FIXME:
# `tmux-open` installs 2 other key bindings in copy-mode:  `C-o` and `S-s`.
# They don't work.

set -g @plugin 'tmux-plugins/tmux-resurrect'
# FIXME:
# This plugin installs (among others?) the following key binding (pfx ?):
#
#@    bind -T copy-mode y send -X copy-pipe-and-cancel "xsel -i --clipboard"
#
# It allows us to copy the selection in copy-mode.
# If I disable the plugin, and installs the key binding manually, it doesn't work.
# Why?
# Maybe it has something to do with this line in our tmux.conf file:
#
#@     set -g @shell_mode 'vi'
#
# If I could install it manually, maybe I could get rid of the plugin.

set -g @plugin 'tmux-plugins/tmux-yank'

# Other examples:
#@ set -g @plugin 'github_username/plugin_name'
#@ set -g @plugin 'git@github.com/user/plugin'
#@ set -g @plugin 'git@bitbucket.com/user/plugin'

# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)
run '~/.tmux/plugins/tpm/tpm'
