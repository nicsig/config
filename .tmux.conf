# Options {{{1
# Server {{{2

# Why `-s` instead of `-g`? {{{
#
# Since tmux 2.1, `default-terminal` is a server option, not a session option.
#
# > As a side-effect this changes default-terminal  to be a server rather than a
# > session option.
#
# https://github.com/tmux/tmux/commit/7382ba82c5b366be84ca55c7842426bcf3d1f521
# Confirmed by the  fact that `default-terminal` is described in  the section of
# the server options in the man page.
# Also confirmed by the fact that it's listed in the output of:
#
#     tmux show-options -s
#
# However, according to `nicm` (contributor of `tmux`):
#
# > You do not have to use -s or -w for set-option except for user options.
# > Tmux can work it out from the option name.
# > For show-option you do need it.
#
# So, we could omit `-s`, but I prefer to be explicit.
#}}}
# Why not let tmux use the default value `screen` (for `$TERM`)?{{{
#
# By default, most terminals set `$TERM` to `xterm` because the `xterm` entry is
# present and set in the terminfo db of most machines.
# `tmux` set it to `screen`, again, because  it's a popular entry (more than the
# `tmux` one).
# The `xterm`/`screen` value implies that the terminal will declare supporting
# only 8 colors. Confirmed by:    tput colors
#
# Because of this, the theme of some programs may be off (including Vim and the
# terminal itself). We want the terminal to declare it supports 256 colors,
# which anyway is usually true.
#}}}
# Do we need `$TERM` to contain `tmux`?{{{
#
# Yes. To support italics:
#
# The `screen-256color` entry in the terminfo db doesn't have a `sitm` field.
# IOW, the db reports that screen is unable to support italics, which is true.
# So, if we set `$TERM` to `screen-256color`, when an application will want to
# make some text appear italicized, it will think it's not possible.
# But it IS possible, because we use tmux, not screen. And tmux DOES support
# the italics style.
# The solution is to set `$TERM`  to `tmux-256color` so that when an application
# queries  the terminfo  db, it  finds  the field  `sitm` with  the right  value
# `\E[3m`.
#
# See also:
#
#     https://github.com/tmux/tmux/wiki/FAQ#i-dont-see-italics-or-italics-and-reverse-are-the-wrong-way-round
#     https://github.com/tmux/tmux/issues/175#issuecomment-152719805
#}}}
# Do we need `$TERM` to contain `256color`?{{{
#
# For a Vim color scheme to be correctly applied, no.
# Because  it seems  that our  current theme  automatically sets  the number  of
# colors to 256:
#
#     runtime colors/seoul256.vim
#     echo &t_Co
#
# But, for the color schemes of other programs, maybe.
#}}}
set -s default-terminal tmux-256color

# What does this option control?{{{
#
# It sets the time in milliseconds for which tmux waits after an escape is input
# to determine if it is part of a function or meta key sequences.
# The default is 500 millisec onds.
#}}}
# Why do you reset it?{{{
#
# The default  value introduces lag  when we use Vim  and escape from  insert to
# normal mode.  We want to reduce the timeout.
#}}}
# Why don't you set it to 0 ?{{{
#
# > Some people set  it to zero but  I consider that risky  if you're connecting
# > over a wide-area  network or there is anything else  that might insert small
# > delays between the delivery of chars in such a sequence.
#
# Source: https://github.com/tmux/tmux/issues/353#issuecomment-294570322
#
# Basically, we should still  let a few ms to be sure all  the keys in a control
# sequence will have enough time to reach tmux.
#}}}
set -s escape-time 10

# If the terminal supports focus events, they will be requested by the tmux
# client and passed through to the tmux server, then to the programs it runs.
# Necessary to be able to listen to `FocusGained` and `FocusLost` in Vim.
set -s focus-events on

# history of tmux commands (pfx :)
set -s history-file '~/.tmux/command_history'

# Before we begin appending values to 'terminal-overrides', we reset it, so that
# when we reload the configuration, old values don't pile up.
set -s terminal-overrides ''

# Why?{{{
#
# The 'guicursor'  option of Neovim relies  on the terminfo extensions  `Ss` and
# `Se` being correctly set to change  the shape of the cursor.  Neovim correctly
# sets them when `$TERM` contains `xterm` in the outer terminal.
#
# But not if it's `rxvt-unicode-256color`.  And the terminfo entry of the latter
# doesn't have any description for the `Ss` and `Se` capabilities.
#
# So, if  we don't set  `Ss` and `Se` here,  tmux won't recognize  the sequences
# sent by Neovim.
#}}}
#    ┌ append
#    │┌ server option
#    ││
set -as terminal-overrides ',*:Ss=\E[%p1%d q:Se=\E[2 q'
#                            │ ├┘ ├────────┘ ├┘ ├────┘ {{{
#                            │ │  │          │  └ override with this keysequence;
#                            │ │  │          │    restore the cursor shape to a block
#                            │ │  │          │
#                            │ │  │          └ `Se` capability in `terminfo` db
#                            │ │  │
#                            │ │  └ override the current value with this new one;
#                            │ │    set the cursor shape to the one specified by
#                            │ │    the digit `%d`
#                            │ │
#                            │ └ `Ss` capability in the `terminfo` db (see `:h tui-cursor-shape`)
#                            └ for all terminals (no matter `$TERM`)
#}}}

# Why?{{{
#
# So that tmux understands  a sequence sent by a program to  the terminal to set
# the cursor color.
#}}}
# Is it necessary for all terminal?{{{
#
# No.
# It's useless for xfce4-terminal and guake. But it's necessary for urxvt.
#}}}
# When is it useless?{{{
#
# It's useless  for some terminals,  on the  condition that they  understand the
# sequences changing  the cursor color, AND  that their `$TERM` is  `xterm` or a
# derivative.
# Because if it's `xterm`, `tmux` will  automatically add and set the unofficial
# extensions `Cs` and `Cr` in the terminfo db.
#}}}
# How did you found the value?{{{
#
#     $ TERM=xterm tmux -Ltest -f/dev/null
#     $ tmux info V
#     /Cs
#
# See also:
#     http://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Operating-System-Commands
#
#     OSC Ps ; Pt BEL
#     Ps = 1 2  -> Change text cursor color to Pt.  (Cs)
#     Ps = 1 1 2  -> Reset text cursor color.       (Cr)
#}}}
set -as terminal-overrides ',*:Cs=\E]12;%p1%s\007:Cr=\E]112\007'
#                                 ├─┘├┘ ├───┘├──┘ {{{
#                                 │  │  │    └ BEL
#                                 │  │  └ Pt
#                                 │  └ Ps
#                                 └ OSC
#}}}

# strikethrough
set -as terminal-overrides ',xterm*:smxx=\E[9m'

# true colors
# Why the `if-shell ` guard?{{{
#
# Setting `Tc` may prevent other settings to work, like these for example:
#
#     set -gw window-style        'bg=#cacaca'
#     set -gw window-active-style 'bg=#dbd6d1'
#
# The issue is specific to terminals which don't support true colors.
#
# MWE:
#
#      $ cat <<'EOF' >/tmp/tmux.conf
#
#      set -as terminal-overrides ',*-256color:Tc'
#      set -gw window-style         'bg=#000000'
#      set -gw window-active-style  'bg=#ffffff'
#
#      set -g prefix 'M-space'
#      unbind '"'
#      bind _ splitw -v
#      bind M-space last-pane
#      EOF
#
#      # start xfce4-terminal 0.6.3
#
#      $ tmux -L test -f /tmp/tmux.conf
#
#      pfx _
#      pfx SPC
#
# ---
#
# Alternatively, you could:
#
#    - use `colour123` instead of `#ab1234`
#    - use a terminal supporting true colors
#}}}
# Why `*-256color`?{{{
#
# It should  prevent the option  from being set  for a terminal  supporting less
# than 256 colors; if it doesn't even  support 256 colors, it can't support true
# colors either.
#}}}
if-shell '[ "$COLORTERM" != "xfce4-terminal" ]' 'set -as terminal-overrides ",*-256color:Tc"' ''

# Session {{{2

# Why?{{{
#
# If a new window is created without any command to execute, tmux reads the
# session option `default-command` to find one.
# By default,  its value  is an empty  string which instructs  tmux to  create a
# *login* shell using the value of the default-shell option.
# The default value of the latter is $SHELL (atm: /bin/zsh).
#
# When we create a new window, we  want a *non*-login shell, because a login zsh
# shell  sources `~/.zprofile`,  which  we use  to execute  code  specific to  a
# virtual *console* (set the background to white in the console).
# This code is not suited to a virtual *terminal*.
#
# More  generally, we  don't  want a  *non*-login shell  to  source login  files
# (`.profile`, `.zprofile`, `.zlogin`).
#
# So, we give the value zsh to `default-command` to prevent tmux from starting a
# login shell.
#}}}
set -g default-command zsh

# Don't detach the client when the current session is killed.
set -g detach-on-destroy off

# display status line messages and other on-screen indicators for 4s
# (or until a key is pressed)
set -g display-time 4000

# increase scrollback buffer (2000 → 50000)
#
# `history-limit` has nothing to do with the history of executed tmux commands.
# It controls the amount of lines you can scroll back when you enter copy mode.
set -g history-limit 50000

# Index options
#
# When we create a new window, tmux looks for an unused index, starting from 0.
# I prefer 1.
set -g base-index 1
#    │
#    └ must be applied globally to all sessions
#
# same thing for the panes
set -gw pane-base-index 1
#    ││
#    │└ window option
#    └ must be applied globally to all windows

# enable mouse support (scrolling, pane resize, select pane/window)
set -g mouse on

# use `M-space` as a prefix
set -g prefix M-space

# renumber windows, when one is destroyed, to prevent a hole in the numbering
set -g renumber-windows on

# update the status line every 5 seconds (instead of 15s by default)
set -g status-interval 5

# emacs key bindings in tmux command prompt (prefix + :) are better than vi keys,
# even for vim users.
set -g status-keys emacs

# color of status line
set -g status-style 'bg=colour138'

# Center the position of the window list component of the status line
set -g status-justify centre

# set the contents of the status line
# What's `#S`?{{{
#
# An alias for the variable `#{session_name}`.
# As the name  suggests, it's automatically replaced by the  name of the current
# session.
#}}}
# What's `#[...]`?{{{
#
# It allows you to embed some styles.
# If you want to  apply the same style all over the left  part or the right part
# of the status line, you can also use `status-left-style` or `status-right-style`:
#
#     set -g status-left '#[fg=colour15,bold] #S'
#     ⇔
#     set -g status-left       ' #S'
#     set -g status-left-style '#[fg=colour15,bold]'
#
# However, I prefer  embedding the styles inside the value  of `status-left` and
# `status-right`, because:
#
#    - it's more concise
#    - it's more powerful: you can set the style of an arbitrary *portion* of the status line
#
# ---
#
# Note that you  can use this syntax only  in the value of an  option which sets
# the *contents* of sth, not its style.
# So, this is *not* a valid syntax:
#
#     # ✘
#     set -g status-left-style '#[fg=colour15,bold]'
#
# Here, you must get rid of `#[...]`:
#
#     # ✔
#     set -g status-left-style 'fg=colour15,bold'
#}}}
# What's `#{...}`?{{{
#
# A conditional:
#
#     #{?test,val1,val2}
#
# For example:
#
#     {?client_prefix,#[bold],}
#
# This will be evaluated  into the style `bold` if the  prefix has been pressed,
# or nothing otherwise.
#}}}
# What's `#(...)`?{{{
#
# It allows you to insert the output of a shell command.
#}}}
# Why do you use `nobold`?{{{
#
# We set the style `bold` for some part of the status line.
# But a style applies to *all* the remaining text in the status line.
# I need `nobold` to reset the style.
#}}}
# Why don't you ever refer to colors by names (`black`, `white`, ...)?{{{
#
# When  they're  combined  with a  style  such  as  `bold`,  the result  can  be
# unexpected; for example, `fg=black,bold` gives some sort of grey.
# Same thing with `fg=white,nobold`.
#
# ---
#
# The issue may exist in other options, even without a `bold` style:
#
#     set -gw window-status-format '#[fg=white]#W'
#
# The title of a non-focused window should  be in white, but in practice it's in
# grey.
#
# OTOH, these commands work as expected:
#
#     set -gw window-status-format '#[fg=color255]#W'
#     set -gw window-status-format '#[fg=white,bold]#W'
#}}}
# How can I include the time of the day or the hour in the status line?{{{
#
# Use `%` items:
#
#     %a = day of week
#     %d = day of month
#     %b = month
#     %R = hour
#
# See `$ man date`.
#}}}
set -g status-left ' #[fg=colour15]#{?client_prefix,#[bold],}#S#{?client_prefix,,#[bold]}'
set -g status-right '#[fg=colour235] M #[fg=colour15,bold]#(get-mem-used.sh) #[fg=colour235,nobold] C #[fg=colour15,bold]#(get-cpu-load.sh) '

# Window {{{2

# Use vi key bindings in copy mode.
set -gw mode-keys vi

# Monitor for activity in the window.
# Windows with activity are highlighted in the status line.
set -gw monitor-activity on

# colors of focused and non-focused panes
set -gw window-active-style 'bg=#dbd6d1'
set -gw window-style        'bg=#cacaca'
# colors of *borders* of focused and non-focused panes
set -gw pane-active-border-style 'fg=colour138,bg=#cacaca'
set -gw pane-border-style        'fg=colour138,bg=#cacaca'

# How to insert the index of a window?{{{
#
# Use the alias `#I`.
#}}}
# How to insert its flags, like `Z` for a zoomed window?{{{
#
# Use the alias `#F`.
#}}}
# What's this `window_activity_flag`?{{{
#
# It's a variable whose value is 1 if the window has activity.
#}}}
# Is there an alternative?{{{
#
# If you don't want to use it, you could also use the
# `window-status-activity-style` option:
#
#     set -gw window-status-activity-style 'fg=red,bg=green'
#
# But it would apply to the whole text.
# `#{?window_activity_flag,...,...}` gives you more control over what is
# highlighted.
#}}}
# Why do you put a `#` in front of some commas?{{{
#
# Inside a conditional, a comma has a special meaning.
# If we don't want a comma to be  parsed as a separation between the main tokens
# of the conditional, we need to “escape” it.
#
# From `$ man tmux /FORMATS`:
# > ‘##’ is replaced by a single ‘#’, ‘#,’ by a ‘,’ and ‘#}’ by a ‘}’.
#}}}
# How to highlight the previous visited window?{{{
#
# Use the `window_last_flag` variable:
#
#     #{?window_last_flag,style1,style2]}
#
# Or use the `window-status-last-style` option:
#
#     set -gw window-status-last-style 'fg=red,bg=green'
#}}}
# Set what to display for the current window (then for the other ones), and how,
# in the status line window list.
# See: https://github.com/tmux/tmux/issues/74#issuecomment-129130023
set -gw window-status-current-format '#[fg=colour232,bg=colour253]#W#F'
set -gw window-status-format \
'#{?window_activity_flag,#[fg=colour235#,bg=colour253],#[fg=colour232#,bg=colour248]}#W#[bg=default]'
#                                                       ├────────────────────────┘{{{
#                                                       └ Shouldn't the colors be reversed?
# No.
# Tmux automatically reverse the colors when an activity is detected.
# The fact that we use a conditional to test the existence of an activity is irrelevant.
# Tmux is not aware of that.
#
# Start tmux with this minimal tmux.conf:
#
#     set -gw monitor-activity on
#     set -gw window-status-current-format '#[fg=colour16,bg=colour15]#W'
#     set -gw window-status-format '#[fg=colour16,bg=colour15]#W'
#     set -g prefix M-space
#     bind -T root M-l next
#     bind -T root M-h prev
#
# Create some windows; all the window titles in the window list are highlighted in white.
# In one of them run `sleep 5`, move to another window, and wait for `sleep` to end.
# The title of the window where the sleep has ended is highlighted in black.
# The colors have been reversed.
#}}}

# Purpose:{{{
#
# When we press a modified arrow key, urxvt emits a sequence containing a number
# indicating the modifier which was used:
#
#     S-Up  →  \e[1;2A
#
# We want it to be passed to the foreground process (Vim, shell, ...).
# If `xterm-keys`  is not set, nothing  is transmitted to the  process, probably
# because tmux doesn't recognize the sequence.
#}}}
set -gw xterm-keys on
# }}}1
# Key Bindings {{{1
# root {{{2

# focus next/previous window
bind -T root M-l next
bind -T root M-h prev

# copy-mode {{{2

# `q` is the default  key to quit copy mode, but in  practice, I constantly want
# to press Escape.
#     bind  -T copy-mode-vi  Escape send -X cancel
# Why is the previous key binding commented?{{{
#
# According to this page:
#     https://github.com/tmux-plugins/tmux-copycat/blob/master/docs/limitations.md
# Remapping the Escape key in copy mode can break tmux-copycat.
#
# Besides, we already have `M-z` and `q`. That should be enough.
#}}}

bind  -T copy-mode-vi  _  send -X start-of-line

# move current window position forward/backward
# Why switch to copy mode?{{{
#
# I haven't found any easy-to-type key binding in the root table.
# So, I use `C-h` and `C-l` in copy mode instead.
#
# ---
#
# `M-C-[jk]` could  be more  useful for something  else (WeeChat?),  and doesn't
# match a horizontal motion.
# `M-C-j` conflicts with some `dmenu`.
# `M-C-[hl]` conflicts with our window manager (move virtual desktop).
# `M-C-[HL]` is hard to press.
#}}}
bind -T copy-mode-vi C-l swapw -t +1
bind -T copy-mode-vi C-h swapw -t -1

bind -T copy-mode-vi  v    send -X begin-selection
bind -T copy-mode-vi  V    send -X select-line
bind -T copy-mode-vi  C-v  send -X rectangle-toggle
# How to use C-v?{{{
#
# You can't begin selecting a block right from copy mode, by pressing C-v.
#
# `rectangle-toggle` does  *not* select  a text;  it *toggles*  the type  of the
# current selection from characterwise/linewise to blockwise.
# IOW, you  need first to  press `v` or  `V` to select  some text, then  you can
# press `C-v` if you want a block.
# }}}

# `M-z` to toggle copy-mode.
bind -T root M-z copy-mode
bind -T copy-mode-vi M-z send -X cancel

# prefix {{{2

# NOTE: `C-\` is free.

# TODO:
# If possible, implement the key binding `pfx + L` to move a horizontal pane
# into a vertical one to the right.
# Implement similar ones with `H`, `J` and `K`, to gain consistency between Vim
# and tmux.

# pfx escape = cycle through predefined layouts
bind -r Escape nextl

# focus last pane
bind M-space last-pane

# write system clipboard inside tmux buffer
bind + run 'tmux set-buffer -- "$(xsel -o -b)"'

# We use `*` instead of `q` because it's more consistent with `#`.
# They both show information. Besides, if I hit `pfx + q` by accident (which
# happen often), I won't be distracted by the panes numbers.
bind * displayp

bind ! show-messages

# split window vertically / horizontally
#                 ┌ keep current working directory
#                 ├───────────────────────┐
bind - splitw  -v -c '#{pane_current_path}'
bind | splitw  -h -c '#{pane_current_path}'
bind _ splitw -fv -c '#{pane_current_path}'
bind \ splitw -fh -c '#{pane_current_path}'

# bring arbitrary pane in current window
bind [ command-prompt -p 'join pane from:'  "join-pane -s '%%'"
# send current pane in arbitrary window
bind ] command-prompt -p 'send pane to:'  "join-pane -t '%%'"

# Why a space before every shell command (` cmus`, ` weechat`, ...)?{{{
#
# It's useful  to prevent  zsh from saving  the command in  the history  when we
# cancel the search with `c-c` or `c-d` (`setopt HIST_IGNORE_SPACE`).
#}}}
# What's the `-n` option passed to `neww`?{{{
#
# It set the name of the window.
#}}}
# What about the `-c` option?{{{
#
# It sets the cwd of the shell.
#}}}
bind M-1 rename -t 0 fun \; \
    renamew -t 1 music \; \
    send ' cmus' 'Enter' '2' 'Enter' 'Enter' \; \
    neww -n irc -c $HOME \; \
    send ' weechat' 'Enter' \; \
    new -s study \; \
    send ' nv' 'Enter' \; \
    neww -n fm -c $HOME \; \
    send ' fm' 'Enter' \; \
    selectw -t 1

# jump Back to the Beginning of the previous shell command{{{
#
# Look  for the  previous shell  prompt, to  get to  the beginning  of the  last
# command output. After  pressing the key binding,  you can visit all  the other
# prompts by pressing `n` or `N`.
#
# We've included a no-break space inside our shell prompt, and we use it here as
# our search pattern.
#
# Inspiration: https://www.youtube.com/watch?v=uglorjY0Ntg
#}}}
bind b copy-mode \; send -X start-of-line \; send -X search-backward '٪'
#      │            │                        │{{{
#      │            │                        └ search backward for the pattern `٪`
#      │            └ move cursor at the beginning of the line
#      └ enter copy mode
#}}}

# We  can't use  `C-l` for the  lhs, because  we already use  it in  another key
# binding:
#     bind -r C-l resizep -R 5
bind C-c send C-l \; run 'tmux clear-history'
#             │           │
#             │           └ clear tmux scrollback buffer
#             └ clear terminal screen

# We could use `q` instead to be more consistent with Vim, but the problem is
# that we often type pfx + q by accident.
# So we use `d` instead for the moment; but `d` was used by `detach`, so we move
# it to `@`. Why `@`? I didn't find anything better, and it seems hard to hit by
# accident ...
bind d killp
bind D killw
bind @ detach

# resize pane
bind -r C-h resizep -L 5
bind -r C-j resizep -D 5
bind -r C-k resizep -U 5
bind -r C-l resizep -R 5

# focus neighboring panes
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R

# Toggle mouse.
# Temporarily preventing tmux from handling the mouse can be useful in some
# terminals to copy text in system clipboard.
bind C-m set -g mouse on  \; display 'Mouse: ON'
bind M-m set -g mouse off \; display 'Mouse: OFF'

# paste last tmux buffer
# Do *not* choose a key too easy to type.{{{
#
# It's dangerous.
# In Vim, the contents  of the buffer will be typed,  which will have unexpected
# results, unless you're in insert mode.
#
# Besides, if you've copied a line with the newline at the end, and you paste it
# on the shell's command-line, it will  be run automatically, without giving you
# the time to edit it.
#}}}
bind C-p paste-buffer

# choose and paste arbitrary tmux buffer
bind p choose-buffer -Z
#                     │
#                     └ zoom the pane so that it takes the whole window

# similar to `C-w r` and `C-w R` in Vim
bind -r r rotate-window -D \; selectp -t +1
bind -r R rotate-window -U \; selectp -t -1

# reload tmux config
# `C-r` is already used by tmux-resurrect
bind M-r source ~/.tmux.conf \; display 'Configuration reloaded.'

bind T breakp

# You need to install the `urlview` package for this key binding to work.
# Source: https://github.com/tmux-plugins/tmux-urlview/blob/b84c876cffdd22990b4ab51247e795cbd7813d53/urlview.tmux#L28-L31
bind u capture-pane \; \
       save-buffer /tmp/.tmux-buffer \; \
       delete-buffer \; \
       splitw -l 10 '$SHELL -c "urlview < /tmp/.tmux-buffer"'

# similar to `C-w x` in Vim
bind x swapp -U
bind X swapp -D
# }}}1
# Hooks {{{1

# Don't use this hook! `set-hook -g after-split-window 'selectl even-vertical'`{{{
#
# You wouldn't be able to split vertically anymore.
# Splitting vertically would result in an horizontal split no matter what.
#
# The hook  is given as  an example in  `$ man tmux`;  its purpose is  to resize
# equally all the panes whenever you split a pane horizontally.
#}}}

# TODO: Install a hook to ignore the activity in a Vim or cmus window.{{{
#
# This works:
#
#     ps_cmd="ps -o state=,comm= -t '#{pane_tty}'"
#     vim_pat="g?(view|n?vim?x?)(diff)?"
#         set-hook -g pane-focus-in \
#         "if \"$ps_cmd | grep -iqE '^[^TXZ ]+ +(\\S+\\/)?($vim_pat|cmus)$'\" \
#         'setw monitor-activity off' \
#         'setw monitor-activity on'"
#
# But I'm  not comfortable with `$  ps` and `$  grep` being fired every  time we
# focus a different pane.
# I would prefer using `window-renamed`, which is much less frequent.
# The problem is that it's also less reliable.
#
# MWE: Open two windows.
#
# In the first one run:
#
#     $ tmux show-options -w
#     ''~
#
# In the second one run:
#
#     $ sleep 3
#
# And get back to the first.
# Wait for the sleep to end in the other window, and run:
#
#     $ tmux show-options -w
#     monitor-activity on~
#
# The option has been set. It shouldn't.
#
# This is because:
#
#    - when sleep ends running, its window is renamed (sleep → zsh)
#    - the hook is run in the context of the current window, instead of the renamed window
#
# We need a way to make the command target the window which is renamed, probably
# using the `-t` option of `setw`.
# How to get a description (session name  + window index) of the window which is
# renamed?
#
# ---
#
# Once you've found a satisfying code, explain how it works.
#
#
# ---
#
# Ask this question on irc:
#
# > In Vim,  you can refer  to the  buffer name where  an autocmd is  fired with
# > `expand('<amatch>')`.
# > Is there something  equivalent in Tmux?
# > That is, if  a window is renamed automatically  (`automatic-rename` is set),
# > and I have a hook listening to  `window-renamed`, is there a way to refer to
# > the window (session name + window index)?
#}}}

# Plugins {{{1

# TODO: study these plugins:
# https://github.com/tmux-plugins/tmux-sensible
# https://github.com/tmux-plugins/tmux-pain-control
# https://github.com/tmux-plugins/tpm
# https://github.com/tmux-plugins/tmux-resurrect
# https://github.com/tmux-plugins/tmux-continuum
#
# https://github.com/tmux-plugins/vim-tmux

set -g @plugin 'tmux-plugins/tpm'

# https://github.com/tmux-plugins/tmux-copycat
# How do I change copycat's key bindings?{{{
#
#     set -g @copycat_git_special 'C-g'
#     set -g @copycat_file_search 'C-f'
#     set -g @copycat_url_search 'C-u'
#     set -g @copycat_digit_search 'C-d'
#     set -g @copycat_hash_search 'M-h'
#     set -g @copycat_ip_search 'M-i'
#
# https://github.com/tmux-plugins/tmux-copycat/blob/master/docs/customizations.md
#}}}
# How do I define new searches?{{{
#
# https://github.com/tmux-plugins/tmux-copycat/blob/master/docs/defining_new_stored_searches.md
#}}}
set -g @plugin 'tmux-plugins/tmux-copycat'

set -g @plugin 'tmux-plugins/tmux-logging'
# Create temporary directory for tmux log files.
run '[ -d $XDG_RUNTIME_DIR/tmux || mkdir $XDG_RUNTIME_DIR/tmux ]'
set -g @logging_key 'G'
set -g @screen-capture-key 'M-g'
set -g @save-complete-history-key 'M-G'
# Installing `ansifilter` is recommended. It improves the removal of color codes.
# FIXME: `ansifilter` fails to properly parse the command-lines,{{{
# probably because of the syntax highlighting of our zsh plugin.
#
# MWE:
#     # tmux command
#     pipe-pane -o 'cat >>/tmp/#W.tmux.log'
#
#     $ echo 'hello'
#     $ ansifilter  zsh.tmux.log
#     eecechecho ''hheelllloo'
#     hello
#
# Solution:
# Install a key-binding to temporarily disable the zsh syntax highlighting.
# In the meantime,  you can simply write a `return`  statement before the Syntax
# Highlighting section in our zshrc.
#}}}
# Don't use single quotes!{{{
#
# It would prevent the environment variable from being interpolated.
#}}}
set -g @logging-path "$XDG_RUNTIME_DIR/tmux"
set -g @logging-filename '#S-#W-%H%M%S.log'
set -g @screen-capture-path "$XDG_RUNTIME_DIR/tmux"
set -g @screen-capture-filename 'capture-#S-#W-%H%M%S.log'
set -g @save-complete-history-path "$XDG_RUNTIME_DIR/tmux"
set -g @save-complete-history-filename 'history-#S-#W-%H%M%S.log'

# https://github.com/tmux-plugins/tmux-open
set -g @plugin 'tmux-plugins/tmux-open'
# Open a visually selected text (file path or url) by pressing `x`.
# The default is `o`, which is confusing because of the semantic of `v_o` in Vim.
set -g @open 'x'
# Search a visually selected text on google by pressing `S`.
# You're not limited to a single search engine!{{{
#
# You can define as many key bindings as you want, to search on several engines:
#
#     set -g @open-B 'https://www.bing.com/search?q='
#}}}
set -g @open-S 'https://www.google.com/search?q='
# Open the visually selected file path in Vim.
set -g @open-editor 'C-x'

set -g @plugin 'tmux-plugins/tmux-resurrect'

# If you only care about copying the selection in copy mode, you can remove `tmux-yank`{{{
# and instead install this key binding:
#
#     bind -T copy-mode-vi y send -X copy-pipe-and-cancel "xsel -i --clipboard"
#}}}
set -g @plugin 'tmux-plugins/tmux-yank'

# Initialize TMUX plugin manager (keep this line near the very bottom of tmux.conf)
run '$HOME/.tmux/plugins/tpm/tpm'

# Unbind {{{1

# How to find the default key bindings installed with no config?{{{
#
#     $ tmux -Ltest -f/dev/null new
#     C-b ?
#     VG$
#     Enter
#     $ vim
#     i
#     C-b ]
#
# Make sure to release `Ctrl` before pressing `]`.
#}}}
# How to unbind `#`, `~`, `'`, `"`?{{{
#
# Quote the key (with single or double quotes).
#
# From `$ man tmux /KEY BINDINGS`:
# > Note that to bind the ‘"’ or ‘'’ keys, quotation marks are necessary.
#}}}
# How to unbind `;`?{{{
#
# Escape it.
#
# From `$ man tmux /COMMANDS`:
# > A literal  semicolon may be  included by escaping  it with a  backslash (for
# > example, when specifying a command sequence to bind-key).
#}}}

# TODO:
# Remove all default key bindings which you're not interested in.
# Some of them could be hit by accident.
# Keep only the ones you really use.
# Besides, it will give us a smaller table of key bindings, which will be easier
# to read when we have an issue with one of our key bindings.
# Have a look at `~/Desktop/tmux.md`.

# prefix {{{2

unbind C-b
# rotate-window -D
unbind C-o
# display-message
unbind '~'
# split-window
unbind '"'
# split-window -h
unbind %
# choose-buffer -Z
unbind =
# switch-client -l
unbind L
# next-window
unbind n
# display-panes
unbind q
# swap-pane -U
# swap-pane -D
unbind {
unbind }
# select-pane -U
# select-pane -D
# select-pane -L
# select-pane -R
unbind Up
unbind Down
unbind Left
unbind Right
# tmux clear-history (tmux-logging)
unbind M-c
# rotate-window -D
unbind M-o
# resize-pane -U 5
unbind M-up
# resize-pane -D 5
unbind M-down
# resize-pane -L 5
unbind M-left
# resize-pane -R 5
unbind M-right
# resize-pane -U
# resize-pane -D
# resize-pane -L
# resize-pane -R
unbind C-Up
unbind C-Down
unbind C-Left
unbind C-Right

# copy mode {{{2

# We don't need the key bindings from the copy-mode table; we use the copy-mode-*vi* table.
# But do *not* empty the table completely! Leave at least one key binding.{{{
#
# Otherwise, when you reload tmux.conf, you'll get error messages
#
#     Table copy-mode doesn't exist
#     Table copy-mode doesn't exist
#     Table copy-mode doesn't exist
#     ...
#
# Run `show-messages` to see them.
# Currently, we leave `C-Down`, because we're unlikely to ever hit that key.
#}}}

# default {{{3

unbind -T copy-mode C-a
unbind -T copy-mode C-b
unbind -T copy-mode C-c
unbind -T copy-mode C-e
unbind -T copy-mode C-f
unbind -T copy-mode C-g
unbind -T copy-mode C-k
unbind -T copy-mode C-n
unbind -T copy-mode C-p
unbind -T copy-mode C-r
unbind -T copy-mode C-s
unbind -T copy-mode C-v
unbind -T copy-mode C-w
unbind -T copy-mode Escape
unbind -T copy-mode Space
unbind -T copy-mode ,
unbind -T copy-mode \;
unbind -T copy-mode F
unbind -T copy-mode N
unbind -T copy-mode R
unbind -T copy-mode T
unbind -T copy-mode f
unbind -T copy-mode g
unbind -T copy-mode n
unbind -T copy-mode q
unbind -T copy-mode t

# third-party (?) {{{3

unbind -T copy-mode C-Space
unbind -T copy-mode C-x
unbind -T copy-mode !
unbind -T copy-mode S
unbind -T copy-mode Y
unbind -T copy-mode x
unbind -T copy-mode y
unbind -T copy-mode MouseDown1Pane
unbind -T copy-mode MouseDrag1Pane
unbind -T copy-mode MouseDragEnd1Pane
unbind -T copy-mode WheelUpPane
unbind -T copy-mode WheelDownPane
unbind -T copy-mode DoubleClick1Pane
unbind -T copy-mode TripleClick1Pane
unbind -T copy-mode Home
unbind -T copy-mode End
unbind -T copy-mode NPage
unbind -T copy-mode PPage
unbind -T copy-mode Up
unbind -T copy-mode Down
unbind -T copy-mode Left
unbind -T copy-mode Right
unbind -T copy-mode M-1
unbind -T copy-mode M-2
unbind -T copy-mode M-3
unbind -T copy-mode M-4
unbind -T copy-mode M-5
unbind -T copy-mode M-6
unbind -T copy-mode M-7
unbind -T copy-mode M-8
unbind -T copy-mode M-9
unbind -T copy-mode M-<
unbind -T copy-mode M->
unbind -T copy-mode M-R
unbind -T copy-mode M-b
unbind -T copy-mode M-f
unbind -T copy-mode M-m
unbind -T copy-mode M-r
unbind -T copy-mode M-v
unbind -T copy-mode M-w
unbind -T copy-mode M-y
unbind -T copy-mode M-{
unbind -T copy-mode M-}
unbind -T copy-mode M-Up
unbind -T copy-mode M-Down
unbind -T copy-mode C-Up

