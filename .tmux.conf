# Options {{{1
# Server {{{2

# Don't pile up more than 10 buffers (down from 50 by default).{{{
#
# Rationale: Keeping  a tidy  stack, with  relevant information,  could help  us
# integrate tmux buffers in our workflow more often.
#
# However, maybe  we could  keep a  big stack  of buffers,  and filter  them by`
# pressing `f in the window opened by `choose-buffer.                          `
# Alternatively,  we could  also try to  use fzf to  fuzzy search  through their
# contents...
#}}}
set -s buffer-limit 10

# What does this option control?{{{
#
# It sets the time in milliseconds for which tmux waits after an escape is input
# to determine if it is part of a function or meta key sequences.
# The default is 500 millisec onds.
#}}}
# Why do you reset it?{{{
#
# The default  value introduces lag  when we use Vim  and escape from  insert to
# normal mode.  We want to reduce the timeout.
#}}}
# Why don't you set it to 0 ?{{{
#
# > Some people set  it to zero but  I consider that risky  if you're connecting
# > over a wide-area  network or there is anything else  that might insert small
# > delays between the delivery of chars in such a sequence.
#
# Source: https://github.com/tmux/tmux/issues/353#issuecomment-294570322
#
# Basically, we should still  let a few ms to be sure all  the keys in a control
# sequence will have enough time to reach tmux.
#}}}
set -s escape-time 10

# If the terminal supports focus events, they will be requested by the tmux
# client and passed through to the tmux server, then to the programs it runs.
# Necessary to be able to listen to `FocusGained` and `FocusLost` in Nvim.
# Also necessary for `pane-focus-[in|out]` hooks.
set -s focus-events on

# history of tmux commands (pfx :)
set -s history-file "$HOME/.tmux/command_history"

# What does this do?{{{
#
# It makes tmux support  an OSC 52 sequence – which  sets the terminal clipboard
# content – if there  is an 'Ms' entry in the terminfo  description of the outer
# terminal.
# Note that  it seems tmux  sets 'Ms' in its  internal description of  the outer
# terminal – via 'terminal-overrides' – no matter the identity of the latter.
#
# MWE:
#
#     $ bash
#     $ export TERM=ansi
#     $ tmux -Ltest -f/dev/null new
#     $ tmux show-options -s terminal-overrides | grep Ms
#     terminal-overrides[0] "xterm*:XT:Ms=\\E]52;%p1%s;%p2%s\\007:Cs=\\E]12;%p1%s\\007:Cr=\\E]112\\007:Ss=\\E[%p1%d q:Se=\\E[2 q"~
#                                      ^^
#}}}
# What are the possible values of this option?{{{
#
#    - on
#    - external
#    - off
#
# ---
#
# If set to on,  tmux will accept the escape sequence to  create a buffer, *and*
# attempt to set the terminal clipboard.
#
# If set to external, tmux will attempt to set the terminal clipboard, but won't
# set a tmux buffer.
#
# If set  to off,  tmux will  neither accept the  clipboard escape  sequence nor
# attempt to set the clipboard.
#}}}
# What's the possible drawback of the value 'on'?{{{
#
# When you copy some text to
# TODO: finish (does the issue apply to copy? copy-pipe? both?)
#
# Also, document the benefit  of this option (I think it  eliminates the need of
# the yank script...).
#
# Also, document that if you need to reset the option for some terminals,
# but not all, you should set the option to 'on', and run:
#
#     set-option -as terminal-overrides ',yourTERMname:Ms@'
#                                                        ^
#
# I think the `@` is some kind  of placeholder character which doesn't match any
# valid description of a terminal capability, and can be used to disable one.
# I think nicm uses this technique in some issues on github, like here:
# https://github.com/tmux/tmux/issues/1593#issuecomment-460004714
# https://github.com/tmux/tmux/issues/1419#issuecomment-409111029
#
# Here, if we wanted to set the Ms capability correctly, the right syntax would be:
#
#     set-option -as terminal-overrides ',yourTERMname:Ms=...'
#                                                        ^^^^
#
# ---
#
# The same issue applies to the value 'external'.
#}}}
set -s set-clipboard external

# Why do you move your 'terminal-overrides' settings in another file?{{{
#
# It makes it easier to source the settings only when the tmux server is started;
# not when we manually re-source `~/.tmux.conf`.
#}}}
#   Why do you need them to be sourced only once?{{{
#
# We *append* strings to the value of the 'terminal-overrides' option.
# I don't want to append the same strings again and again every time I re-source
# `~/.tmux.conf`.
#}}}
#     Why don't you simply reset the option before appending a value?{{{
#
# That would make us lose the default value of the option:
#
#     terminal-overrides[0] "xterm*:XT:Ms=\\E]52;%p1%s;%p2%s\\007:Cs=\\E]12;%p1%s\\007:Cr=\\E]112\\007:Ss=\\E[%p1%d q:Se=\\E[2 q"
#     terminal-overrides[1] screen*:XT
#
# ---
#
# Besides, one of the value we append to 'terminal-overrides' depends on the value of `$TERM`.
#
#     if '[ "$TERM" != "st-256color" ]' 'set -as terminal-overrides ",*:Cr=\\E]112\\007"'
#           ^^^^^^^^^^^^^^^^^^^^^^^^
#
# And the value of `$TERM` will be correct only the first time we source `~/.tmux.conf`.
#}}}

# What's the value of `$TERM` here?{{{
#
# The first  time our `~/.tmux.conf` is  sourced, it matches the  `$TERM` of the
# outer terminal.
# The next times, it's 'tmux-256color'.
#}}}
# What's the meaning of this `if` guard?{{{
#
# The condition `[ "$TERM" != "tmux-256color" ]` is true only the first time our
# `~/.tmux.conf` is sourced.
# So, the guard means: “if this is the first time the file is sourced”.
# This is equivalent to `has('vim_starting')` in Vim.
#}}}
#   Could we use `%if` instead of `if`?{{{
#
# You could try this:
#
#     %if #{!=:$TERM,tmux-256color}
#     source-file $HOME/.tmux/terminal-overrides.conf
#     %endif
#
# But it doesn't seem to work; the guard would not prevent the file from being re-sourced.
# I think that's because `$TERM` is not expanded inside a replacement variable.
#
#     $ tmux display -p '#{==:$TERM,tmux-256color}'
#     0~
#     $ tmux display -p '#{==:$TERM,st-256color}'
#     0~
#     $ tmux display -p '#{==:$TERM,$TERM}'
#     1~
#}}}
if '[ "$TERM" != "#{default-terminal}" ]' { source-file "$HOME/.tmux/terminal-overrides.conf" }

# Leave `default-terminal` at the end.{{{
#
# In my limited testing, moving it above would not cause an issue, but better be
# safe than sorry.
# In  particular,  I  want  to  be  sure  that  the  value  of  `$TERM`  is  not
# 'tmux-256color'  the  first  time  our `~/.tmux.conf`  is  sourced;  otherwise
# `terminal-overrides.conf` would never be sourced.
#}}}
# Why `-s` instead of `-g`? {{{
#
# Since tmux 2.1, `default-terminal` is a server option, not a session option.
#
# > As a side-effect this changes default-terminal  to be a server rather than a
# > session option.
#
# https://github.com/tmux/tmux/commit/7382ba82c5b366be84ca55c7842426bcf3d1f521
# Confirmed by the  fact that `default-terminal` is described in  the section of
# the server options in the man page.
# Also confirmed by the fact that it's listed in the output of:
#
#     tmux show-options -s
#
# However, according to `nicm` (contributor of `tmux`):
#
# > You do not have to use -s or -w for set-option except for user options.
# > Tmux can work it out from the option name.
# > For show-option you do need it.
#
# So, we could omit `-s`, but I prefer to be explicit.
#}}}
# Why not let tmux use the default value `screen` (for `$TERM`)?{{{
#
# By default, most terminals set `$TERM` to `xterm` because the `xterm` entry is
# present and set in the terminfo db of most machines.
# tmux sets it to  `screen`, again, because it's a popular  entry (more than the
# `tmux` one).
# The `xterm`/`screen` value  implies that the terminal  will declare supporting
# only 8 colors; confirmed by `$ tput colors`.
#
# Because of this, the theme of some programs may be off (including Vim and the
# terminal itself). We want the terminal to declare it supports 256 colors,
# which anyway is usually true.
#}}}
# Do we need `$TERM` to contain `tmux`?{{{
#
# Yes. To support italics:
#
# The `screen-256color` entry in the terminfo db doesn't have a `sitm` field.
# IOW, the db reports that screen is unable to support italics, which is true.
# So, if we set `$TERM` to `screen-256color`, when an application will want to
# make some text appear italicized, it will think it's not possible.
# But it IS possible, because we use tmux, not screen. And tmux DOES support
# the italics style.
# The solution is to set `$TERM`  to `tmux-256color` so that when an application
# queries  the terminfo  db, it  finds  the field  `sitm` with  the right  value
# `\E[3m`.
#
# See also:
# https://github.com/tmux/tmux/wiki/FAQ#i-dont-see-italics-or-italics-and-reverse-are-the-wrong-way-round
# https://github.com/tmux/tmux/issues/175#issuecomment-152719805
#}}}
#   `256color`?{{{
#
# For a Vim color scheme to be correctly applied, no.
# Because  it seems  that our  current theme  automatically sets  the number  of
# colors to 256:
#
#     :runtime colors/seoul256.vim
#     :echo &t_Co
#
# But, for the color schemes of other programs, maybe.
#}}}
set -s default-terminal tmux-256color

# Session {{{2

# Why?{{{
#
# If a new window is created without any command to execute, tmux reads the
# session option `default-command` to find one.
# By default,  its value  is an empty  string which instructs  tmux to  create a
# *login* shell using the value of the default-shell option.
# The default value of the latter is $SHELL (atm: /bin/zsh).
#
# When we create a new window, we  want a *non*-login shell, because a login zsh
# shell  sources `~/.zprofile`,  which  we use  to execute  code  specific to  a
# virtual *console* (set the background to white in the console).
# This code is not suited to a virtual *terminal*.
#
# More  generally, we  don't  want a  *non*-login shell  to  source login  files
# (`.profile`, `.zprofile`, `.zlogin`).
#
# So, we give the value zsh to `default-command` to prevent tmux from starting a
# login shell.
#}}}
set -g default-command zsh

# Don't detach the client when the current session is killed.
set -g detach-on-destroy off

# display status line messages and other on-screen indicators for 4s
# (or until a key is pressed)
set -g display-time 4000

# increase scrollback buffer (2000 → 50000)
#
# `history-limit` has nothing to do with the history of executed tmux commands.
# It controls the amount of lines you can scroll back when you enter copy mode.
set -g history-limit 50000

# Index options
#
# When we create a new window, tmux looks for an unused index, starting from 0.
# I prefer 1.
set -g base-index 1
#    │
#    └ must be applied globally to all sessions
#
# same thing for the panes
set -gw pane-base-index 1
#    ││
#    │└ window option
#    └ must be applied globally to all windows

# enable mouse support (scrolling, pane resize, select pane/window)
set -g mouse on

# use `M-space` as a prefix
set -g prefix M-space

# renumber windows, when one is destroyed, to prevent a hole in the numbering
set -g renumber-windows on

# Some consoles don't like attempts to set the window title.
# This may cause tmux to freeze the terminal when you attach to a session.
# https://github.com/tmux/tmux/wiki/FAQ#tmux-freezes-my-terminal-when-i-attach-to-a-session-i-have-to-kill--9-the-shell-it-was-started-from-to-recover
set -g set-titles off

# update the status line every 5 seconds (instead of 15s by default)
set -g status-interval 5

# emacs key bindings in tmux command prompt (prefix + :) are better than vi keys,
# even for vim users.
set -g status-keys emacs

# color of status line
set -g status-style 'bg=colour138'

# Center the position of the window list component of the status line
set -g status-justify centre

# set the contents of the status line
# What's `#S`?{{{
#
# An alias for the replacement variable `#{session_name}`.
# As the name  suggests, it's automatically replaced by the  name of the current
# session.
#}}}
# What's `#[...]`?{{{
#
# It allows you to embed some styles.
# If you want to  apply the same style all over the left  part or the right part
# of the status line, you can also use `status-left-style` or `status-right-style`:
#
#     set -g status-left '#[fg=colour15,bold] #S'
#     ⇔
#     set -g status-left       ' #S'
#     set -g status-left-style '#[fg=colour15,bold]'
#
# However, I prefer  embedding the styles inside the value  of `status-left` and
# `status-right`, because:
#
#    - it's more concise
#    - it's more powerful: you can set the style of an arbitrary *portion* of the status line
#
# ---
#
# Note that you  can use this syntax only  in the value of an  option which sets
# the *contents* of sth, not its style.
# So, this is *not* a valid syntax:
#
#     # ✘
#     set -g status-left-style '#[fg=colour15,bold]'
#
# Here, you must get rid of `#[...]`:
#
#     # ✔
#     set -g status-left-style 'fg=colour15,bold'
#}}}
# What's `#{?...}`?{{{
#
# A conditional:
#
#     #{?test,val1,val2}
#
# For example:
#
#     {?client_prefix,#[bold],}
#
# This will be evaluated  into the style `bold` if the  prefix has been pressed,
# or nothing otherwise.
#}}}
# What's `#(...)`?{{{
#
# It allows you to insert the output of a shell command.
#}}}
# Why do you use `nobold`?{{{
#
# We set the style `bold` for some part of the status line.
# But a style applies to *all* the remaining text in the status line.
# I need `nobold` to reset the style.
#}}}
# Why don't you ever refer to colors by names (`black`, `white`, ...)?{{{
#
# When  they're  combined  with a  style  such  as  `bold`,  the result  can  be
# unexpected; for example, `fg=black,bold` gives some sort of grey.
# Same thing with `fg=white,nobold`.
#
# ---
#
# The issue may exist in other options, even without a `bold` style:
#
#     set -gw window-status-format '#[fg=white]#W'
#
# The title of a non-focused window should  be in white, but in practice it's in
# grey.
#
# OTOH, these commands work as expected:
#
#     set -gw window-status-format '#[fg=color255]#W'
#     set -gw window-status-format '#[fg=white,bold]#W'
#}}}
# How can I include the time of the day or the hour in the status line?{{{
#
# Use `$ date` and `%` items:
#
#     %a = day of week
#     %d = day of month
#     %b = month
#     %R = hour
#
# See `$ man date`.
#}}}
set -g status-left ' #[fg=colour15]#{?client_prefix,#[bold],}#S#{?client_prefix,,#[bold]}'
set -g status-right '#[fg=colour235] M #[fg=colour15,bold]#(get-mem-used.sh) #[fg=colour235,nobold] C #[fg=colour15,bold]#(get-cpu-load.sh) '

# Why do you want `COLORTERM` to be automatically updated?{{{
#
# It can be useful to detect a terminal which lies about its identity.
# E.g., xfce4-terminal advertises  itself as `xterm-256color`, but  the value of
# its `COLORTERM` variable is 'xfce4-terminal'.
#
# So, the more reliable  `COLORTERM` is, the better we can  detect that we're in
# xfce4-terminal, and react appropriately.
# This can be useful, for example, to prevent vim-term from sending `CSI 2 SPC q`
# when we're leaving Vim from xfce4-terminal on Ubuntu 16.04.
# The latter  doesn't understand this sequence,  and once sent to  the terminal,
# tmux will regularly reprint the sequence wherever our cursor is.
#}}}
# Why could I be tempted to run the same command for `LESSOPEN`, `LESSCLOSE`, `LS_COLORS`?{{{
#
#     setenv -gu LESSOPEN
#     setenv -gu LESSCLOSE
#     setenv -gu LS_COLORS
#
# These environment variables are set in  `~/.zshenv`, but only on the condition
# they've not been set yet.
# The purpose of the condition is to make the shell quicker to start.
# Indeed, setting these variables adds around 8ms to the shell's startup time.
# However, if they are set in the tmux global environment, then they'll never be
# reset  when  we  start a  new  shell,  because  the  condition will  never  be
# satisfied.
#
# This means that we can't change the value of these variables by simply editing
# `~/.zshenv`, which can be an issue.
#}}}
#   Why don't you do it?{{{
#
# Because, it  would add around 8ms  to the startup  time of every shell  we ask
# tmux to open.
#}}}
#     Isn't this an issue?{{{
#
# No.
# If you want to modify one of these variables, and if you want the change to be
# applied immediately without  restarting the tmux server, do it  in the context
# of the tmux global environment:
#
#     $ tmux setenv -g LESSOPEN new_value
#}}}
if '[ "$TERM" != "#{default-terminal}" ]' { set -ga update-environment COLORTERM }

# Window {{{2

# Use vi key bindings in copy mode.
set -gw mode-keys vi

# Monitor for activity in the window.
# Windows with activity are highlighted in the status line.
set -gw monitor-activity on

# colors of focused and non-focused panes
set -gw window-active-style 'bg=#dbd6d1'
set -gw window-style        'bg=#cacaca'
# colors of *borders* of focused and non-focused panes
set -gw pane-active-border-style 'fg=colour138,bg=#cacaca'
set -gw pane-border-style        'fg=colour138,bg=#cacaca'

# How to insert the index of a window?{{{
#
# Use the alias `#I`.
#}}}
# How to insert its flags, like `Z` for a zoomed window?{{{
#
# Use the alias `#F`.
#}}}
# What's this `window_activity_flag`?{{{
#
# It's a replacement variable whose value is 1 if the window has activity.
#}}}
#   Is there an alternative?{{{
#
# If you don't want to use it, you could also use the
# `window-status-activity-style` option:
#
#     set -gw window-status-activity-style 'fg=red,bg=green'
#
# But it would apply to the whole text.
# `#{?window_activity_flag,...,...}` gives you more control over what is
# highlighted.
#}}}
# Why do you put a `#` in front of some commas?{{{
#
# Inside a conditional, a comma has a special meaning.
# If we don't want a comma to be  parsed as a separation between the main tokens
# of the conditional, we need to “escape” it.
#
# From `$ man tmux /FORMATS`:
# > ‘##’ is replaced by a single ‘#’, ‘#,’ by a ‘,’ and ‘#}’ by a ‘}’.
#}}}
# How to highlight the previous visited window?{{{
#
# Use the `window_last_flag` replacement variable:
#
#     #{?window_last_flag,style1,style2]}
#
# Or use the `window-status-last-style` option:
#
#     set -gw window-status-last-style 'fg=red,bg=green'
#}}}
# Set what to display for the current window (then for the other ones), and how,
# in the status line window list.
# See: https://github.com/tmux/tmux/issues/74#issuecomment-129130023
set -gw window-status-current-format '#[fg=colour232,bg=colour253]#W#F'
set -gw window-status-format \
'#{?window_activity_flag,#[fg=colour235#,bg=colour253],#[fg=colour232#,bg=colour248]}#W#[bg=default]'
#                                                       ├────────────────────────┘{{{
#                                                       └ Shouldn't the colors be reversed?
# No.
# Tmux automatically reverse the colors when an activity is detected.
# The fact that we use a conditional to test the existence of an activity is irrelevant.
# Tmux is not aware of that.
#
# Start tmux with this minimal tmux.conf:
#
#     set -gw monitor-activity on
#     set -gw window-status-current-format '#[fg=colour16,bg=colour15]#W'
#     set -gw window-status-format '#[fg=colour16,bg=colour15]#W'
#     set -g prefix M-space
#     bind -T root M-l next
#     bind -T root M-h prev
#
# Create some windows; all the window titles in the window list are highlighted in white.
# In one of them run `sleep 5`, move to another window, and wait for `sleep` to end.
# The title of the window where the sleep has ended is highlighted in black.
# The colors have been reversed.
#}}}

# Purpose:{{{
#
# When we press a modified arrow key, urxvt emits a sequence containing a number
# indicating the modifier which was used:
#
#     S-Up  →  \e[1;2A
#
# We want it to be passed to the foreground process (Vim, shell, ...).
# If `xterm-keys`  is not set, nothing  is transmitted to the  process, probably
# because tmux doesn't recognize the sequence.
#}}}
set -gw xterm-keys on
# }}}1
# Key Bindings {{{1
# root {{{2

# focus next/previous window
bind -T root M-l next
bind -T root M-h prev

# copy mode {{{2

# `M-z` to enter copy mode
# Do *not* bind `M-z` to anything while in copy mode!{{{
#
# This would  make you lose  an interesting  feature of the  `copy-mode` command
# while you're already in copy mode, reading  the output of some command such as
# `list-keys`.
#
# The default behavior makes tmux show you the contents of the original window:
#
#     # you're reading a file
#     :list-keys
#     :copy-mode
#     # the window shows again the file you were reading
#     # press `q`, and you get back the output of `:list-keys`
#
# I don't know where this is documented.
# And I don't  know why the `copy-mode`  command is invoked when  we press `M-z`
# while in copy mode.
# We only  have one key  binding using `M-z`  as its lhs,  and it's in  the root
# table, not in the copy-mode table.
#
# Note that this feature is not specific to our `M-z` key binding.
# I can reproduce with no config (and `C-b [` instead of `M-z`).
#}}}
bind -T root M-z copy-mode

# TODO: Originally, the mappings `S`, `x` and `C-x` in copy  mode passed `-b` to `run-shell` (see tmux-open plugin).{{{
# Should we use them too?
#
# Btw, they also redirected the output of the shell commands to `/dev/null`.
# This is because, if there's any output, it's displayed in copy mode.
# We don't do it atm, because I haven't noticed any output, and because we don't
# systematically use `/dev/null` whenever we invoke `run-shell`.
#}}}
# Search a visually selected text on google by pressing `S`.
bind -T copy-mode-vi S send -X copy-pipe-and-cancel \
    "xargs -I {} tmux run 'xdg-open \"https://www.google.com/search?q={}\"'"

# Open a visually selected text (filepath or url) by pressing `x`.
# TODO: The key binding will break if the file name contains double quotes.{{{
#
# Find a way to escape special characters.
#
# I tried `$ tmux display -p '#{q:#(tmux pasteb)}'`, but it doesn't work.
# You probably need `q:`, but a modifier needs to be followed by the name of
# a replacement variable and `#(tmux pasteb)` is not one.
#
# Update:
# I don't think you should use `q:`.
# Maybe you should  try to find a shell utility  which quotes special characters
# in a given text.
# Does such a tool exist?
# If it does, maybe you could try: `#(magic_tool $(tmux pasteb))`.
#}}}
bind -T copy-mode-vi x send -X copy-pipe-and-cancel \
    "xargs -I {} tmux run 'xdg-open \"{}\"'"

# TODO: How to make `%` cycle between the closing and opening bracket?
# Right now, we have to choose between `next-matching-bracket`
# or `previous-matching-bracket`.
bind -T copy-mode-vi % send -X next-matching-bracket
bind -T copy-mode-vi _ send -X start-of-line

# move current window position forward/backward
# Why switch to copy mode?{{{
#
# I haven't found any easy-to-type key binding in the root table.
# So, I use `C-h` and `C-l` in copy mode instead.
#
# ---
#
# `M-C-[jk]` could  be more  useful for something  else (WeeChat?),  and doesn't
# match a horizontal motion.
# `M-C-j` conflicts with some `dmenu`.
# `M-C-[hl]` conflicts with our window manager (move virtual desktop).
# `M-C-[HL]` is hard to press.
#}}}
bind -T copy-mode-vi C-l swapw -t +1 \; selectw -n
bind -T copy-mode-vi C-h swapw -t -1 \; selectw -p

bind -T copy-mode-vi  v    send -X begin-selection
bind -T copy-mode-vi  V    send -X select-line
bind -T copy-mode-vi  C-v  send -X rectangle-toggle
# How to use C-v?{{{
#
# You can't begin selecting a block right from copy mode, by pressing C-v.
#
# `rectangle-toggle` does  *not* select  a text;  it *toggles*  the type  of the
# current selection from characterwise/linewise to blockwise.
# IOW, you  need first to  press `v` or  `V` to select  some text, then  you can
# press `C-v` if you want a block.
# }}}

# prefix {{{2

# NOTE: `C-\` is free.

# pfx escape = cycle through predefined layouts
bind -r Escape nextl

# focus last pane
bind M-space last-pane

# copy clipboard selection into tmux buffer
# Why `run`?{{{
#
# To make the shell evaluate the command substitution.
#}}}
#   `--`?{{{
#
# The evaluation of the substitution command could start with a hyphen.
# And  if that  happens,  tmux could  parse  the  text as  an  option passed  to
# `set-buffer` (i.e. `-a`, `-b`, or `-n`).
#}}}
#   `-o`?{{{
#
# To make `$ xsel` output something.
#}}}
bind > run 'tmux set-buffer -- "$(xsel -o -b)"' \; display 'clipboard selection copied into tmux buffer'
# TODO: Implement the reverse; copy the last tmux buffer into the clipboard.
# Also, do the same, but for any tmux buffer (via choose-buffer).
# Have a look at the `M-y` and `M-Y` key bindings here:
# https://sunaku.github.io/tmux-yank-osc52.html

# We use `*` instead of `q` because it's more consistent with `#`.
# They  both show  information. Besides, if  I hit  `pfx q`  by accident  (which
# happens often), I won't be distracted by the panes numbers.
bind * displayp

bind ! show-messages

# Issue: tmux-fingers doesn't let us search outside the current screen.
# Solution: Install a key binding which lets us search through the scrollback buffer, in a Nvim buffer.
# Why `#{==:#{window_name},[capture]}`?{{{
#
# To prevent the key binding from capturing the same pane again and again, if we
# press it several times by accident.
#}}}
#   Ok, but isn't `#{m:#{pane_current_command},*vim}` already enough?{{{
#
# In this particular case, `#{pane_current_command}` is expanded into `zsh`, not `nvim`.
#
# MWE:
#
#     $ echo hello | vim -
#     :display '#{pane_current_command}'
#     zsh~
#
#     $ vim <(echo hello)
#     :display '#{pane_current_command}'
#     zsh~
#}}}
bind -n M-: if -F \
    '#{||:#{==:#{window_name},[capture]},#{||:#{m:*vim,#{pane_current_command}},#{==:#{pane_current_command},man}}}' \
    '' \
    'capture-pane -J -S - ; neww -n "[capture]" "tmux showb | nvim +\"call myfuncs#after_tmux_capture_pane()\" -"'
# What does `-J` do?{{{
#
# It joins wrapped lines.
#
# Suppose that we have a long line in a file, which doesn't fit on a single line
# of the terminal, but on two.
# If  you  run `$  cat  file`,  this too-long  line  will  be displayed  on  two
# consecutive lines of the terminal.
# Without `-J`, tmux  would copy – in  one of its buffers –  the two consecutive
# lines on two different lines.
#
# But that's not what we want.
# We want the buffer to join back these two lines, as they were originally in the file.
#}}}
#   `-S -`? {{{
#
# `-S` specifies the starting line number, from where to copy.
# The special value `-` refers to the start of the history.
# Without this, `capture-pane` would capture only from the first visible line in
# the pane; we want the *whole* scrollback buffer.
#}}}
# Why don't you use `splitw` instead of `neww`?{{{
#
# With `split-window`, you would also need to run `resize-pane -Z`.
# But what if there's already a zoomed pane in the current window?
# After quitting Nvim, the latter would be unzoomed.
# So, we use `neww` to preserve a possible zoomed pane in the current window.
#}}}
# Why do you use Nvim, and not Vim?{{{
#
# With Vim, you wouldn't be able to paste the clipboard selection after quitting.
#
# MWE:
#
#     $ tmux -Ltest -f/dev/null new
#     $ tmux splitw vim -Nu NONE
#     :call system('xclip -selection clipboard', 'hello')
#     :q
#     C-S-v
#     ''~
#     $ xclip -selection clipboard -o
#     Error: target STRING not available~
#
# It seems that the `$ xclip` process is  killed when we quit Vim, if the latter
# has been started by tmux instead of being directly started by the shell.
#
# I don't understand the cause of the issue.
# If you press `C-b ;` before quitting Vim, to focus back the pane where a shell
# is running, and execute `$ pidof xclip`, you'll get a pid.
# And if you use this pid in `$ pstree -s -p PID`, you'll get sth like this:
#
#     systemd(1)---lightdm(1008)---lightdm(1088)---upstart(1097)---xclip(12973)
#
# There's no  Vim or Tmux  process in  the parents of  `$ xclip`, so  the latter
# shouldn't care about what happens to the Vim process...
#
# ---
#
# I think the reason why it works in Nvim is given at `:h vim-differences`:
#
# > |system()|, |systemlist()| can run {cmd} directly (without 'shell')
#
# If you wanted to use Vim, you would need to start xclip without a shell.
# First, you could write the text in a file:
#
#     :let tempfile = tempname()
#     call writefile(split(@", '\n'), tempfile, 'b')
#
# then you could run:
#
#     :call job_start('xclip -selection clipboard ' . tempfile)
#
# Why writing the text in a file?
# Without a file, you would need a pipe; and a pipe can only be parsed by a shell.
# But remember that we need to avoid a shell to be spawned.
# So, no shell → no pipe → use a file.
#
# However, for some  reason, the job can't be started  from an autocmd listening
# to `VimLeave(Pre)`;  so, you would  need to make  your autocmd listen  to some
# other event like `TextYankPost`.
#}}}

# split window vertically / horizontally
#                   ┌ keep current working directory
#                   ├───────────────────────┐
bind -   splitw  -v -c '#{pane_current_path}'
bind |   splitw  -h -c '#{pane_current_path}'
bind _   splitw -fv -c '#{pane_current_path}'
bind '\' splitw -fh -c '#{pane_current_path}'

# bring arbitrary pane in current window
bind [ command-prompt -p 'join pane from:'  "join-pane -s '%%'"
# send current pane in arbitrary window
bind ] command-prompt -p 'send pane to:'  "join-pane -t '%%'"

# Why a space before every shell command (` cmus`, ` weechat`, ...)?{{{
#
# It's useful  to prevent  zsh from saving  the command in  the history  when we
# cancel the search with `C-c` or `C-d` (`setopt HIST_IGNORE_SPACE`).
#}}}
# What's the `-n` option passed to `neww`?{{{
#
# It sets the name of the window.
#}}}
# What about the `-c` option?{{{
#
# It sets the cwd of the shell.
#}}}
bind M-1 rename -t 0 fun \; \
    renamew -t 1 music \; \
    send ' cmus' 'Enter' '2' 'Enter' 'Enter' \; \
    neww -n irc -c $HOME \; \
    send ' weechat' 'Enter' \; \
    new -s study \; \
    send ' nv' 'Enter' \; \
    neww -n fm -c $HOME \; \
    send ' fm' 'Enter' \; \
    selectw -t 1

# jump Back to the Beginning of the previous shell command{{{
#
# Look  for the  previous shell  prompt, to  get to  the beginning  of the  last
# command output. After  pressing the key binding,  you can visit all  the other
# prompts by pressing `n` or `N`.
#
# We've included a no-break space inside our shell prompt, and we use it here as
# our search pattern.
#
# Inspiration: https://www.youtube.com/watch?v=uglorjY0Ntg
#}}}
bind b copy-mode \; send -X start-of-line \; send -X search-forward '٪'
#      │            │                        │{{{
#      │            │                        └ search backward for the pattern `٪`
#      │            └ move cursor at the beginning of the line
#      └ enter copy mode
#}}}

# Note that `clear-history` doesn't clear *all* the history.{{{
#
# The last lines of the scrollback buffer which fits in one screen are preserved.
# So, if you enter copy mode, you'll still  be able to scroll back *some* lines,
# but not more than a few dozens.
#}}}
# We  can't use  `C-l` for the  lhs, because  we already use  it in  another key
# binding:
#     bind -r C-l resizep -R 5
bind C-c send C-l \; clear-history
#             │      │
#             │      └ clear tmux scrollback buffer
#             └ clear terminal screen

# We could  use `q`  and `Q`  instead to be  more consistent  with Vim,  but the
# problem is that we often press those key sequences by accident.
# So we use `C-d` and `M-d` instead for the moment.
bind C-d killp
bind M-d killw

# Why `TERM="#{client_terminal}"` in the 'sourced files' entry?{{{
#
# When `$  tmux -v -Ldm` is  started, it inherits  the TERM of the  current tmux
# server, which is set by 'default-terminal'.
# As a  result, the condition `[  if '[ "$TERM" !=  "#{default-terminal}" ]'` is
# true, and several files which we expect to be sourced, won't be sourced.
#
# We want to see all files which would be sourced, if we were to start tmux from
# a regular shell; so we need to reset TERM.
#}}}
bind i display-menu -y S \
    'server information' i info \
    'key bindings' k lsk \
    'aliases' a { run 'tmux show-options -sv command-alias | column -t -s=' } \
    'sourced files' f { run 'cd "$(mktemp -d /tmp/.tmux.XXXXXXXXXX)" \
        ; TERM="#{client_terminal}" tmux -v -Ldm start \
        ; grep loading tmux-server*.log | grep -v grep | sed "s/.*loading \(.*\)/\1/"' } \
    '' \
    'server options' C-s { show -s } \
    'global session options' s { show -g } \
    'local session options' S { show } \
    '' \
    'global window options' w { show -gw } \
    'local window options' W { show -w } \
    '' \
    'global hooks' h { show-hooks -g } \
    'local hooks' H { show-hooks } \
    '' \
    'global environment' e { showenv -g } \
    'local environment' E { showenv } \
    '' \
    'outer terminfo description' t { run 'infocmp -x #{client_termname}' } \
    'inner terminfo description' T { run 'infocmp -x #{default-terminal}' } \
    '' \
    'default settings' d { display-menu -y S \
        'key bindings' k { run 'tmux -Ldm -f/dev/null start \; lsk' } \
        'aliases' a { run 'tmux -Ldm -f/dev/null start \; show-options -sv command-alias | column -t -s=' } \
        '' \
        'server options' C-s { run 'tmux -Ldm -f/dev/null start \; show -s' } \
        'window options' w { run 'tmux -Ldm -f/dev/null start \; show -gw' } \
        'session options' s { run 'tmux -Ldm -f/dev/null start \; show -g' } \
    }

# By default, `detach-session` is bound to `d`.
# I find that too easy to press, so we move it to `@`.
# Why `@`?
# I didn't find anything better, and it seems hard to press by accident...
bind @ detach

# Where can I find more information about this `USR2` signal?{{{
#
# `$ man tmux /-v`:
#
# > The SIGUSR2 signal may be sent to the tmux server process
# > to toggle logging between on (as if -v was given) and off.
#}}}
# Why do you use `USR2` instead of `SIGUSR2`?{{{
#
# Because `run` invokes sh, not bash.
# And in sh, you need to remove the `SIG` prefix.
# https://unix.stackexchange.com/a/199384/289772
#}}}
# Where is the logfile written?{{{
#
# In the cwd of the shell from which you started tmux.
# It is *not* written in the cwd of the shell in which you press the key binding.
# IOW, it's most probably written in you $HOME.
#}}}
bind L display 'Toggled tmux server logging' \; run 'kill -s USR2 $(ps -o ppid= $$)'

# resize pane
bind -r C-h resizep -L 5
bind -r C-j resizep -D 5
bind -r C-k resizep -U 5
bind -r C-l resizep -R 5

# focus neighboring panes
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R

# Toggle mouse.
# Temporarily preventing  tmux from  handling the  mouse can  be useful  in some
# terminals to copy text in the clipboard.
# Why `M` for the lhs?{{{
#
# It provides a good mnemonic for “mouse”.
# I don't use `C-m` nor `M-m` because, atm, they're used to display some default menus.
#
# However, note that `pfx M` is used by default to clear the marked pane (`select-pane -M`).
# It's not a big deal to lose it, because we can get the same result by focusing
# the marked pane and then pressing `pfx m` (`select-pane -m`).
# The latter marks the pane if it's not already, or clears the mark otherwise.
#}}}
bind M set -g mouse \; if 'tmux show-options -g mouse | grep on' 'display "Mouse: ON"' 'display "Mouse: OFF"'

# paste last tmux buffer
# Do *not* choose a key too easy to type.{{{
#
# It's dangerous.
# In Vim, the contents  of the buffer will be typed,  which will have unexpected
# results, unless you're in insert mode.
#}}}
bind C-p paste-buffer -p

# choose and paste arbitrary tmux buffer
# What's `-Z`?{{{
#
# It makes tmux zoom the pane so that it takes the whole window.
#}}}
#   `-F`?{{{
#
# It specifies the format with which each buffer should be displayed.
# In it, you can use these replacement variables:
#
#    ┌────────────────┬─────────────────────────────┐
#    │ buffer_created │ creation date of the buffer │
#    ├────────────────┼─────────────────────────────┤
#    │ buffer_name    │ name of the buffer          │
#    ├────────────────┼─────────────────────────────┤
#    │ buffer_sample  │ starting text of the buffer │
#    ├────────────────┼─────────────────────────────┤
#    │ buffer_size    │ size of the buffer          │
#    └────────────────┴─────────────────────────────┘
#
# Note that  even with an empty  format, tmux will  still display the name  of a
# buffer followed by a colon.
# So, `buffer_name` is  not very useful (unless you want to print  the name of a
# buffer twice).
#}}}
#   the `-p` argument passed to `paste-buffer`?{{{
#
# It prevents the shell from  automatically running a pasted text which contains
# a newline.
#
# See `$ man tmux /paste-buffer`
#}}}
bind p choose-buffer -Z -F '#{buffer_sample}' "paste-buffer -p -b '%%'"

# similar to `C-w r` and `C-w R` in Vim
bind -r r rotate-window -D \; selectp -t +1
bind -r R rotate-window -U \; selectp -t -1

# reload tmux config
bind C-r source "$HOME/.tmux.conf" \; display 'Configuration reloaded.'

bind T breakp

# You need to install the `urlview` package for this key binding to work.
# Source: https://github.com/tmux-plugins/tmux-urlview/blob/b84c876cffdd22990b4ab51247e795cbd7813d53/urlview.tmux#L28-L31
bind u capture-pane \; \
       save-buffer /tmp/.tmux-buffer \; \
       delete-buffer \; \
       splitw -l 10 '$SHELL -c "urlview </tmp/.tmux-buffer"'

# similar to `C-w x` in Vim
bind x swapp -U
bind X swapp -D
# }}}1
# Hooks {{{1

# Don't use this hook! `set-hook -g after-split-window 'selectl even-vertical'`{{{
#
# You wouldn't be able to split vertically anymore.
# Splitting vertically would result in an horizontal split no matter what.
#
# The hook  is given as  an example in  `$ man tmux`;  its purpose is  to resize
# equally all the panes whenever you split a pane horizontally.
#}}}

set-hook -g pane-focus-out ''
# Ignore the activity in a (N)Vim/cmus/mpv/newsboat/weechat window.
# What's `#{?var,off,on}`?{{{
#
# A replacement variable, using a conditional operator.
# It will  be replaced with  'off' if `var` evaluates  to anything else  than 0,
# 'on' otherwise.
#
# Here `var` is:
#
#     #{||:#{m:*vim,#{pane_current_command}},#{==:cmus,#{pane_current_command}} }
#}}}
#   `#{||:var1,var2}`?{{{
#
# A replacement variable  which will be evaluated  to true if any  of `var1` and
# `var2` is true.
#
# Here, `var1` is:
#
#     #{m:*vim,#{pane_current_command}}
#
# And `var2` is:
#
#     #{==:cmus,#{pane_current_command}}
#}}}
#   `#{m:pat,str}`?{{{
#
# A replacement variable which will be evaluated to true if `pat` matches `str`.
# Here, `pat` is `*vim`, and `str` is `#{pane_current_command}`.
#}}}
#   `#{==:str1,str2}`?{{{
#
# A replacement variable which will be evaluated to true if `str1` and `str2` are identical.
# Here, `str1` is `#{pane_current_command}`, and `str2` is `cmus`.
#}}}
is_distraction='#{||:#{==:#{pane_current_command},cmus},#{||:#{==:#{pane_current_command},mpv},#{||:#{==:#{pane_current_command},newsboat},#{==:#{pane_current_command},weechat}}}}'
set-hook -ga pane-focus-out \
    'setw -F monitor-activity \
        "#{?#{||:#{m:*vim,#{pane_current_command}},$is_distraction},off,on}"'
setenv -gu is_distraction
# TODO: Ask nicm whether `#{||:}` could be made to accept more than two operands.
# It would make the code more readable/maintainable.

set-hook -ga pane-focus-out 'run "echo hello"'
set-hook -ga pane-focus-out 'run "echo world"'

# Do *not* add a space in-between three consecutive `}`.{{{
#
# For example, if you exchange the position of `#{pane_current_command}` and `cmus`:
#
#     "#{?#{||:#{m:*vim,#{pane_current_command}},#{==:cmus,#{pane_current_command} }},off,on}"'
#                                                                                 ^
#                                                                                 ✘
#
# It would be tempting to add a space to prevent Vim from detecting the end of a fold.
# Unfortunately, it  would also break  the hook,  probably because the  space is
# semantic in this position; same thing after the second `}`.
#}}}

# Plugins {{{1

# Why the guard?{{{
#
# To  prevent the plugins  from re-installing their  key bindings every  time we
# resource tmux.conf.
# Indeed, we only unbind the key bindings from the copy-mode table once.
#
# Besides, it's probably a bad idea to resource plugins.
#}}}
if '[ "$TERM" != "#{default-terminal}" ]' { source-file "$HOME/.tmux/plugins/run" }

# Rebind {{{1

# Purpose:{{{
#
# The tmux-yank plugin installs this key binding:
#
#     bind-key -T copy-mode-vi Y  send-keys -X copy-pipe-and-cancel "tmux paste-buffer"
#
# It copies the selection, quit copy mode, then paste the buffer.
#
# However, it doesn't support the bracketed paste mode.
# So we  redefine the key binding,  and pass `-p` to  `paste-buffer` to surround
# the text with the sequences `Esc [ 200 ~` and `Esc [ 201 ~`.
# This way, if we  select a text containing a newline, then  press `Y`, it's not
# automatically run by the shell.
#
# From `$ man tmux /paste-buffer`:
#
# > If -p  is specified,  paste bracket  control codes  are inserted  around the
# > buffer if the application has requested bracketed paste mode.
#
# Note that this requires that the shell supports the bracketed paste mode.
# I.e. if you're using  zsh, you need zsh version 5.1 or  greater, and if you're
# using bash, you need bash 4.4 or greater.
#
# ---
#
# The `-p` option was added to tmux in the commit `f4fdddc`.
# According to the changelog, this was somewhere between tmux 1.6 and 1.7.
#
# ---
#
# Note that  the original key binding used `copy-pipe-and-cancel`  which – while
# working – doesn't make sense; you can't pipe anything to `$ tmux paste-buffer`,
# since it doesn't read its input.
#}}}
bind -T copy-mode-vi Y send -X copy-selection-and-cancel \; paste-buffer -p
#                                                                        ^^

# Unbind {{{1

# How to find the default key bindings installed with no config?{{{
#
#     $ tmux -Ltest -f/dev/null new
#     C-b ?
#     VG$
#     Enter
#     $ vim
#     i
#     C-b ]
#
# Make sure to release `Ctrl` before pressing `]`.
#}}}
# How to unbind `#`, `~`, `'`, `"`?{{{
#
# Quote the key (with single or double quotes).
#
# From `$ man tmux /KEY BINDINGS`:
# > Note that to bind the ‘"’ or ‘'’ keys, quotation marks are necessary.
#}}}
# How to unbind `;`?{{{
#
# Escape it.
#
# From `$ man tmux /COMMANDS`:
# > A literal  semicolon may be  included by escaping  it with a  backslash (for
# > example, when specifying a command sequence to bind-key).
#}}}

# TODO:
# Remove all default key bindings which you're not interested in.
# Some of them could be hit by accident.
# Keep only the ones you really use.
# Besides, it will give us a smaller table of key bindings, which will be easier
# to read when we have an issue with one of our key bindings.
# Have a look at `~/Desktop/tmux.md`.

# prefix {{{2

unbind C-b
# rotate-window -D
unbind C-o
# display-message
unbind '~'
# split-window
unbind '"'
# split-window -h
unbind %
# choose-buffer -Z
unbind =
# detach-client
unbind d
unbind n
# display-panes
unbind q
# swap-pane -U
# swap-pane -D
unbind '{'
unbind '}'
# select-pane -U
# select-pane -D
# select-pane -L
# select-pane -R
unbind Up
unbind Down
unbind Left
unbind Right
# tmux clear-history (tmux-logging)
unbind M-c
# rotate-window -D
unbind M-o
# resize-pane -U 5
unbind M-up
# resize-pane -D 5
unbind M-down
# resize-pane -L 5
unbind M-left
# resize-pane -R 5
unbind M-right
# resize-pane -U
# resize-pane -D
# resize-pane -L
# resize-pane -R
unbind C-Up
unbind C-Down
unbind C-Left
unbind C-Right
unbind M-p
unbind M-P
unbind P

# copy mode {{{2

# We don't need the key bindings from the copy-mode table; we use the copy-mode-*vi* table.
# Why the guard?{{{
#
# Once the table is empty, it's removed.
# So, if you later try to unbind a key binding from it, an error will be raised:
#
#     Table copy-mode doesn't exist
#
# Which can be repeated for every key binding you try to remove:
#
#     Table copy-mode doesn't exist
#     Table copy-mode doesn't exist
#     ...
#
# Run `show-messages` to see them.
#
# This is annoying when you reload tmux.conf.
#}}}
if '[ "$TERM" != "#{default-terminal}" ]' { source-file "$HOME/.tmux/unbind-copy-mode.conf" }
# }}}1

