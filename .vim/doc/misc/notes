==============================================================================
git

http://mislav.net/2014/02/hidden-documentation/
==============================================================================
Create Hyper modifier to install various global key bindings

https://www.reddit.com/r/vim/comments/5kgw7x/what_sort_of_vim_tricks_are_there_for_editing_text/dboofjy/

CapsLock is the  evil. Escape is an  improvement, but when you  realise that vim
was designed on a keyboard with the Ctrl key in that spot, default commands make
a lot more sense.

I have the CapsLock key function as Ctrl when held and Escape when tapped, using
xcape. It's beautiful. Here are my configs: .Xmodmap

clear      lock
clear   control
clear      mod1
clear      mod2
clear      mod3
clear      mod4
clear      mod5
keycode      37 = Hyper_L
add     control = Control_L Control_R
add        mod1 = Alt_L Alt_R Meta_L
add        mod2 = Num_Lock
add        mod3 = Hyper_L
add        mod4 = Super_L Super_R
add        mod5 = Mode_switch ISO_Level3_Shift

(This also makes the physical Ctrl key "Hyper"; a long-forgotten modifier, that you can use to bind a plethora of global binds if you want)

Oh, another cool thing; you can still keep Capslock when the key is rebound; press both shift keys!

setxkbmap us -option ctrl:nocaps -option shift:both_capslock

.xinitrc

xmodmap ~/.Xmodmap &
xcape -t 170 &
setxkbmap us -option ctrl:nocaps -option shift:both_capslock

(the -t 170 flag gives a timeout; here, it will only register quick taps as Escape. Adjust to taste)
==============================================================================
There are inconsistencies between the different implementations of the modulo
operation over negative numbers, depending on the compiler, environment,
programming language…

    http://stackoverflow.com/questions/4467539/javascript-modulo-not-behaving#comment4882815_4467559
    https://www.reddit.com/r/vim/comments/4lfc4v/psa_modulo_returns_negative_numbers/d3mwlds/
    http://stackoverflow.com/a/11720975

    $ perl -E 'say -10 % 3'              →  2
    $ perl -Minteger -E 'say -10 % 3'    → -1

In VimL, when we use the modulo operation over a negative number, it seems we get a negative
result:
        :echo -5%4    →    -1

In math, we would get a positive one (3).

What's the solution to get back consistency across all programming languages and environment?
Use the formula described here:
http://javascript.about.com/od/problemsolving/a/modulobug.htm

    ((n%p)+p)%p

… where `n` and `p` are resp. a negative and positive number.

Adding `p` converts a possible negative result given by the modulo
operator into a positive number:

    if     (-5 % 4)     = -1
    then   (-5 % 4) + 4 = 3

But adding `p` would give us a too big result if `n` was a positive
number, instead of being negative:

    (5 % 4) + 4 = 5

So we need the second modulo to cover both cases with the same
formula:

    ((5 % 4) + 4) % 4 = 1

==============================================================================
User Manual (Built-in)
:h usr_toc.txt
:h quickref
:viu[sage]
:exu[sage]

https://romainl.github.io/the-patient-vimmer/1.html
https://bling.github.io/blog/2013/08/16/modularizing-vimscript/
https://ujihisa.blogspot.fr/2010/11/something-like-closure-for-vim-script.html

http://eduncan911.com/software/fix-slow-scrolling-in-vim-and-neovim.html
:syntime on
:syntime report
:set lazyredraw

:set synmaxcol=128
:syntax sync minlines=256

==============================================================================
'scrollbind' 'scb' option locale à la fenêtre, off par défaut
Toutes les fenêtres pour lesquelles cette option est active scrollent de façon synchronisée.


'scrollopt' 'sbo'   string  (default 'ver,jump')
            global

    This is a comma-separated list of words that specifies how
    'scrollbind' windows should behave.  'sbo' stands for ScrollBind
    Options. The following words are available:

        ver     Bind vertical scrolling for 'scrollbind' windows

        hor     Bind horizontal scrolling for 'scrollbind' windows

        jump    Applies to the offset between two windows for vertical
                scrolling.  This offset is the difference in the first
                displayed line of the bound windows.  When moving
                around in a window, another 'scrollbind' window may
                reach a position before the start or after the end of
                the buffer.  The offset is not changed though, when
                moving back the 'scrollbind' window will try to scroll
                to the desired position when possible.
                When now making that window the current one, two
                things can be done with the relative offset:

                1. When "jump" is not included, the relative offset is
                   adjusted for the scroll position in the new current
                   window.  When going back to the other window, the
                   new relative offset will be used.

                2. When "jump" is included, the other windows are
                   scrolled to keep the same relative offset.  When
                   going back to the other window, it still uses the
                   same relative offset.

    Also see |scroll-binding|.
    When 'diff' mode is active there always is vertical scroll binding,
    even when "ver" isn't there.


'scrolljump' 'sj'   number  (default 1)
            global

    Minimal number of lines to scroll when the cursor gets off the
    screen (e.g., with "j").  Not used for scroll commands (e.g., CTRL-E,
    CTRL-D).  Useful if your terminal scrolls very slowly.
    When set to a negative number from -1 to -100 this is used as the
    percentage of the window height.  Thus -50 scrolls half the window
    height.
    NOTE: This option is set to 1 when 'compatible' is set.


'scrolloff' 'so'    number  (default 0)
            global

    Minimal number of screen lines to keep above and below the cursor.
    This will make some context visible around where you are working.  If
    you set it to a very large value (999) the cursor line will always be
    in the middle of the window (except at the start or end of the file or
    when long lines wrap).
    For scrolling horizontally see 'sidescrolloff'.
    NOTE: This option is set to 0 when 'compatible' is set.


'sidescroll' 'ss'   number  (default 0)
            global

    The minimal number of columns to scroll horizontally.  Used only when
    the 'wrap' option is off and the cursor is moved off of the screen.
    When it is zero the cursor will be put in the middle of the screen.
    When using a slow terminal set it to a large number or 0.  When using
    a fast terminal use a small number or 1.  Not used for "zh" and "zl"
    commands.


'sidescrolloff' 'siso'  number (default 0)
            global

    The minimal number of screen columns to keep to the left and to the
    right of the cursor if 'nowrap' is set.  Setting this option to a
    value greater than 0 while having |'sidescroll'| also at a non-zero
    value makes some context visible in the line you are scrolling in
    horizontally (except at beginning of the line).  Setting this option
    to a large value (like 999) has the effect of keeping the cursor
    horizontally centered in the window, as long as one does not come too
    close to the beginning of the line.
    NOTE: This option is set to 0 when 'compatible' is set.

    Example: Try this together with 'sidescroll' and 'listchars' as
         in the following example to never allow the cursor to move
         onto the "extends" character:

         :set nowrap sidescroll=1 listchars=extends:>,precedes:<
         :set sidescrolloff=1
==============================================================================
List modification ~

    :call sort(list)                " sort a list alphabetically
    :call uniq(sort(list))          " sort and remove duplicates

    uniq(list[, func, dict])

        retourne   list,  mais   qd   un  item   se   répète  plusieurs   fois
        consécutivement, seule la 1e occurrence  est conservée les autres sont
        supprimées

        La suppression est faite in-place ; utiliser copy() pour conserver list intacte.
        Par défaut, la comparaison utilise la représentation sous forme de chaîne de chaque item.

        For the use of {func} and {dict} see |sort()|.

    :[range]sort[!] [iurn] [/pattern/]

        trie les lignes du buffer

        NOTE:
        • Si un pattern vide est fourni //, il est remplacé par la dernière recherche

        • Si un pattern est utilisé et que des lignes ne le contiennent pas:
          leur ordre est préservé (ou inversé avec un bang: sort!),
          mais elles sont déplacées avant les lignes qui matchent pattern.

        • ! inverse l'ordre de tri
        • si aucune rangée n'est fournie, toutes les lignes du buffer sont triées

    :sort /[^,]*,/

        trier toutes les lignes du buffer en fonction du texte situé après la 1e virgule (2e champ)

    :.,$!sort -k2 -r    :.,$sort! /\S\+\s\+/

        trier les lignes depuis la courante jusqu'à la dernière, en fonction du 2e champ et en inversant
        l'ordre du tri

    :%!sort -k3 -t,    :sort /\v([^,]*,){2}/

        trier en fonction du texte situé dans le 3e champ (les champs étant délimités par des virgules)

    :10,20 sort! /\a\a\a/ r

        trier les lignes 10 à 20 en fonction de leurs 3 premières lettres en inversant l'ordre de tri

        ! inverse l'ordre de tri

        r  effectue  le  tri  en  fonction du  texte  contenu  dans  le  pattern
        (autrement le tri commence après le pattern)

        Il existe d'autres flags intéressants (en + de r):

                i    ignore case
                n    sort on first decimal number
                u    uniq (only keep the 1st of a sequence of identical lines)

    :sort /.\{-}\ze\d/

        trier en fonction du 1er nb sur la ligne

        /.\{-}\ze\d/ élimine tout le texte qui précède le 1er chiffre
        en excluant/préservant (\ze) ce dernier

        FIXME: Ne semble pas très fiable. Tester là-dessus:

                foo 69
                bar 9
                baz 19

        Plus fiable:

                %!sort -rn -k2

        Tri numérique (-n), inversé (-r) sur le 2e champ (-k2).

    sort(mylist)

        retourne mylist triée

        NOTE:

        • Le tri est réalisé sur place / in-place.
          Pour éviter de modifier mylist: sort(copy(mylist))

        • Le tri utilise la représentation sous forme de chaîne de chaque item.
          Ceci implique pex que 123 apparaîtra avant 21 (pour trier des nombres, utiliser le 2e argument 'n').

        • Si my list contient un mélange de chaînes, nb et listes, ils sont triés de la façon suivante:

                chaînes > nb > listes

        • Le tri est stable: deux items considérés comme égaux conservent leur position relative.

    sort(mylist, 'i')

        retourne mylist triée, en ignorant la casse

    sort(mylist, 'n')    sort(mylist, 'N')

        retourne mylist triée, en utilisant un tri numérique et non la représentation sous forme de chaîne
        Les chaînes, listes, dictionnaires, références de fonctions sont tous considérés comme nuls.

        'N' réalise un tri numérique comme 'n' mais convertit en plus les chaînes contenant des nbs en ces derniers.

    sort(mylist, 'MySort')

        retourne mylist triée, en utilisant la fonction MySort() ou la funcref MySort pour comparer 2 éléments

        MySort() doit accepter 2 arguments, et retourner 0 qd ils sont égaux, un nb >=1 qd le 1er est trié
        après le 2nd, un nb <=-1 autrement.

        Ex de fonction de tri custom:

                fu! MySort(i1, i2)
                    return a:i1 - a:i2
                    " ou return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
                endfu

==============================================================================
*41.8*  Lists and Dictionaries

DICTIONARIES

    :let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}

DICTIONARY FUNCTIONS

And now for something special: you can directly define a function and store a
reference to it in the dictionary: >

    :function uk2nl.translate(line) dict
    :  return join(map(split(a:line), 'get(self, v:val, "???")'))
    :endfu

Let's first try it out: >

    :echo uk2nl.translate('three two five one')
<   drie twee ??? een ~

The first special thing you notice is the "dict" at the end of the ":function"
line.  This marks the function as being used from a Dictionary.  The "self"
local variable will then refer to that Dictionary.

The get() function checks if a key is present in a Dictionary.  If it is, then
the value is retrieved.  If it isn't, then the default value is returned, in
the example it's '???'.  This is a convenient way to handle situations where a
key may not be present and you don't want an error message.

This combination of split(), map() and join() is a nice way to filter a line
of words in a very compact way.


OBJECT ORIENTED PROGRAMMING

Now that you can put both values and functions in a Dictionary, you can
actually use a Dictionary like an object.
   Above we used a Dictionary for translating Dutch to English.  We might want
to do the same for other languages.  Let's first make an object (aka
Dictionary) that has the translate function, but no words to translate: >

    :let transdict = {}
    :function transdict.translate(line) dict
    :  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
    :endfu

It's slightly different from the function above, using 'self.words' to lookup
word translations.  But we don't have a self.words.  Thus you could call this
an abstract class.

Now we can instantiate a Dutch translation object: >

    :let uk2nl = copy(transdict)
    :let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
    :echo uk2nl.translate('three one')
<   drie een ~

And a German translator: >

    :let uk2de = copy(transdict)
    :let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}
    :echo uk2de.translate('three one')
<   drei ein ~

You see that the copy() function is used to make a copy of the "transdict"
Dictionary and then the copy is changed to add the words.  The original
remains the same, of course.

Now you can go one step further, and use your preferred translator: >

    :if $LANG =~ "de"
    :  let trans = uk2de
    :else
    :  let trans = uk2nl
    :endif
    :echo trans.translate('one two three')
<   een twee drie ~

Here "trans" refers to one of the two objects (Dictionaries).  No copy is
made.  More about List and Dictionary identity can be found at |list-identity|
and |dict-identity|.

Now you might use a language that isn't supported.  You can overrule the
translate() function to do nothing: >

    :let uk2uk = copy(transdict)
    :fu! uk2uk.translate(line)
    :  return a:line
    :endfu
    :echo uk2uk.translate('three one wladiwostok')
<   three one wladiwostok ~

Notice that a ! was used to overwrite the existing function reference.  Now
use "uk2uk" when no recognized language is found: >

    :if $LANG =~ "de"
    :  let trans = uk2de
    :elseif $LANG =~ "nl"
    :  let trans = uk2nl
    :else
    :  let trans = uk2uk
    :endif
    :echo trans.translate('one two three')
<   one two three ~

==============================================================================
*41.9*  Exceptions

Let's start with an example: >

    :try
    :   read ~/templates/pascal.tmpl
    :catch /E484:/
    :   echo "Sorry, the Pascal template file cannot be found."
    :endtry

The ":read" command will fail if the file does not exist.  Instead of
generating an error message, this code catches the error and gives the user a
nice message.

For the commands in between ":try" and ":endtry" errors are turned into
exceptions.  An exception is a string.  In the case of an error the string
contains the error message.  And every error message has a number.  In this
case, the error we catch contains "E484:".  This number is guaranteed to stay
the same (the text may change, e.g., it may be translated).

When the ":read" command causes another error, the pattern "E484:" will not
match in it.  Thus this exception will not be caught and result in the usual
error message.

You might be tempted to do this: >

    :try
    :   read ~/templates/pascal.tmpl
    :catch
    :   echo "Sorry, the Pascal template file cannot be found."
    :endtry

This means all errors are caught.  But then you will not see errors that are
useful, such as "E21: Cannot make changes, 'modifiable' is off".

Another useful mechanism is the ":finally" command: >

    :let tmp = tempname()
    :try
    :   exe ".,$write " . tmp
    :   exe "!filter " . tmp
    :   .,$delete
    :   exe "$read " . tmp
    :finally
    :   call delete(tmp)
    :endtry

This filters the lines from the cursor until the end of the file through the
"filter" command, which takes a file name argument.  No matter if the
filtering works, something goes wrong in between ":try" and ":finally" or the
user cancels the filtering by pressing CTRL-C, the "call delete(tmp)" is
always executed.  This makes sure you don't leave the temporary file behind.

More information about exception handling can be found in the reference
manual: |exception-handling|.

==============================================================================
*41.10* Various remarks

Here is a summary of items that apply to Vim scripts.  They are also mentioned
elsewhere, but form a nice checklist.

The end-of-line character depends on the system.  For Unix a single <NL>
character is used.  For MS-DOS, Windows, OS/2 and the like, <CR><LF> is used.
This is important when using mappings that end in a <CR>.  See |:source_crnl|.


WHITE SPACE

Blank lines are allowed and ignored.

Leading whitespace characters (blanks and TABs) are always ignored.  The
whitespaces between parameters (e.g. between the 'set' and the 'cpoptions' in
the example below) are reduced to one blank character and plays the role of a
separator, the whitespaces after the last (visible) character may or may not
be ignored depending on the situation, see below.

For a ":set" command involving the "=" (equal) sign, such as in: >

    :set cpoptions    =aABceFst

the whitespace immediately before the "=" sign is ignored.  But there can be
no whitespace after the "=" sign!

To include a whitespace character in the value of an option, it must be
escaped by a "\" (backslash)  as in the following example: >

    :set tags=my\ nice\ file

The same example written as: >

    :set tags=my nice file

will issue an error, because it is interpreted as: >

    :set tags=my
    :set nice
    :set file


COMMENTS

The character " (the double quote mark) starts a comment.  Everything after
and including this character until the end-of-line is considered a comment and
is ignored, except for commands that don't consider comments, as shown in
examples below.  A comment can start on any character position on the line.

There is a little "catch" with comments for some commands.  Examples: >

    :abbrev dev development     " shorthand
    :map <F3> o#include     " insert include
    :exe cmd            " do it
    :!ls *.c            " list C files

The abbreviation 'dev' will be expanded to 'development     " shorthand'.  The
mapping of <F3> will actually be the whole line after the 'o# ....' including
the '" insert include'.  The "execute" command will give an error.  The "!"
command will send everything after it to the shell, causing an error for an
unmatched '"' character.
   There can be no comment after ":map", ":abbreviate", ":execute" and "!"
commands (there are a few more commands with this restriction).  For the
":map", ":abbreviate" and ":execute" commands there is a trick: >

    :abbrev dev development|" shorthand
    :map <F3> o#include|" insert include
    :execute cmd            |" do it

With the '|' character the command is separated from the next one.  And that
next command is only a comment.  For the last command you need to do two
things: |:execute| and use '|': >
    :exe '!ls *.c'          |" list C files

Notice that there is no white space before the '|' in the abbreviation and
mapping.  For these commands, any character until the end-of-line or '|' is
included.  As a consequence of this behavior, you don't always see that
trailing whitespace is included: >

    :map <F4> o#include

To spot these problems, you can set the 'list' option when editing vimrc
files.

For Unix there is one special way to comment a line, that allows making a Vim
script executable: >
    #!/usr/bin/env vim -S
    echo "this is a Vim script"
    quit

The "#" command by itself lists a line with the line number.  Adding an
exclamation mark changes it into doing nothing, so that you can add the shell
command to execute the rest of the file. |:#!| |-S|


PITFALLS

Even bigger problem arises in the following example: >

    :map ,ab o#include
    :unmap ,ab

Here the unmap command will not work, because it tries to unmap ",ab ".  This
does not exist as a mapped sequence.  An error will be issued, which is very
hard to identify, because the ending whitespace character in ":unmap ,ab " is
not visible.

And this is the same as what happens when one uses a comment after an 'unmap'
command: >

    :unmap ,ab     " comment

Here the comment part will be ignored.  However, Vim will try to unmap
',ab     ', which does not exist.  Rewrite it as: >

    :unmap ,ab|    " comment


RESTORING THE VIEW

Sometimes you want to make a change and go back to where the cursor was.
Restoring the relative position would also be nice, so that the same line
appears at the top of the window.
   This example yanks the current line, puts it above the first line in the
file and then restores the view: >

    map ,p ma"aYHmbgg"aP`bzt`a

What this does: >
    ma"aYHmbgg"aP`bzt`a
<   ma          set mark a at cursor position
      "aY           yank current line into register a
         Hmb        go to top line in window and set mark b there
        gg      go to first line in file
          "aP       put the yanked line above it
             `b     go back to top line in display
               zt   position the text in the window as before
             `a go back to saved cursor position


PACKAGING

To avoid your function names to interfere with functions that you get from
others, use this scheme:
- Prepend a unique string before each function name.  I often use an
  abbreviation.  For example, "OW_" is used for the option window functions.
- Put the definition of your functions together in a file.  Set a global
  variable to indicate that the functions have been loaded.  When sourcing the
  file again, first unload the functions.
Example: >

    " This is the XXX package

    if exists("XXX_loaded")
      delfun XXX_one
      delfun XXX_two
    endif

    function XXX_one(a)
        ... body of function ...
    endfu

    function XXX_two(b)
        ... body of function ...
    endfu

    let XXX_loaded = 1

==============================================================================
*41.11* Writing a plugin

You can write a Vim script in such a way that many people can use it.  This is
called a plugin.  Vim users can drop your script in their plugin directory and
use its features right away |add-plugin|.

There are actually two types of plugins:

  global plugins: For all types of files.
filetype plugins: Only for files of a specific type.

In this section the first type is explained.  Most items are also relevant for
writing filetype plugins.  The specifics for filetype plugins are in the next
section |write-filetype-plugin|.


NAME

First of all you must choose a name for your plugin.  The features provided
by the plugin should be clear from its name.  And it should be unlikely that
someone else writes a plugin with the same name but which does something
different.  And please limit the name to 8 characters, to avoid problems on
old Windows systems.

A script that corrects typing mistakes could be called "typecorr.vim".  We
will use it here as an example.

For the plugin to work for everybody, it should follow a few guidelines.  This
will be explained step-by-step.  The complete example plugin is at the end.


BODY

Let's start with the body of the plugin, the lines that do the actual work: >

 14 iabbrev teh the
 15 iabbrev otehr other
 16 iabbrev wnat want
 17 iabbrev synchronisation
 18     \ synchronization
 19 let s:count = 4

The actual list should be much longer, of course.

The line numbers have only been added to explain a few things, don't put them
in your plugin file!


HEADER

You will probably add new corrections to the plugin and soon have several
versions lying around.  And when distributing this file, people will want to
know who wrote this wonderful plugin and where they can send remarks.
Therefore, put a header at the top of your plugin: >

  1 " Vim global plugin for correcting typing mistakes
  2 " Last Change:  2000 Oct 15
  3 " Maintainer:   Bram Moolenaar <Bram@vim.org>

About copyright and licensing: Since plugins are very useful and it's hardly
worth restricting their distribution, please consider making your plugin
either public domain or use the Vim |license|.  A short note about this near
the top of the plugin should be sufficient.  Example: >

  4 " License:  This file is placed in the public domain.


LINE CONTINUATION, AVOIDING SIDE EFFECTS        *use-cpo-save*

In line 18 above, the line-continuation mechanism is used |line-continuation|.
Users with 'compatible' set will run into trouble here, they will get an error
message.  We can't just reset 'compatible', because that has a lot of side
effects.  To avoid this, we will set the 'cpoptions' option to its Vim default
value and restore it later.  That will allow the use of line-continuation and
make the script work for most people.  It is done like this: >

 11 let s:save_cpo = &cpo
 12 set cpo&vim
 ..
 42 let &cpo = s:save_cpo
 43 unlet s:save_cpo

We first store the old value of 'cpoptions' in the s:save_cpo variable.  At
the end of the plugin this value is restored.

Notice that a script-local variable is used |s:var|.  A global variable could
already be in use for something else.  Always use script-local variables for
things that are only used in the script.


NOT LOADING

It's possible that a user doesn't always want to load this plugin.  Or the
system administrator has dropped it in the system-wide plugin directory, but a
user has his own plugin he wants to use.  Then the user must have a chance to
disable loading this specific plugin.  This will make it possible: >

  6 if exists("g:loaded_typecorr")
  7   finish
  8 endif
  9 let g:loaded_typecorr = 1

This also avoids that when the script is loaded twice it would cause error
messages for redefining functions and cause trouble for autocommands that are
added twice.

The name is recommended to start with "loaded_" and then the file name of the
plugin, literally.  The "g:" is prepended just to avoid mistakes when using
the variable in a function (without "g:" it would be a variable local to the
function).

Using "finish" stops Vim from reading the rest of the file, it's much quicker
than using if-endif around the whole file.


MAPPING

Now let's make the plugin more interesting: We will add a mapping that adds a
correction for the word under the cursor.  We could just pick a key sequence
for this mapping, but the user might already use it for something else.  To
allow the user to define which keys a mapping in a plugin uses, the <Leader>
item can be used: >

 22   map <unique> <Leader>a  <Plug>TypecorrAdd

The "<Plug>TypecorrAdd" thing will do the work, more about that further on.

The user can set the "mapleader" variable to the key sequence that he wants
this mapping to start with.  Thus if the user has done: >

    let mapleader = "_"

the mapping will define "_a".  If the user didn't do this, the default value
will be used, which is a backslash.  Then a map for "\a" will be defined.

Note that <unique> is used, this will cause an error message if the mapping
already happened to exist. |:map-<unique>|

But what if the user wants to define his own key sequence?  We can allow that
with this mechanism: >

 21 if !hasmapto('<Plug>TypecorrAdd')
 22   map <unique> <Leader>a  <Plug>TypecorrAdd
 23 endif

This checks if a mapping to "<Plug>TypecorrAdd" already exists, and only
defines the mapping from "<Leader>a" if it doesn't.  The user then has a
chance of putting this in his vimrc file: >

    map ,c  <Plug>TypecorrAdd

Then the mapped key sequence will be ",c" instead of "_a" or "\a".


PIECES

If a script gets longer, you often want to break up the work in pieces.  You
can use functions or mappings for this.  But you don't want these functions
and mappings to interfere with the ones from other scripts.  For example, you
could define a function Add(), but another script could try to define the same
function.  To avoid this, we define the function local to the script by
prepending it with "s:".

We will define a function that adds a new typing correction: >

 30 function s:Add(from, correct)
 31   let to = input("type the correction for " . a:from . ": ")
 32   exe ":iabbrev " . a:from . " " . to
 ..
 36 endfu

Now we can call the function s:Add() from within this script.  If another
script also defines s:Add(), it will be local to that script and can only
be called from the script it was defined in.  There can also be a global Add()
function (without the "s:"), which is again another function.

<SID> can be used with mappings.  It generates a script ID, which identifies
the current script.  In our typing correction plugin we use it like this: >

 24 noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 ..
 28 noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>

Thus when a user types "\a", this sequence is invoked: >

    \a  →  <Plug>TypecorrAdd  →  <SID>Add  →  :call <SID>Add()

If another script would also map <SID>Add, it would get another script ID and
thus define another mapping.

Note that instead of s:Add() we use <SID>Add() here.  That is because the
mapping is typed by the user, thus outside of the script.  The <SID> is
translated to the script ID, so that Vim knows in which script to look for
the Add() function.

This is a bit complicated, but it's required for the plugin to work together
with other plugins.  The basic rule is that you use <SID>Add() in mappings and
s:Add() in other places (the script itself, autocommands, user commands).

We can also add a menu entry to do the same as the mapping: >

 26 noremenu <script> Plugin.Add\ Correction      <SID>Add

The "Plugin" menu is recommended for adding menu items for plugins.  In this
case only one item is used.  When adding more items, creating a submenu is
recommended.  For example, "Plugin.CVS" could be used for a plugin that offers
CVS operations "Plugin.CVS.checkin", "Plugin.CVS.checkout", etc.

Note that in line 28 ":noremap" is used to avoid that any other mappings cause
trouble.  Someone may have remapped ":call", for example.  In line 24 we also
use ":noremap", but we do want "<SID>Add" to be remapped.  This is why
"<script>" is used here.  This only allows mappings which are local to the
script. |:map-<script>|  The same is done in line 26 for ":noremenu".
|:menu-<script>|

                        *:map-<script>* *:map-script*
If the first argument to one of these commands is "<script>" and it is used to
define a new mapping or abbreviation, the mapping will only remap characters
in the {rhs} using mappings that were defined local to a script, starting with
"<SID>".  This can be used to avoid that mappings from outside a script
interfere (e.g., when CTRL-V is remapped in mswin.vim), but do use other
mappings defined in the script.
Note: ":map <script>" and ":noremap <script>" do the same thing.  The
"<script>" overrules the command name.  Using ":noremap <script>" is
preferred, because it's clearer that remapping is (mostly) disabled.


USER COMMAND

Now let's add a user command to add a correction: >

 38 if !exists(":Correct")
 39   command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40 endif

The user command is defined only if no command with the same name already
exists.  Otherwise we would get an error here.  Overriding the existing user
command with ":command!" is not a good idea, this would probably make the user
wonder why the command he defined himself doesn't work.  |:command|


SCRIPT VARIABLES

When a variable starts with "s:" it is a script variable.  It can only be used
inside a script.  Outside the script it's not visible.  This avoids trouble
with using the same variable name in different scripts.  The variables will be
kept as long as Vim is running.  And the same variables are used when sourcing
the same script again. |s:var|

The fun is that these variables can also be used in functions, autocommands
and user commands that are defined in the script.  In our example we can add
a few lines to count the number of corrections: >

 19 let s:count = 4
 ..
 30 function s:Add(from, correct)
 ..
 34   let s:count = s:count + 1
 35   echo s:count . " corrections now"
 36 endfu

First s:count is initialized to 4 in the script itself.  When later the
s:Add() function is called, it increments s:count.  It doesn't matter from
where the function was called, since it has been defined in the script, it
will use the local variables from this script.


THE RESULT

Here is the resulting complete example: >

  1 " Vim global plugin for correcting typing mistakes
  2 " Last Change:  2000 Oct 15
  3 " Maintainer:   Bram Moolenaar <Bram@vim.org>
  4 " License:  This file is placed in the public domain.
  5
  6 if exists("g:loaded_typecorr")
  7   finish
  8 endif
  9 let g:loaded_typecorr = 1
 10
 11 let s:save_cpo = &cpo
 12 set cpo&vim
 13
 14 iabbrev teh the
 15 iabbrev otehr other
 16 iabbrev wnat want
 17 iabbrev synchronisation
 18     \ synchronization
 19 let s:count = 4
 20
 21 if !hasmapto('<Plug>TypecorrAdd')
 22   map <unique> <Leader>a  <Plug>TypecorrAdd
 23 endif
 24 noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 25
 26 noremenu <script> Plugin.Add\ Correction      <SID>Add
 27
 28 noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
 29
 30 function s:Add(from, correct)
 31   let to = input("type the correction for " . a:from . ": ")
 32   exe ":iabbrev " . a:from . " " . to
 33   if a:correct | exe "normal viws\<C-R>\" \b\e" | endif
 34   let s:count = s:count + 1
 35   echo s:count . " corrections now"
 36 endfu
 37
 38 if !exists(":Correct")
 39   command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40 endif
 41
 42 let &cpo = s:save_cpo
 43 unlet s:save_cpo

Line 33 wasn't explained yet.  It applies the new correction to the word under
the cursor.  The |:normal| command is used to use the new abbreviation.  Note
that mappings and abbreviations are expanded here, even though the function
was called from a mapping defined with ":noremap".

Using "unix" for the 'fileformat' option is recommended.  The Vim scripts will
then work everywhere.  Scripts with 'fileformat' set to "dos" do not work on
Unix.  Also see |:source_crnl|.  To be sure it is set right, do this before
writing the file: >

    :set fileformat=unix


DOCUMENTATION                       *write-local-help*

It's a good idea to also write some documentation for your plugin.  Especially
when its behavior can be changed by the user.  See |add-local-help| for how
they are installed.

Here is a simple example for a plugin help file, called "typecorr.txt": >

  1 *typecorr.txt*  Plugin for correcting typing mistakes
  2
  3 If you make typing mistakes, this plugin will have them corrected
  4 automatically.
  5
  6 There are currently only a few corrections.  Add your own if you like.
  7
  8 Mappings:
  9 <Leader>a   or   <Plug>TypecorrAdd
 10     Add a correction for the word under the cursor.
 11
 12 Commands:
 13 :Correct {word}
 14     Add a correction for {word}.
 15
 16                         *typecorr-settings*
 17 This plugin doesn't have any settings.

The first line is actually the only one for which the format matters.  It will
be extracted from the help file to be put in the "LOCAL ADDITIONS:" section of
help.txt |local-additions|.  The first "*" must be in the first column of the
first line.  After adding your help file do ":help" and check that the entries
line up nicely.

You can add more tags inside ** in your help file.  But be careful not to use
existing help tags.  You would probably use the name of your plugin in most of
them, like "typecorr-settings" in the example.

Using references to other parts of the help in || is recommended.  This makes
it easy for the user to find associated help.


FILETYPE DETECTION                  *plugin-filetype*

If your filetype is not already detected by Vim, you should create a filetype
detection snippet in a separate file.  It is usually in the form of an
autocommand that sets the filetype when the file name matches a pattern.
Example: >

    au BufNewFile,BufRead *.foo         set filetype=foofoo

Write this single-line file as "ftdetect/foofoo.vim" in the first directory
that appears in 'runtimepath'.  For Unix that would be
"~/.vim/ftdetect/foofoo.vim".  The convention is to use the name of the
filetype for the script name.

You can make more complicated checks if you like, for example to inspect the
contents of the file to recognize the language.  Also see |new-filetype|.


SUMMARY                         *plugin-special*

Summary of special things to use in a plugin:

s:name          Variables local to the script.

<SID>           Script-ID, used for mappings and functions local to
            the script.

hasmapto()      Function to test if the user already defined a mapping
            for functionality the script offers.

<Leader>        Value of "mapleader", which the user defines as the
            keys that plugin mappings start with.

:map <unique>       Give a warning if a mapping already exists.

:noremap <script>   Use only mappings local to the script, not global
            mappings.

exists(":Cmd")      Check if a user command already exists.

==============================================================================
*41.12* Writing a filetype plugin   *write-filetype-plugin* *ftplugin*

A filetype plugin is like a global plugin, except that it sets options and
defines mappings for the current buffer only.  See |add-filetype-plugin| for
how this type of plugin is used.

First read the section on global plugins above |41.11|.  All that is said there
also applies to filetype plugins.  There are a few extras, which are explained
here.  The essential thing is that a filetype plugin should only have an
effect on the current buffer.


DISABLING

If you are writing a filetype plugin to be used by many people, they need a
chance to disable loading it.  Put this at the top of the plugin: >

    " Only do this when not done yet for this buffer
    if exists("b:did_ftplugin")
      finish
    endif
    let b:did_ftplugin = 1

This also needs to be used to avoid that the same plugin is executed twice for
the same buffer (happens when using an ":edit" command without arguments).

Now users can disable loading the default plugin completely by making a
filetype plugin with only this line: >

    let b:did_ftplugin = 1

This does require that the filetype plugin directory comes before $VIMRUNTIME
in 'runtimepath'!

If you do want to use the default plugin, but overrule one of the settings,
you can write the different setting in a script: >

    setlocal textwidth=70

Now write this in the "after" directory, so that it gets sourced after the
distributed "vim.vim" ftplugin |after-directory|.  For Unix this would be
"~/.vim/after/ftplugin/vim.vim".  Note that the default plugin will have set
"b:did_ftplugin", but it is ignored here.


OPTIONS

To make sure the filetype plugin only affects the current buffer use the >

    :setlocal

command to set options.  And only set options which are local to a buffer (see
the help for the option to check that).  When using |:setlocal| for global
options or options local to a window, the value will change for many buffers,
and that is not what a filetype plugin should do.

When an option has a value that is a list of flags or items, consider using
"+=" and "-=" to keep the existing value.  Be aware that the user may have
changed an option value already.  First resetting to the default value and
then changing it is often a good idea.  Example: >

    :setlocal formatoptions& formatoptions+=ro


MAPPINGS

To make sure mappings will only work in the current buffer use the >

    :map <buffer>

command.  This needs to be combined with the two-step mapping explained above.
An example of how to define functionality in a filetype plugin: >

    if !hasmapto('<Plug>JavaImport')
      map <buffer> <unique> <LocalLeader>i <Plug>JavaImport
    endif
    noremap <buffer> <unique> <Plug>JavaImport oimport ""<Left><Esc>

|hasmapto()| is used to check if the user has already defined a map to
<Plug>JavaImport.  If not, then the filetype plugin defines the default
mapping.  This starts with |<LocalLeader>|, which allows the user to select
the key(s) he wants filetype plugin mappings to start with.  The default is a
backslash.
"<unique>" is used to give an error message if the mapping already exists or
overlaps with an existing mapping.
|:noremap| is used to avoid that any other mappings that the user has defined
interferes.  You might want to use ":noremap <script>" to allow remapping
mappings defined in this script that start with <SID>.

The user must have a chance to disable the mappings in a filetype plugin,
without disabling everything.  Here is an example of how this is done for a
plugin for the mail filetype: >

    " Add mappings, unless the user didn't want this.
    if !exists("no_plugin_maps") && !exists("no_mail_maps")
      " Quote text by inserting "> "
      if !hasmapto('<Plug>MailQuote')
        vmap <buffer> <LocalLeader>q <Plug>MailQuote
        nmap <buffer> <LocalLeader>q <Plug>MailQuote
      endif
      vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>
      nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>
    endif

Two global variables are used:
no_plugin_maps      disables mappings for all filetype plugins
no_mail_maps        disables mappings for a specific filetype


USER COMMANDS

To add a user command for a specific file type, so that it can only be used in
one buffer, use the "-buffer" argument to |:command|.  Example: >

    :command -buffer  Make  make %:r.s


VARIABLES

A filetype plugin will be sourced for each buffer of the type it's for.  Local
script variables |s:var| will be shared between all invocations.  Use local
buffer variables |b:var| if you want a variable specifically for one buffer.


FUNCTIONS

When defining a function, this only needs to be done once.  But the filetype
plugin will be sourced every time a file with this filetype will be opened.
This construct makes sure the function is only defined once: >

    :if !exists("*s:Func")
    :  function s:Func(arg)
    :    ...
    :  endfu
    :endif
<

UNDO                            *undo_ftplugin*

When the user does ":setfiletype xyz" the effect of the previous filetype
should be undone.  Set the b:undo_ftplugin variable to the commands that will
undo the settings in your filetype plugin.  Example: >

    let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
        \ . "| unlet b:match_ignorecase b:match_words b:match_skip"

Using ":setlocal" with "<" after the option name resets the option to its
global value.  That is mostly the best way to reset the option value.

This does require removing the "C" flag from 'cpoptions' to allow line
continuation, as mentioned above |use-cpo-save|.


FILE NAME

The filetype must be included in the file name |ftplugin-name|.  Use one of
these three forms:

    .../ftplugin/stuff.vim
    .../ftplugin/stuff_foo.vim
    .../ftplugin/stuff/bar.vim

"stuff" is the filetype, "foo" and "bar" are arbitrary names.


SUMMARY                         *ftplugin-special*

Summary of special things to use in a filetype plugin:

<LocalLeader>       Value of "maplocalleader", which the user defines as
                    the keys that filetype plugin mappings start with.

:map <buffer>       Define a mapping local to the buffer.

:noremap <script>   Only remap mappings defined in this script that start
                    with <SID>.

:setlocal           Set an option for the current buffer only.

:command -buffer    Define a user command local to the buffer.

exists("*s:Func")   Check if a function was already defined.

Also see |plugin-special|, the special things used for all plugins.

==============================================================================
*41.13* Writing a compiler plugin       *write-compiler-plugin*

A compiler plugin sets options for use with a specific compiler.  The user can
load it with the |:compiler| command.  The main use is to set the
'errorformat' and 'makeprg' options.

Easiest is to have a look at examples.  This command will edit all the default
compiler plugins: >

    :next $VIMRUNTIME/compiler/*.vim

Use |:next| to go to the next plugin file.

There are two special items about these files.  First is a mechanism to allow
a user to overrule or add to the default file.  The default files start with: >

    :if exists("current_compiler")
    :  finish
    :endif
    :let current_compiler = "mine"

When you write a compiler file and put it in your personal runtime directory
(e.g., ~/.vim/compiler for Unix), you set the "current_compiler" variable to
make the default file skip the settings.
                            *:CompilerSet*
The second mechanism is to use ":set" for ":compiler!" and ":setlocal" for
":compiler".  Vim defines the ":CompilerSet" user command for this.  However,
older Vim versions don't, thus your plugin should define it then.  This is an
example: >

  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal <args>
  endif
  CompilerSet errorformat&      " use the default 'errorformat'
  CompilerSet makeprg=nmake

When you write a compiler plugin for the Vim distribution or for a system-wide
runtime directory, use the mechanism mentioned above.  When
"current_compiler" was already set by a user plugin nothing will be done.

When you write a compiler plugin to overrule settings from a default plugin,
don't check "current_compiler".  This plugin is supposed to be loaded
last, thus it should be in a directory at the end of 'runtimepath'.  For Unix
that could be ~/.vim/after/compiler.

==============================================================================
*41.14* Writing a plugin that loads quickly *write-plugin-quickload*

A plugin may grow and become quite long.  The startup delay may become
noticeable, while you hardly ever use the plugin.  Then it's time for a
quickload plugin.

The basic idea is that the plugin is loaded twice.  The first time user
commands and mappings are defined that offer the functionality.  The second
time the functions that implement the functionality are defined.

It may sound surprising that quickload means loading a script twice.  What we
mean is that it loads quickly the first time, postponing the bulk of the
script to the second time, which only happens when you actually use it.  When
you always use the functionality it actually gets slower!

Note that since Vim 7 there is an alternative: use the |autoload|
functionality |41.15|.

The following example shows how it's done: >

    " Vim global plugin for demonstrating quick loading
    " Last Change:  2005 Feb 25
    " Maintainer:   Bram Moolenaar <Bram@vim.org>
    " License:  This file is placed in the public domain.

    if !exists("s:did_load")
        command -nargs=* BNRead  call BufNetRead(<f-args>)
        map <F19> :call BufNetWrite('something')<CR>

        let s:did_load = 1
        exe 'au FuncUndefined BufNet* source ' . expand('<sfile>')
        finish
    endif

    function BufNetRead(...)
        echo 'BufNetRead(' . string(a:000) . ')'
        " read functionality here
    endfu

    function BufNetWrite(...)
        echo 'BufNetWrite(' . string(a:000) . ')'
        " write functionality here
    endfu

When the script is first loaded "s:did_load" is not set.  The commands between
the "if" and "endif" will be executed.  This ends in a |:finish| command, thus
the rest of the script is not executed.

The second time the script is loaded "s:did_load" exists and the commands
after the "endif" are executed.  This defines the (possible long)
BufNetRead() and BufNetWrite() functions.

If you drop this script in your plugin directory Vim will execute it on
startup.  This is the sequence of events that happens:

1. The "BNRead" command is defined and the <F19> key is mapped when the script
   is sourced at startup.  A |FuncUndefined| autocommand is defined.  The
   ":finish" command causes the script to terminate early.

2. The user types the BNRead command or presses the <F19> key.  The
   BufNetRead() or BufNetWrite() function will be called.

3. Vim can't find the function and triggers the |FuncUndefined| autocommand
   event.  Since the pattern "BufNet*" matches the invoked function, the
   command "source fname" will be executed.  "fname" will be equal to the name
   of the script, no matter where it is located, because it comes from
   expanding "<sfile>" (see |expand()|).

4. The script is sourced again, the "s:did_load" variable exists and the
   functions are defined.

Notice that the functions that are loaded afterwards match the pattern in the
|FuncUndefined| autocommand.  You must make sure that no other plugin defines
functions that match this pattern.

==============================================================================
*41.15* Writing library scripts         *write-library-script*

Some functionality will be required in several places.  When this becomes more
than a few lines you will want to put it in one script and use it from many
scripts.  We will call that one script a library script.

Manually loading a library script is possible, so long as you avoid loading it
when it's already done.  You can do this with the |exists()| function.
Example: >

    if !exists('*MyLibFunction')
       runtime library/mylibscript.vim
    endif
    call MyLibFunction(arg)

Here you need to know that MyLibFunction() is defined in a script
"library/mylibscript.vim" in one of the directories in 'runtimepath'.

To make this a bit simpler Vim offers the autoload mechanism.  Then the
example looks like this: >

    call mylib#myfunction(arg)

That's a lot simpler, isn't it?  Vim will recognize the function name and when
it's not defined search for the script "autoload/mylib.vim" in 'runtimepath'.
That script must define the "mylib#myfunction()" function.

You can put many other functions in the mylib.vim script, you are free to
organize your functions in library scripts.  But you must use function names
where the part before the '#' matches the script name.  Otherwise Vim would
not know what script to load.

If you get really enthusiastic and write lots of library scripts, you may
want to use subdirectories.  Example: >

    call netlib#ftp#read('somefile')

For Unix the library script used for this could be:

    ~/.vim/autoload/netlib/ftp.vim

Where the function is defined like this: >

    function netlib#ftp#read(fname)
        "  Read the file fname through ftp
    endfu

Notice that the name the function is defined with is exactly the same as the
name used for calling the function.  And the part before the last '#'
exactly matches the subdirectory and script name.

You can use the same mechanism for variables: >

    let weekdays = dutch#weekdays

This will load the script "autoload/dutch.vim", which should contain something
like: >

    let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
        \ 'donderdag', 'vrijdag', 'zaterdag']

Further reading: |autoload|.

==============================================================================
------------------------------------------------------------------------------
======================
reddit - medium - gist 

https://www.reddit.com/r/vim/comments/7bj837/favorite_console_tools_to_use_with_vim/
https://www.reddit.com/r/vim/comments/4ootmz/what_is_your_little_known_secret_vim_shortcut_or/
https://www.reddit.com/r/vim/comments/7iy03o/you_aint_gonna_need_it_your_replacement_for/dr2qo4k/
https://www.reddit.com/r/vim/comments/6tb492/vi_is_not_vim/dlkgv6f/
https://www.reddit.com/r/vim/comments/6ucyus/editing_prose_with_vim_help_with_using_vim_to/dlrrsfc/
https://medium.com/brigade-engineering/sharpen-your-vim-with-snippets-767b693886db
https://medium.com/@crashybang/supercharge-vim-with-fzf-and-ripgrep-d4661fc853d2#.hfnqelusz
https://dougblack.io/words/a-good-vimrc.html
https://nondev.io/Fuzzy-completion-in-Vim
https://blog.bugsnag.com/tmux-and-vim/

https://gist.github.com/romainl/ce55ce6fdc1659c5fbc0f4224fd6ad29
linting the vanilla way
https://gist.github.com/BoltsJ/5942ecac7f0b0e9811749ef6e19d2176
place sign after linting

Relire le plugin sensible

Lire :h include-search

======================
Vim Stack Exchange

https://vi.stackexchange.com/a/8571/13370
https://vi.stackexchange.com/questions/2115/can-i-be-notified-when-im-undoing-changes-from-the-undofile
https://vi.stackexchange.com/questions/4584/how-to-create-my-own-autocomplete-function/9192#9192
https://vi.stackexchange.com/questions/9156/what-is-a-more-efficient-way-to-use-buffers
https://vi.stackexchange.com/questions/8122/how-to-open-a-file-from-active-buffer-into-a-split-window
https://vi.stackexchange.com/questions/8670/how-can-i-enable-folding-only-for-files-longer-than-a-certain-length/8672#8672
https://vi.stackexchange.com/questions/8674/how-to-save-and-restore-the-result-of-the-command-set
https://vi.stackexchange.com/questions/8709/keep-windows-reference-in-memory
https://stackoverflow.com/questions/5215163/how-to-get-a-unique-identifier-for-a-window/
https://vi.stackexchange.com/questions/8926/is-it-possible-to-obtain-the-displayable-area-width-and-height-of-current-buffe
https://stackoverflow.com/questions/26315925/get-usable-window-width-in-vim-script/26318602#26318602
https://vi.stackexchange.com/questions/9700/mutliple-choice-substitute
https://vi.stackexchange.com/questions/8683/mapping-without-polluting-the-global-namespace
http://vimcasts.org/blog/2014/02/follow-my-leader/
https://vi.stackexchange.com/questions/2543/how-can-i-map-dcountd/2546#2546

https://vi.stackexchange.com/questions/7925/quick-search-limited-to-a-c-function
https://vi.stackexchange.com/questions/6869/how-to-handle-a-nested-dictionary-with-mixed-key-values
https://vi.stackexchange.com/questions/471/why-do-i-need-both-a-vimrc-and-a-gvimrc
https://vi.stackexchange.com/questions/8127/is-there-a-way-to-restrict-search-results-to-differences-in-a-diff
https://vi.stackexchange.com/questions/8692/command-to-loop-through-spelling-suggestions/


https://vi.stackexchange.com/questions/2009/how-do-i-make-vim-look-in-a-set-of-directories-for-a-file-if-it-doesnt-exist-i



colorscheme
https://vi.stackexchange.com/questions/6780/how-do-i-preserve-my-colorscheme-when-i-sudo-to-root
https://vi.stackexchange.com/questions/8575/neovim-default-colors-dont-match-vims
https://vi.stackexchange.com/questions/8607/how-do-putty-kitty-ansi-colors-affect-vim-colorschemes/

conceal
https://vi.stackexchange.com/questions/8559/vim-conceal-indentation-replace-indentation-spaces-with-utf-8-chars/
https://vi.stackexchange.com/questions/6474/how-do-i-hide-a-tex-macro-and-highlight-the-arguments

folding
https://vi.stackexchange.com/questions/8770/how-can-i-hide-blank-lines-in-vim-without-actually-removing-them-from-the-text-i
https://vi.stackexchange.com/questions/6738/is-it-possible-to-create-a-folding-inside-a-single-line

miscellaneous
https://vi.stackexchange.com/questions/6876/can-i-apply-one-files-filetype-to-another-without-actually-opening-the-first-f
https://vi.stackexchange.com/questions/6784/how-can-i-automate-filetype-detection-when-using-sudoedit
https://vi.stackexchange.com/questions/6773/how-can-i-make-vims-flowing-aware-of-email-replies
https://vi.stackexchange.com/questions/6705/use-shell-variable-substitution-with-current-filepath
https://vi.stackexchange.com/questions/6238/how-can-i-make-a-slow-ish-system-call-in-a-statusline-without-corrupting-the-d
https://vi.stackexchange.com/questions/5941/summary-of-functions-in-current-file
https://vi.stackexchange.com/questions/5869/edit-neovim-terminal-commandline-within-the-same-neovim-instance
https://vi.stackexchange.com/questions/5667/escape-return-value-key-in-mapping-function
https://vi.stackexchange.com/questions/3920/is-it-possible-to-use-a-delegate-or-to-pass-a-function-as-argument-in-vimscript
https://vi.stackexchange.com/questions/8958/align-code-functions-documentation
https://vi.stackexchange.com/questions/9880/retitling-tab-labels
https://vi.stackexchange.com/questions/10077/get-index-of-search-in-substitute-expression
https://vi.stackexchange.com/questions/10083/how-can-i-sort-a-file-by-word-frequency/10092#10092
https://vi.stackexchange.com/questions/10167/is-there-a-way-that-i-can-identify-which-window-is-a-terminal-after-calling-the/10173#10173
https://vi.stackexchange.com/questions/9416/how-do-you-find-where-a-variable-was-last-assigned
https://vi.stackexchange.com/questions/3177/use-single-ftplugin-for-more-than-one-filetype

syntax highlighting

:h syntax-loading
http://vim.wikia.com/wiki/Creating_your_own_syntax_files
https://vi.stackexchange.com/questions/5855/is-it-possible-to-turn-on-spell-checking-for-only-parts-of-buffers
https://vi.stackexchange.com/questions/7445/nested-highlighting
https://vi.stackexchange.com/questions/6943/syntax-highlight-region-keyword-overlap
https://vi.stackexchange.com/questions/6731/vim-syntax-pattern-to-highlight-python-keyword-argument
https://vi.stackexchange.com/questions/7709/custom-syntax-highlighting-highlight-word-following-keyword
https://vi.stackexchange.com/questions/6703/start-of-match-zs-seems-to-break-my-pattern
https://vi.stackexchange.com/questions/9599/syntax-highlighting-for-custom-latex-commands
https://vi.stackexchange.com/questions/10132/vim-syntax-file-how-to-match-capturing-groups
https://vi.stackexchange.com/questions/10193/how-do-i-make-regexes-mutually-contain-each-other
http://stackoverflow.com/questions/2683521/vim-search-in-c-c-code-lines/2696143#2696143
https://vi.stackexchange.com/questions/11371/where-does-red-highlighting-come-from-with-syntax-off-and-spell-on-in-neovim


How to find where a variable was defined? (':5verbose let' doesn't give the information)

Possible solutions:

    1 - :cexpr system('grep -Rn g:myvar ~/.vim')

    2 - cd ~/.vim && ctags -R .

        :tselect g:myvar    ou    :tjump g:myvar

    doesn't always work (e.g. b:changedtick)
    LOL it depends on where you are (the value of 'tags' matters), add this to make it always work:    set tags+=$VIMRUNTIME/doc/tags



How to jump to a definition of a function or variable defined in myfunctions.vim?
ctags -R . produces a tag file containing all the info, but then which key must be hit? (gd, gD, []dD don't work)
Type `C-]`, you idiot!!!



Is it possible to send a buffer in the arglist to another local arglist?
How to unload all buffers from the global arglist except the ones of a local arglist?


Is it possible to change the maximum number of entries in the changelist and in the jumplist?
'viminfo' seems to allow to control the maximum number of a lot of things but not these 2.



When closing a tab page, how to give the focus to the last tab page which had the focus instead
of the last tab page on the right?

aug my_tab_focus
    au!
    " Leave comes before Closed
    au TabLeave  * let s:my_last_tab = tabpagenr()
    au TabClosed * call s:tab_focus_restore()
aug END

fu! s:tab_focus_restore() abort
    if s:my_last_tab < tabpagenr()
        let g:debug = { 'my_last_tab' : s:my_last_tab, 'cmd' : 'tabnext '.(s:my_last_tab - 1) }
    else
        let g:debug = { 'my_last_tab' : s:my_last_tab, 'cmd' : 'tabnext '.s:my_last_tab }
    endif
endfu

======================
                            *search()-sub-match*
        With the 'p' flag the returned value is one more than the
        first sub-match in \(\).  One if none of them matched but the
        whole pattern did match.
        To get the column number too use |searchpos()|.

        The cursor will be positioned at the match, unless the 'n'
        flag is used.

        Example (goes over all files in the argument list): >

            let n = 1
            " loop over all files in arglist
            while n <= argc()
              exe 'argument '.n

              " start at the last char in the file and wrap for the
              " first search to find match at start of file

              norm! G$

              let flags = 'w'
              while search('foo', flags) > 0
                s/foo/bar/g
                let flags = 'W'
              endwhile

              update
              let n += 1
            endwhile
<
        Example for using some flags: >

            echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')

<       This will search for the keywords "if", "else", and "endif"
        under or after the cursor.  Because of the 'p' flag, it
        returns 1, 2, or 3 depending on which keyword is found, or 0
        if the search fails.  With the cursor on the first word of the
        line:
            if (foo == 0) | let foo = foo + 1 | endif ~
        the function returns 1.  Without the 'c' flag, the function
        finds the "endif" and returns 3.  The same thing happens
        without the 'e' flag if the cursor is on the "f" of "if".
        The 'n' flag tells the function not to move the cursor.


searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])   *searchpos()*

        Same as |search()|, but returns a |List| with the line and
        column position of the match. The first element of the |List|
        is the line number and the second element is the byte index of
        the column position of the match. If no match is found,
        returns [0, 0].
        Example: >

    let [lnum, col] = searchpos('mypattern', 'n')

<       When the 'p' flag is given then there is an extra item with
        the sub-pattern match number |search()-sub-match|.  Example: >

    let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')

<       In this example "submatch" is 2 when a lowercase letter is
        found |/\l|, 3 when an uppercase letter is found |/\u|.

======================
Coming Home to Vim

Next are a few options that just make things better:

set visualbell
set ttyfast

The next section makes Vim handle long lines correctly:

set formatoptions=qrn1
set colorcolumn=85

These lines manage my line wrapping settings and also show a colored column at 85 characters
(so I can see when I write a too-long line of code).

See :help fo-table and the Vimcasts on soft wrapping and hard wrapping for more information.

Finally, I really like TextMate’s “save on losing focus” feature. I can’t remember a time when I didn’t want to save a file after tabbing away from my editor (especially with version control and Vim’s persistent undo):

au FocusLost * :wa

        https://github.com/tmux-plugins/vim-tmux-focus-events
        https://github.com/tmux-plugins/tmux-sensible
        Unfortunately doesn't seem to work with xfce4-terminal or guake (Sure?).

======================
cheatsheet

                        *[(*
[(          go to [count] previous unmatched '('.
            |exclusive| motion. {not in Vi}

                        *[{*
[{          go to [count] previous unmatched '{'.
            |exclusive| motion. {not in Vi}

                        *])*
])          go to [count] next unmatched ')'.
            |exclusive| motion. {not in Vi}

                        *]}*
]}          go to [count] next unmatched '}'.
            |exclusive| motion. {not in Vi}

The above four commands can be used to go to the start or end of the current
code block.  It is like doing "%" on the '(', ')', '{' or '}' at the other
end of the code block, but you can do this from anywhere in the code block.
Very useful for C programs.  Example: When standing on "case x:", "[{" will
bring you back to the switch statement.

                        *]m*
]m          Go to [count] next start of a method (for Java or
            similar structured language).  When not before the
            start of a method, jump to the start or end of the
            class.  When no '{' is found after the cursor, this is
            an error.  |exclusive| motion. {not in Vi}
                        *]M*
]M          Go to [count] next end of a method (for Java or
            similar structured language).  When not before the end
            of a method, jump to the start or end of the class.
            When no '}' is found after the cursor, this is an
            error. |exclusive| motion. {not in Vi}
                        *[m*
[m          Go to [count] previous start of a method (for Java or
            similar structured language).  When not after the
            start of a method, jump to the start or end of the
            class.  When no '{' is found before the cursor this is
            an error. |exclusive| motion. {not in Vi}
                        *[M*
[M          Go to [count] previous end of a method (for Java or
            similar structured language).  When not after the
            end of a method, jump to the start or end of the
            class.  When no '}' is found before the cursor this is
            an error. |exclusive| motion. {not in Vi}

The above two commands assume that the file contains a class with methods.
The class definition is surrounded in '{' and '}'.  Each method in the class
is also surrounded with '{' and '}'.  This applies to the Java language.  The
file looks like this: >

    // comment
    class foo {
        int method_one() {
            body_one();
        }
        int method_two() {
            body_two();
        }
    }
Starting with the cursor on "body_two()", using "[m" will jump to the '{' at
the start of "method_two()" (obviously this is much more useful when the
method is long!).  Using "2[m" will jump to the start of "method_one()".
Using "3[m" will jump to the start of the class.

                        *[#*
[#          go to [count] previous unmatched "#if" or "#else".
            |exclusive| motion. {not in Vi}

                        *]#*
]#          go to [count] next unmatched "#else" or "#endif".
            |exclusive| motion. {not in Vi}

These two commands work in C programs that contain #if/#else/#endif
constructs.  It brings you to the start or end of the #if/#else/#endif where
the current line is included.  You can then use "%" to go to the matching line.

                        *[star* *[/*
[*  or  [/      go to [count] previous start of a C comment "/*".
            |exclusive| motion. {not in Vi}

                        *]star* *]/*
]*  or  ]/      go to [count] next end of a C comment "*/".
            |exclusive| motion. {not in Vi}




tags
    Vim will read a 'tags' file automatically

    g] - list matching tags (évite de devoir faire C-] puis répéter :tn et :tp)

    :tag _initInputField - jump the function definition of _initInputField
    :tag /placeholder - jump to tag matching the text 'placeholder'

    :ptag placeholderUrl - open tag in preview window
    :tselect afterSave - select from multiple matching tags
    :tjump url - jump to unique tag, or list non-unique ones

external command
    :%! markdown - filter buffer via the external 'markdown' command
    :%! tidy - filter buffer via html tidy
    :!wc % - word count

filename
    use a % sign on the command line to denote the current file
    :! echo %

    :! markdown % > %:p:r.html

search and replace

    :%s/<br>\n<br>/\r<\/p>\r<p>/g - replace br with p

    :color - show current colorscheme

:%TOhtml - generate HTML page that looks like the current view

buffers

    :bdel galleries <Ctrl-a> - complete all matches

fileformat
    :set ff? - show fileformat

    convert in current buffer
        :setlocal ff=unix
        :w
======================

8. Views and Sessions                   *views-sessions*

This is introduced in sections |21.4| and |21.5| of the user manual.

                        *View* *view-file*
A View is a collection of settings that apply to one window.  You can save a
View and when you restore it later, the text is displayed in the same way.
The options and mappings in this window will also be restored, so that you can
continue editing like when the View was saved.

                        *Session* *session-file*
A Session keeps the Views for all windows, plus the global settings.  You can
save a Session and when you restore it later the window layout looks the same.
You can use a Session to quickly switch between different projects,
automatically loading the files you were last working on in that project.

Views and Sessions are a nice addition to viminfo-files, which are used to
remember information for all Views and Sessions together |viminfo-file|.

You can quickly start editing with a previously saved View or Session with the
|-S| argument: >
    vim -S Session.vim
<
All this is {not in Vi} and {not available when compiled without the
|+mksession| feature}.

                            *:mks* *:mksession*
:mks[ession][!] [file]  Write a Vim script that restores the current editing
            session.
            When [!] is included an existing file is overwritten.
            When [file] is omitted "Session.vim" is used.

The output of ":mksession" is like ":mkvimrc", but additional commands are
added to the file.  Which ones depends on the 'sessionoptions' option.  The
resulting file, when executed with a ":source" command:
1. Restores global mappings and options, if 'sessionoptions' contains
   "options".  Script-local mappings will not be written.
2. Restores global variables that start with an uppercase letter and contain
   at least one lowercase letter, if 'sessionoptions' contains "globals".
3. Unloads all currently loaded buffers.
4. Restores the current directory if 'sessionoptions' contains "curdir", or
   sets the current directory to where the Session file is if 'sessionoptions'
   contains "sesdir".
5. Restores GUI Vim window position, if 'sessionoptions' contains "winpos".
6. Restores screen size, if 'sessionoptions' contains "resize".
7. Reloads the buffer list, with the last cursor positions.  If
   'sessionoptions' contains "buffers" then all buffers are restored,
   including hidden and unloaded buffers.  Otherwise only buffers in windows
   are restored.
8. Restores all windows with the same layout.  If 'sessionoptions' contains
   "help", help windows are restored.  If 'sessionoptions' contains "blank",
   windows editing a buffer without a name will be restored.
   If 'sessionoptions' contains "winsize" and no (help/blank) windows were
   left out, the window sizes are restored (relative to the screen size).
   Otherwise, the windows are just given sensible sizes.
9. Restores the Views for all the windows, as with |:mkview|.  But
   'sessionoptions' is used instead of 'viewoptions'.
10. If a file exists with the same name as the Session file, but ending in
   "x.vim" (for eXtra), executes that as well.  You can use *x.vim files to
   specify additional settings and actions associated with a given Session,
   such as creating menu items in the GUI version.

After restoring the Session, the full filename of your current Session is
available in the internal variable "v:this_session" |this_session-variable|.
An example mapping: >
  :nmap <F2> :wa<Bar>exe "mksession! " . v:this_session<CR>:so ~/sessions/
This saves the current Session, and starts off the command to load another.

A session includes all tab pages, unless "tabpages" was removed from
'sessionoptions'. |tab-page|

The |SessionLoadPost| autocmd event is triggered after a session file is
loaded/sourced.
                        *SessionLoad-variable*
While the session file is loading the SessionLoad global variable is set to 1.
Plugins can use this to postpone some work until the SessionLoadPost event is
triggered.

                            *:mkvie* *:mkview*

http://vim.wikia.com/wiki/Make_views_automatic

:mkview[!] [file] écrit un fichier vimscript qui une fois sourcé restaure le contenu de la fenêtre courante.
Le bang sert à écraser [file] s'il existe déjà.
Si [file] est omis, la sauvegarde se fait dans un fichier au nom aléatoire dans le dossier ~/.vim/view (valeur de 'viewdir').

La sortie de :mkview contient:
* l'arglist utilisée par la fenêtre ainsi que l'index de l'argument courant (dernier buffer de l'arglist ayant été affiché).
* le fichier affiché dans la fenêtre
* abréviations, mappings et options locales à la fenêtre et au buffer si l'option 'viewoptions' contient la valeur options
  ou localoptions
* les plis créés par la méthode manuelle si 'viewoptions' contient la valeur folds
* la position du curseur
* le working directory local s'il est différent du working directory global
*
NOTE: les sessions et les views ont plusieurs défauts:
* elles ne restaurent pas



Note that Views and Sessions are not perfect:
- They don't restore everything.  For example, defined functions, autocommands
  and ":syntax on" are not included.  Things like register contents and
  command line history are in viminfo, not in Sessions or Views.
- Global option values are only set when they differ from the default value.
  When the current value is not the default value, loading a Session will not
  set it back to the default value.  Local options will be set back to the
  default value though.
- Existing mappings will be overwritten without warning.  An existing mapping
  may cause an error for ambiguity.
- When storing manual folds and when storing manually opened/closed folds,
  changes in the file between saving and loading the view will mess it up.

                            *:lo* *:loadview*
:lo[adview] [nr]    Load the view for the current file.  When [nr] is
            omitted, the view stored with ":mkview" is loaded.
            When [nr] is specified, the view stored with ":mkview
            [nr]" is loaded.

The combination of ":mkview" and ":loadview" can be used to store up to ten
different views of a file.  These are remembered in the directory specified
with the 'viewdir' option.  The views are stored using the file name.  If a
file is renamed or accessed through a (symbolic) link the view will not be
found.

You might want to clean up your 'viewdir' directory now and then.

To automatically save and restore views for *.c files: >
    au BufWinLeave *.c mkview
    au BufWinEnter *.c sil loadview

======================
'binary'

http://vim.wikia.com/wiki/VimTip1518


'fileformats' 'ffs'    (par défaut "unix,dos")    global

Cette option contient une liste de standards ("unix", "dos", "mac"), chacun déterminant à sa façon comment lire / écrire une fin de ligne <EOL>.
Vim teste différents standards jusqu'à en trouver un qui fonctionne pour le fichier qu'on veut éditer (:e)
(ou pour le fichier qu'on veut lire dans le buffer courant (:r)) et qui est présent dans 'ffs'.
Vim configure alors l'option 'fileformat' en lui donnant la valeur du standard trouvé.


'fileformat' 'ff'    (par défaut "unix")    local au buffer

Cette option détermine comment Vim lit / écrit une fin de ligne (<EOL>) pour le buffer courant.
dos  = <CR><LF>
unix = <LF>
mac  = <CR>

Elle est automatiquement configurée qd on édite un fichier si 'fileformats' est non vide et que 'binary' est désactivée.
Elle est considérée comme valant "unix" qd 'binary' est activée.


'binary' 'bin'    booléen (par défaut off)    local au buffer

Cette option devrait être activée avant d'éditer un fichier binaire.
Pour ce faire :    vim -b file    :e ++bin file
'set binary' est déconseillé car il affecte tous les fichiers édités (:setlocal ?).

Qd 'bin' est activée:

    - 'tw' = 'wrapmargin' = 'modeline' = 'expandtab' = 0
    - 'fileformat' et 'fileformats' sont ignorés
    - le fichier est lu et écrit comme si 'fileformat' = "unix", càd qu'une fin de ligne est considérée
      comme étant un <LF>
    - 'fileencoding' et 'fileencodings' sont ignorés, le fichier est lu sans conversion

Si on édite un autre fichier, ces options risquent d'être modifiées par des autocmd.
Pour cette raison, il est conseillé de réactiver l'option à nouveau qd on revient éditer le binaire.

Qd on désactive 'bin' les anciennes valeurs des options 'tw', 'wrapmargin', 'modeline' et 'expandtab' sont restaurés.


'fileencodings' 'fencs'    (par défaut: "ucs-bom,utf-8,default,latin1" qd 'encoding' = utf-8)    global

Qd Vim lit un fichier, il tente d'utiliser chaque encodage présent ds 'fencs' dans leur ordre d'apparition.
Qd il en trouve qui fonctionne, il configure la valeur de 'fileencoding' / 'fenc'.
Si tous les encodages de 'fencs' échouent, Vim donne à 'fenc' la valeur "", ce qui signifie qu'il utilisera la valeur
configurée par 'encoding'.

'fencs' est ignoré dans 3 cas de figure:

1- 'binary' est activé
2- le buffer a été chargé avec l'argument ++enc={encodage}
3- le buffer correspond à un nouveau fichier ('fenc' est utilisé)


    Note that 'fileencodings' is not used for a new file, the global value
    of 'fileencoding' is used instead.  You can set it with: >
        :setglobal fenc=iso-8859-2
<   This means that a non-existing file may get a different encoding than
    an empty file.
    The special value "ucs-bom" can be used to check for a Unicode BOM
    (Byte Order Mark) at the start of the file.  It must not be preceded
    by "utf-8" or another Unicode encoding for this to work properly.
    An entry for an 8-bit encoding (e.g., "latin1") should be the last,
    because Vim cannot detect an error, thus the encoding is always
    accepted.
    The special value "default" can be used for the encoding from the
    environment.  This is the default value for 'encoding'.  It is useful
    when 'encoding' is set to "utf-8" and your environment uses a
    non-latin1 encoding, such as Russian.
    When 'encoding' is "utf-8" and a file contains an illegal byte
    sequence it won't be recognized as UTF-8.  You can use the |8g8|
    command to find the illegal byte sequence.
    WRONG VALUES:           WHAT'S WRONG:
        latin1,utf-8        "latin1" will always be used
        utf-8,ucs-bom,latin1    BOM won't be recognized in an utf-8
                    file
        cp1250,latin1       "cp1250" will always be used
    If 'fileencodings' is empty, 'fileencoding' is not modified.
    See 'fileencoding' for the possible values.
    Setting this option does not have an effect until the next time a file
    is read.

                *'fileencoding'* *'fenc'* *E213*
'fileencoding' 'fenc'   string (default: "")
            local to buffer
            {only available when compiled with the |+multi_byte|
            feature}
            {not in Vi}
    Sets the character encoding for the file of this buffer.

    When 'fileencoding' is different from 'encoding', conversion will be
    done when writing the file.  For reading see below.
    When 'fileencoding' is empty, the same value as 'encoding' will be
    used (no conversion when reading or writing a file).
    Conversion will also be done when 'encoding' and 'fileencoding' are
    both a Unicode encoding and 'fileencoding' is not utf-8.  That's
    because internally Unicode is always stored as utf-8.
        WARNING: Conversion can cause loss of information!  When
        'encoding' is "utf-8" or another Unicode encoding, conversion
        is most likely done in a way that the reverse conversion
        results in the same text.  When 'encoding' is not "utf-8" some
        characters may be lost!

    See 'encoding' for the possible values.  Additionally, values may be
    specified that can be handled by the converter, see
    |mbyte-conversion|.

    When reading a file 'fileencoding' will be set from 'fileencodings'.
    To read a file in a certain encoding it won't work by setting
    'fileencoding', use the |++enc| argument.  One exception: when
    'fileencodings' is empty the value of 'fileencoding' is used.
    For a new file the global value of 'fileencoding' is used.

    Prepending "8bit-" and "2byte-" has no meaning here, they are ignored.
    When the option is set, the value is converted to lowercase.  Thus
    you can set it with uppercase values too.  '_' characters are
    replaced with '-'.  If a name is recognized from the list for
    'encoding', it is replaced by the standard name.  For example
    "ISO8859-2" becomes "iso-8859-2".

    When this option is set, after starting to edit a file, the 'modified'
    option is set, because the file would be different when written.

    Keep in mind that changing 'fenc' from a modeline happens
    AFTER the text has been read, thus it applies to when the file will be
    written.  If you do set 'fenc' in a modeline, you might want to set
    'nomodified' to avoid not being able to ":q".

======================
    :{range}pydo {func}

            remplace chaque ligne de {range} par la sortie de la fonction python définie par:

                `def _vim_pydo(line,linenr): {func}`

            Dans {func}, on peut se référer:

                    - au texte de la ligne à manipuler via l'argument line
                    - au n° de la ligne via l'argument linenr

            Tous les deux sont automatiquement passés à la fonction.

Cette commande est à développer en lisant:

        `:help python-buffer`

et

https://vi.stackexchange.com/questions/849/how-to-execute-python-statement-for-each-line

`:py3do`, `:perldo` et `:rubydo` sont des commandes similaires
À ceci près qu'il semble que pour `:perldo` et `:rubydo` on se réfère à la ligne courante via l'expression `$_`.
Ex:
>
    perldo $_  = {instruction perl}     remplace
    perldo $_ += {instruction perl}     append

======================
input()

input({prompt} [, {text} [, {completion}]])     *input()*

        Example: >

            if input('Coffee or beer? ') == 'beer'
               echo 'Cheers!'
            endif
<
        If the optional {text} argument is present and not empty, this
        is used for the default reply, as if the user typed this.
        Example: >

            let color = input('Color? ', 'white')

<       The optional {completion} argument specifies the type of
        completion supported for the input.  Without it completion is
        not performed.  The supported completion types are the same as
        that can be supplied to a user-defined command using the
        `-complete=` argument.  Refer to |:command-completion| for
        more information.  Example: >

            let fname = input('File: ', '', 'file')
<
        Note: When input() is called from within a mapping it will
        consume remaining characters from that mapping, because a
        mapping is handled like the characters were typed.

        Use |inputsave()| before input() and |inputrestore()|
        after input() to avoid that.  Another solution is to avoid
        that further characters follow in the mapping, e.g., by using
        |:execute| or |:normal|.

        Example with a mapping: >

            nmap \x :call GetFoo()<CR>:exe '/' . Foo<CR>
            fu! GetFoo()
                call inputsave()
                let g:Foo = input('enter search pattern: ')
                call inputrestore()
            endfu
==============================================================================
------------------------------------------------------------------------------
==============================================================================
http://blog.owen.cymru/fzf-ripgrep-navigate-with-bash-faster-than-ever-before/

FZF & RipGrep - Navigate with bash faster than ever before
Posted on Feb 12, 2017

I've always had fzf  and ripgrep on my radar, and I've  finally gotten around to
using them together.  Good lord it makes a world  of difference, especially when
added to Vim as well as Bash.

Add the following snippet to your  ~/.bashrc, this add's fzf keybindings to bash
and gets fzf to use ripgrep by default for faster searching.

        [ -f ~/.fzf.bash ] && source ~/.fzf.bash
        export FZF_DEFAULT_COMMAND='rg --files --no-ignore --hidden --follow -g "!{.git,node_modules}/*" 2> /dev/null'
        export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
        bind -x '"\C-p": vim $(fzf);'

Okay now what can you do?

        Ctrl + r - search through bash history with fzf
        Ctrl + p - edit a file in vim from fzf
        mv dir/** - expand a directory with (**) and select from fzf
        Alt + c - change directory from fzf - see the update at the bottom for faster search with bfs.
        Ctrl + t - insert file from fzf into command

Neat right! Now if you are a vim user  there is more, add the fzf plugin to your
~/.vimrc,  along  with  this  snippet. Obviously  customise  the  bindings,  and
excludes / includes to your workflows!

        let g:rg_command = '
        \ rg --column --line-number --no-heading --fixed-strings --ignore-case --no-ignore --hidden --follow --color "always"
        \ -g "*.{js,json,php,md,styl,jade,html,config,py,cpp,c,go,hs,rb,conf}"
        \ -g "!{.git,node_modules,vendor}/*" '

        command! -bang -nargs=* F call fzf#vim#grep(g:rg_command .shellescape(<q-args>), 1, <bang>0)

You now have a  killer free text search with :F that uses  ripgrep and is faster
than any I've seen before.

I've done  more with this, but  want to leave it  there for now. There  are even
more goodies in my .vimrc, and in  my .bashrc, including auto installing fzf and
ripgrep (admittedly  hackily) from the .vimrc  and a nice snippet  that uses fzf
for git logs.

Update

Just made this nice snippet for tmux:

        tm() {
        local session
        newsession=${1:-new}
        session=$(tmux list-sessions -F "#{session_name}" | \
            fzf --query="$1" --select-1 --exit-0) &&
            tmux attach-session -t "$session" || tmux new-session -s $newsession
        }


        - tm with no sessions open it will create a session called "new".
        - tm irc it will attach to the irc session (if it exists), else it will create it.
        - tm with one session open, it will attach to that session.
        - tm with more than one session open it will let you select the session via fzf.

And here is a nice snippet for looking through git logs:

        fzf_log() {
        hash=$(git log --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |  fzf | awk '{print $1}')
        echo $hash | xclip
        git showtool $hash
        }

It will let you select a commit, and display the diff off it, and put the commit
hash on  your clipboard using xclip.  I also have it  set to use icdiff  via git
showtool.

Update update...

A few  people have  pointed out that  doing this doesn't  work for  fzf's Ctrl+T
completion or the Alt+C completion. Thanks  to @mikepqr, for letting me know the
work around for Ctrl+T. I have updated the configurations at the top of the post
with what he sent me.

Alt+C  has proved  a bit  tricky  to get  working  with ripgrep,  as rg  doesn't
natively support searching  just for directories. Instead I have  been using bfs
(https://github.com/tavianator/bfs) by adding the following to me config.

        export FZF_ALT_C_COMMAND="bfs -type d -nohidden"

After   a   bit   of   quick   testing    it   appears   to   run   faster   and
give   slightly  nicer   results   that  the   ripgrep   solutions  I've   tried
(https://github.com/BurntSushi/ripgrep/issues/388),   although   it  does   mean
installing another tool!


http://www.wezm.net/technical/2016/09/ripgrep-with-vim/

Set grepprg, which is  used by :grep to search a project and  add the matches to
the quickfix list:

        if executable("rg")
            set grepprg=rg\ --vimgrep\ --no-heading
            set grepformat=%f:%l:%c:%m,%f:%l:%m
        endif

For use with ack.vim set g:ackprg as follows.  Now when you run :Ack it will use
rg instead:

        let g:ackprg = 'rg --vimgrep --no-heading'

One of my favourite plugins, fzf.vim has built-in support for ag. I’ve created
an experimental fork that  adds support for rg to it. My fork  adds the :Rg user
command, which works the same way as the existing :Ag command. To use my version
of the plugin with vim-plug add the following to your .vimrc:

        Plug 'wezm/fzf.vim', { 'branch': 'rg' }

==============================================================================
------------------------------------------------------------------------------
==============================================================================
Usage is as follows: You define a function >

   let g:ulti_expand_or_jump_res = 0 "default value, just set once

   fu! Ulti_ExpandOrJump_and_getRes() abort
       call UltiSnips#ExpandSnippetOrJump()
       return g:ulti_expand_or_jump_res
   endfu

then you define your mapping as >

   ino  <NL>  <c-r>=(Ulti_ExpandOrJump_and_getRes() > 0) ? '' : IMAP_Jumpfunc('', 0)<cr>

and if the you can't expand or jump from the current location then the
alternative function IMAP_Jumpfunc('', 0) is called.

3.2.2 Custom autocommands                       *UltiSnips-custom-autocommands*
-------------------------

Note Autocommands must *not* change the buffer in any way. If lines are added,
deleted, or modified it will confuse UltiSnips which might scramble your
snippets contents.

                          *UltiSnipsEnterFirstSnippet* *UltiSnipsExitLastSnippet*
For maximum compatibility with other plug-ins, UltiSnips sets up some special
state, include mappings and autocommands, when a snippet starts being
expanded, and tears them down once the last snippet has been exited. In order
to make it possible to override these "inner" settings, it fires the following
"User" autocommands:

UltiSnipsEnterFirstSnippet
UltiSnipsExitLastSnippet

For example, to call a pair of custom functions in response to these events,
you might do: >

   au! User UltiSnipsEnterFirstSnippet
   au  User UltiSnipsEnterFirstSnippet call CustomInnerKeyMapper()
   au! User UltiSnipsExitLastSnippet
   au  User UltiSnipsExitLastSnippet call CustomInnerKeyUnmapper()

Note that snippet expansion may be nested, in which case
|UltiSnipsEnterFirstSnippet| will fire only as the first (outermost) snippet
is entered, and |UltiSnipsExitLastSnippet| will only fire once the last
(outermost) snippet have been exited.



3.2.3 Path to Python module                   *UltiSnips-python-module-path*
---------------------------

For even more advanced usage, you can directly write python functions using
UltiSnip's python modules.

Here is a small example funtion that expands a snippet: >

   fu! s:Ulti_ExpandSnip() abort
   Python << EOF
   import sys, vim
   from UltiSnips import UltiSnips_Manager
   UltiSnips_Manager.expand()
   EOF
       return ''
   endfu

3.3 Snippet Search Path                       *UltiSnips-snippet-search-path*
-----------------------

UltiSnips snippet definition files are stored in one or more directories.
There are several variables used to indicate those directories and to define
how UltiSnips loads snippets.

Snippet definition files are stored in snippet directories. A snippet
directory must be a subdirectory of a directory defined in the 'runtimepath'
option. The variable g:UltiSnipsSnippetDirectories defines a list of names
used for snippet directories. Note that "snippets" is reserved for snipMate
snippets and cannot be used. The default is shown below. >

   let g:UltiSnipsSnippetDirectories=["UltiSnips"]

UltiSnips will search each 'runtimepath' directory for the subdirectory names
defined in g:UltiSnipsSnippetDirectories in the order they are defined. For
example, if you keep your snippets in a .vim subdirectory called
"mycoolsnippets" and you want to make use of the default snippets that come
with UltiSnips, add the following to your vimrc file. >
   let g:UltiSnipsSnippetDirectories=["UltiSnips", "mycoolsnippets"]
If you do not want to use the third party snippets that come with plugins,
define the variable accordingly: >
   let g:UltiSnipsSnippetDirectories=["mycoolsnippets"]

You can also redefine the search path on a buffer by buffer basis by setting
the variable b:UltiSnipsSnippetDirectories. This variable takes precedence
over the global variable.

|UltiSnips-adding-snippets| explains which files are parsed for a given filetype.

If only one directory is specified in this variable and this directory is
specified by absolute path, UltiSnips will not look for snippets in
&runtimepath, which can lead to significant speedup. So, the common case is:

    let g:UltiSnipsSnippetDirectories=$HOME.'/.vim/UltiSnips'

However, you will not able to use snippets that are shipped with third party
plugins out of the box. You'll need to copy them into your chosen directory.


3.4 Warning About Select Mode Mappings          *UltiSnips-warning-smappings*
--------------------------------------

Vim's help document for |mapmode-s| states: >
   NOTE: Mapping a printable character in Select mode may confuse the user.
   It's better to explicitly use :xmap and :smap for printable characters.  Or
   use :sunmap after defining the mapping.

However, most Vim plugins, including some default Vim plugins, do not adhere
to this. UltiSnips uses Select mode to mark tabstops in snippets for
overwriting. Existing Visual+Select mode mappings will interfere. Therefore,
UltiSnips issues a |:sunmap| command to remove each Select mode mapping for
printable characters. No other mappings are touched. In particular, UltiSnips
does not change existing normal, insert or visual mode mappings.

If this behavior is not desired, you can disable it by adding this line to
your vimrc file. >
   let g:UltiSnipsRemoveSelectModeMappings = 0

If you want to disable this feature for specific mappings only, add them to
the list of mappings to be ignored. For example, the following lines in your
vimrc file will unmap all Select mode mappings except those mappings
containing either the string "somePlugin" or the string "otherPlugin" in its
complete definition as listed by the |:smap| command. >

   let g:UltiSnipsRemoveSelectModeMappings = 1
   let g:UltiSnipsMappingsToIgnore = [ "somePlugin", "otherPlugin" ]


3.5 Functions                                           *UltiSnips-functions*
-------------

UltiSnips provides some functions for extending core functionality.


 3.5.1 UltiSnips#AddSnippetWithPriority    *UltiSnips#AddSnippetWithPriority*

The first function is UltiSnips#AddSnippetWithPriority(trigger, value, description,
options, filetyp, priority). It adds a new snippet with the provided trigger, value,
description, and options to the current list of snippets. See
|UltiSnips-syntax| for details on the meaning of the function arguments. The
Priority is a number that defines which snippet should be preferred over
others. See the priority keyword in|UltiSnips-add-snippets|.


 3.5.2 UltiSnips#Anon                                        *UltiSnips#Anon*

The second function is UltiSnips#Anon(value, ...). It expands an anonymous
snippet. Anonymous snippets are defined on the spot, expanded and immediately
discarded again. Anonymous snippets are not added to the global list of
snippets, so they cannot be expanded a second time unless the function is
called again. The function takes three optional arguments, in order: trigger,
description, options. Arguments coincide with the arguments of the
|UltiSnips#AddSnippetWithPriority| function of the same name. The trigger and
options arguments can change the way the snippet expands. Same options
can be specified as in the snippet definition. See full list of options at
|UltiSnips-snippet-options|. The description is unused at this point.

An example use case might be this line from a reStructuredText plugin file:

   ino  <silent>  $$  $$<C-R>=UltiSnips#Anon(':latex:\`$1\`', '$$')<cr>

This expands the snippet whenever two $ signs are typed.
Note: The right-hand side of the mapping starts with an immediate retype of
the '$$' trigger and passes '$$' to the function as the trigger argument.
This is required in order for UltiSnips to have access to the characters
typed so it can determine if the trigger matches or not.

 3.5.3 UltiSnips#SnippetsInCurrentScope    *UltiSnips#SnippetsInCurrentScope*

A third function is UltiSnips#SnippetsInCurrentScope which is the equivalent
of snipmate GetSnipsInCurrentScope function.

This function simply returns a vim dictionary with the snippets whose trigger
matches the current word.  If you need all snippets information of current
buffer, you can simply pass 1 (which means all) as first argument of this
function, and use a global variable g:current_ulti_dict_info to get the
result (see example below).

This function does not add any new functionality to ultisnips directly but
allows to use third party plugins to integrate the current available snippets.

An example of such third party plugin is SnippetCompleteSnipMate which uses
the function GetSnipsInCurrentScope to integrate the current available
snippets with user defined abbreviations and provides these and a completion
menu.
This script is located in
http://www.vim.org/scripts/script.php?script_id=4276.
Note: If you check the above website it lists two dependencies: the
SnippetComplete plugin and snipmate.
You do need the SnippetComplete plugin but you obviously don't need snipmate,
you just have to define the function GetSnipsInCurrentScope. Put the following
in your vimrc:

function! GetSnipsInCurrentScope()
  return UltiSnips#SnippetsInCurrentScope()
endfunction


As a second example on how to use this function consider the following
function and mapping definition:

function! ExpandPossibleShorterSnippet()
  if len(UltiSnips#SnippetsInCurrentScope()) == 1 "only one candidate...
    let curr_key = keys(UltiSnips#SnippetsInCurrentScope())[0]
    normal diw
    exe "normal a" . curr_key
    exe "normal a "
    return 1
  endif
  return 0
endfunction
ino  <silent>  <c-l>  <c-r>=(ExpandPossibleShorterSnippet() == 0 ? '' : UltiSnips#ExpandSnippet())<cr>

If the trigger for your snippet is lorem, you type lor, and you have no other
snippets whose trigger matches lor then hitting <c-l> will expand to whatever
lorem expands to.

A third example on how to use this function to extract all snippets of
current buffer: >

function! GetAllSnippets()
  call UltiSnips#SnippetsInCurrentScope(1)
  let list = []
  for [key, info] in items(g:current_ulti_dict_info)
    let parts = split(info.location, ':')
    call add(list, {
      \"key": key,
      \"path": parts[0],
      \"linenr": parts[1],
      \"description": info.description,
      \})
  endfor
  return list
endfunction

The new variable g:current_ulti_dict_info is made to avoid confilct with
exists third party plugins.  The definition location contains file path and
line number is also included in this variable.

3.6 Warning about missing python support           *UltiSnips-python-warning*
----------------------------------------

When UltiSnips is loaded, it will check that the running Vim was compiled with
python support.  If no support is detected, a warning will be displayed and
loading of UltiSnips will be skipped.

If you would like to suppress this warning message, you may add the following
line to your vimrc file.

    let g:UltiSnipsNoPythonWarning = 1

This may be useful if your Vim configuration files are shared across several
systems where some of them may not have Vim compiled with python support.

=============================================================================
4. Syntax                                                  *UltiSnips-syntax*

This chapter describes how to write your own snippets and snippet definition
syntax. Examples are used to help illustrate.


4.1 Adding Snippets                               *UltiSnips-adding-snippets*
-------------------

See |UltiSnips-snippet-search-path| for an explanation of where directories
with snippet definitions should be located.

Using a strategy similar to how Vim detects |ftplugins|, UltiSnips iterates
over the snippet definition directories looking for files with names of the
following patterns: ft.snippets, ft_*.snippets, or ft/*, where "ft" is the
'filetype' of the current document and "*" is a shell-like wildcard matching
any string including the empty string. The following table shows some typical
snippet filenames and their associated filetype.

    snippet filename         filetype ~
    ruby.snippets            ruby
    perl.snippets            perl
    c.snippets               c
    c_my.snippets            c
    c/a                      c
    c/b.snippets             c
    all.snippets             *all
    all/a.snippets           *all

* The 'all' filetype is unique. It represents snippets available for use when
editing any document regardless of the filetype. A date insertion snippet, for
example, would fit well in the all.snippets file.

UltiSnips understands Vim's dotted filetype syntax. For example, if you define
a dotted filetype for the CUDA C++ framework, e.g. ":set ft=cuda.cpp", then
UltiSnips will search for and activate snippets for both the cuda and cpp
filetypes.

The snippets file syntax is simple. All lines starting with a # character are
considered comments. Comments are ignored by UltiSnips. Use them to document
snippets.

A line beginning with the keyword 'extends' provides a way of combining
snippet files. When the 'extends' directive is included in a snippet file, it
instructs UltiSnips to include all snippets from the indicated filetypes.

The syntax looks like this: >
   extends ft1, ft2, ft3

For example, the first line in cpp.snippets looks like this: >
   extends c
When UltiSnips activates snippets for a cpp file, it first looks for all c
snippets and activates them as well. This is a convenient way to create
specialized snippet files from more general ones. Multiple 'extends' lines are
permitted in a snippet file, and they can be included anywhere in the file.


A line beginning with the keyword 'priority' sets the priority for all
snippets defined in the current file after this line. The default priority for
a file is always 0. When a snippet should be expanded, UltiSnips will collect
all snippet definitions from all sources that match the trigger and keep only
the ones with the highest priority. For example, all shipped snippets have a
priority < 0, so that user defined snippets always overwrite shipped snippets.


A line beginning with the keyword 'snippet' marks the beginning of snippet
definition and a line starting with  the keyword 'endsnippet' marks the end.
The snippet definition is placed between the lines. Here is a snippet of an
'if' statement for the Unix shell (sh) filetype.

    snippet if "if ... then (if)"
    if ${2:[[ ${1:condition} ]]}; then
            ${0:#statements}
    fi
    endsnippet

The start line takes the following form: >

   snippet tab_trigger [ "description" [ options ] ]

The tab_trigger is required, but the description and options are optional.

The 'tab_trigger' is the word or string sequence used to trigger the snippet.
Generally a single word is used but the tab_trigger can include spaces. If you
wish to include spaces, you must wrap the tab trigger in quotes. >

    snippet "tab trigger" [ "description" [ options ] ]

The quotes are not part of the trigger. To activate the snippet type: tab trigger
followed by the snippet expand character.

It is not technically necessary to use quotes to wrap a trigger with spaces.
Any matching characters will do. For example, this is a valid snippet starting
line. >
    snippet !tab trigger! [ "description" [ options ] ]

Quotes can be included as part of the trigger by wrapping the trigger in
another character. >
    snippet !"tab trigger"! [ "description" [ options ] ]

To activate this snippet one would type: "tab trigger"

The 'description' is a string describing the trigger. It is helpful for
documenting the snippet and for distinguishing it from other snippets with the
same tab trigger. When a snippet is activated and more than one tab trigger
match, UltiSnips displays a list of the matching snippets with their
descriptions. The user then selects the snippet they want.

                                                  *UltiSnips-snippet-options*

The 'options' control the behavior of the snippet. Options are indicated by
single characters. The 'options' characters for a snippet are combined into
a word without spaces.

The options currently supported are: >
   b   Beginning of line - A snippet with this option is expanded only if the
       tab trigger is the first word on the line. In other words, if only
       whitespace precedes the tab trigger, expand. The default is to expand
       snippets at any position regardless of the preceding non-whitespace
       characters.

   i   In-word expansion - By default a snippet is expanded only if the tab
       trigger is the first word on the line or is preceded by one or more
       whitespace characters. A snippet with this option is expanded
       regardless of the preceding character. In other words, the snippet can
       be triggered in the middle of a word.

   w   Word boundary - With this option, the snippet is expanded if
       the tab trigger start matches a word boundary and the tab trigger end
       matches a word boundary. In other words the tab trigger must be
       preceded and followed by non-word characters. Word characters are
       defined by the 'iskeyword' setting. Use this option, for example, to
       permit expansion where the tab trigger follows punctuation without
       expanding suffixes of larger words.

   r   Regular expression - With this option, the tab trigger is expected to
       be a python regular expression. The snippet is expanded if the recently
       typed characters match the regular expression. Note: The regular
       expression MUST be quoted (or surrounded with another character) like a
       multi-word tab trigger (see above) whether it has spaces or not. A
       resulting match is passed to any python code blocks in the snippet
       definition as the local variable "match".

   t   Do not expand tabs - If a snippet definition includes leading tab
       characters, by default UltiSnips expands the tab characters honoring
       the Vim 'shiftwidth', 'softtabstop', 'expandtab' and 'tabstop'
       indentation settings. (For example, if 'expandtab' is set, the tab is
       replaced with spaces.) If this option is set, UltiSnips will ignore the
       Vim settings and insert the tab characters as is. This option is useful
       for snippets involved with tab delimited formats, for example.

   s   Remove whitespace immediately before the cursor at the end of a line
       before jumping to the next tabstop.  This is useful if there is a
       tabstop with optional text at the end of a line.

   m   Trim all whitespaces from right side of snippet lines. Useful when
       snippet contains empty lines which should remain empty after expanding.
       Without this option empty lines in snippets definition will have
       indentation too.

   e   Context snippets - With this option expansion of snippet can be
       controlled not only by previous characters in line, but by any given
       python expression. This option can be specified along with other
       options, like 'b'. See |UltiSnips-context-snippets| for more info.

   A   Snippet will be triggered automatically, when condition matches.
       See |UltiSnips-autotrigger| for more info.

The end line is the 'endsnippet' keyword on a line by itself. >

   endsnippet

When parsing snippet files, UltiSnips chops the trailing newline character
from the 'endsnippet' end line.


 4.1.1 Character Escaping:                     *UltiSnips-character-escaping*

In snippet definitions, the characters '`', '{', '$' and '\' have special
meaning. If you want to insert one of these characters literally, escape them
with a backslash, '\'.


4.3 Visual Placeholder                         *UltiSnips-visual-placeholder*
----------------------

Snippets can contain a special placeholder called ${VISUAL}. The ${VISUAL}
variable is expanded with the text selected just prior to expanding the
snippet.

To see how a snippet with a ${VISUAL} placeholder works, define a snippet with
the placeholder, use Vim's Visual mode to select some text, and then press the
key you use to trigger expanding a snippet (see g:UltiSnipsExpandTrigger). The
selected text is deleted, and you are dropped into Insert mode. Now type the
snippet tab trigger and press the key to trigger expansion. As the snippet
expands, the previously selected text is printed in place of the ${VISUAL}
placeholder.

The ${VISUAL} placeholder can contain default text to use when the snippet has
been triggered when not in Visual mode. The syntax is: >
    ${VISUAL:default text}

The ${VISUAL} placeholder can also define a transformation (see
|UltiSnips-transformations|). The syntax is: >
    ${VISUAL:default/search/replace/option}.

Here is a simple example illustrating a visual transformation. The snippet
will take selected text, replace every instance of "should" within it with
"is" , and wrap the result in tags.

------------------- SNIP -------------------
snippet t
<tag>${VISUAL:inside text/should/is/g}</tag>
endsnippet
------------------- SNAP -------------------

Start with this line of text: >
   this should be cool

Position the cursor on the word "should", then press the key sequence: viw
(visual mode -> select inner word). Then press <Tab>, type "t" and press <Tab>
again. The result is: >
   -> this <tag>is</tag> be cool

If you expand this snippet while not in Visual mode (e.g., in Insert mode type
t<Tab>), you will get: >
   <tag>inside text</tag>


4.4 Interpolation                                   *UltiSnips-interpolation*
-----------------

 4.4.1 Shellcode:                                       *UltiSnips-shellcode*

Snippets can include shellcode. Put a shell command in a snippet and when the
snippet is expanded, the shell command is replaced by the output produced when
the command is executed. The syntax for shellcode is simple: wrap the code in
backticks, '`'. When a snippet is expanded, UltiSnips runs shellcode by first
writing it to a temporary script and then executing the script. The shellcode
is replaced by the standard output. Anything you can run as a script can be
used in shellcode. Include a shebang line, for example, #!/usr/bin/perl, and
your snippet has the ability to run scripts using other programs, perl, for
example.

Here are some examples. This snippet uses a shell command to insert the
current date.

------------------- SNIP -------------------
snippet today
Today is the `date +%d.%m.%y`.
endsnippet
------------------- SNAP -------------------

today<tab> ->
Today is the 15.07.09.


This example inserts the current date using perl.

------------------- SNIP -------------------
snippet today
Today is `#!/usr/bin/perl
@a = localtime(); print $a[3] . '.' . $a[4] . '.' . ($a[5]+1900);`.
endsnippet
------------------- SNAP -------------------
today<tab> ->
Today is 15.6.2009.


 4.4.2 VimScript:                                       *UltiSnips-vimscript*

You can also use Vim scripts (sometimes called VimL) in interpolation. The
syntax is similar to shellcode. Wrap the code in backticks and to distinguish
it as a Vim script, start the code with '!v'. Here is an example that counts
the indent of the current line:

------------------- SNIP -------------------
snippet indent
Indent is: `!v indent(".")`.
endsnippet
------------------- SNAP -------------------
    (note the 4 spaces in front): indent<tab> ->
    (note the 4 spaces in front): Indent is: 4.


 4.4.3 Python:                                             *UltiSnips-python*

Python interpolation is by far the most powerful. The syntax is similar to Vim
scripts except code is started with '!p'. Python scripts can be run using the
python shebang '#!/usr/bin/python', but using the '!p' format comes with some
predefined objects and variables, which can simplify and shorten code. For
example, a 'snip' object instance is implied in python code. Python code using
the '!p' indicator differs in another way. Generally when a snippet is
expanded the standard output of code replaces the code. With python code the
value of the 'rv' property of the 'snip' instance replaces the code. Standard
output is ignored.

The variables automatically defined in python code are: >

   fn      - The current filename
   path    - The complete path to the current file
   t       - The values of the placeholders, t[1] is the text of ${1}, etc.
   snip    - UltiSnips.TextObjects.SnippetUtil object instance. Has methods
             that simplify indentation handling.
   context - Result of context condition. See |UltiSnips-context-snippets|.

The 'snip' object provides the following methods: >

    snip.mkline(line="", indent=None):
        Returns a line ready to be appended to the result. If indent
        is None, then mkline prepends spaces and/or tabs appropriate to the
        current 'tabstop' and 'expandtab' variables.

    snip.shift(amount=1):
        Shifts the default indentation level used by mkline right by the
        number of spaces defined by 'shiftwidth', 'amount' times.

    snip.unshift(amount=1):
        Shifts the default indentation level used by mkline left by the
        number of spaces defined by 'shiftwidth', 'amount' times.

    snip.reset_indent():
        Resets the indentation level to its initial value.

    snip.opt(var, default):
        Checks if the Vim variable 'var' has been set. If so, it returns the
        variable's value; otherwise, it returns the value of 'default'.

The 'snip' object provides some properties as well: >

    snip.rv:
        'rv' is the return value, the text that will replace the python block
        in the snippet definition. It is initialized to the empty string. This
        deprecates the 'res' variable.

    snip.c:
        The text currently in the python block's position within the snippet.
        It is set to empty string as soon as interpolation is completed. Thus
        you can check if snip.c is != "" to make sure that the interpolation
        is only done once. This deprecates the "cur" variable.

    snip.v:
         Data related to the ${VISUAL} placeholder. The property has two
         attributes:
             snip.v.mode   ('v', 'V', '^V', see |visual-mode| )
             snip.v.text   The text that was selected.

    snip.fn:
        The current filename.

    snip.basename:
        The current filename with the extension removed.

    snip.ft:
        The current filetype.

    snip.p:
        Last selected placeholder. Will contain placeholder object with
        following properties:

        'current_text' - text in the placeholder on the moment of selection;
        'start' - placeholder start on the moment of selection;
        'end' - placeholder end on the moment of selection;

For your convenience, the 'snip' object also provides the following
operators: >

    snip >> amount:
        Equivalent to snip.shift(amount)
    snip << amount:
        Equivalent to snip.unshift(amount)
    snip += line:
        Equivalent to "snip.rv += '\n' + snip.mkline(line)"

Any variables defined in a python block can be used in other python blocks
that follow within the same snippet. Also, the python modules 'vim', 're',
'os', 'string' and 'random' are pre-imported within the scope of snippet code.
Other modules can be imported using the python 'import' command.

Python code allows for very flexible snippets. For example, the following
snippet mirrors the first tabstop value on the same line but right aligned and
in uppercase.

------------------- SNIP -------------------
snippet wow
${1:Text}`!p snip.rv = (75-2*len(t[1]))*' '+t[1].upper()`
endsnippet
------------------- SNAP -------------------
wow<tab>Hello World ->
Hello World                                                     HELLO WORLD

The following snippet uses the regular expression option and illustrates
regular expression grouping using python's match object. It shows that the
expansion of a snippet can depend on the tab trigger used to define the
snippet, and that tab trigger itself can vary.

------------------- SNIP -------------------
snippet "be(gin)?( (\S+))?" "begin{} / end{}" br
\begin{${1:`!p
snip.rv = match.group(3) if match.group(2) is not None else "something"`}}
    ${2:${VISUAL}}
\end{$1}$0
endsnippet
------------------- SNAP -------------------
be<tab>center<c-j> ->
\begin{center}

\end{center}
------------------- SNAP -------------------
be center<tab> ->
\begin{center}

\end{center}

The second form is a variation of the first; both produce the same result,
but it illustrates how regular expression grouping works. Using regular
expressions in this manner has some drawbacks:
1. If you use the <Tab> key for both expanding snippets and completion then
   if you typed "be form<Tab>" expecting the completion "be formatted", you
   would end up with the above SNAP instead, not what you want.
2. The snippet is harder to read.

The biggest advantage, however, is that you can create snippets that take into
account the text preceding a "trigger". This way, you can use it to create
postfix snippets, which are popular in some IDEs.

------------------- SNIP -------------------
snippet "(\w+).par" "Parenthesis (postfix)" r
(`!p snip.rv = match.group(1)`$1)$0
endsnippet
------------------- SNAP -------------------
something.par<tab> ->
(something)

------------------- SNIP -------------------
snippet "([^\s].*)\.return" "Return (postfix)" r
return `!p snip.rv = match.group(1)`$0
endsnippet
------------------- SNAP -------------------
value.return<tab> ->
return value


 4.4.4 Global Snippets:                                   *UltiSnips-globals*

Global snippets provide a way to reuse common code in multiple snippets.
Currently, only python code is supported. The result of executing the contents
of a global snippet is put into the globals of each python block in the
snippet file. To create a global snippet, use the keyword 'global' in place of
'snippet', and for python code, you use '!p' for the trigger. For example, the
following snippet produces the same output as the last example . However, with
this syntax the 'upper_right' snippet can be reused by other snippets.

------------------- SNIP -------------------
global !p
def upper_right(inp):
    return (75 - 2 * len(inp))*' ' + inp.upper()
endglobal

snippet wow
${1:Text}`!p snip.rv = upper_right(t[1])`
endsnippet
------------------- SNAP -------------------
wow<tab>Hello World ->
Hello World                                                     HELLO WORLD

Python global functions can be stored in a python module and then imported.
This makes global functions easily accessible to all snippet files. Since Vim
7.4 you can just drop python files into ~/.vim/pythonx and import them
directly inside your snippets. For example to use
~/.vim/pythonx/my_snippets_helpers.py  >

   global !p
   from my_snippet_helpers import *
   endglobal


4.5 Tabstops and Placeholders   *UltiSnips-tabstops* *UltiSnips-placeholders*
-----------------------------

Snippets are used to quickly insert reused text into a document. Often the
text has a fixed structure with variable components. Tabstops are used to
simplify modifying the variable content. With tabstops you can easily place
the cursor at the point of the variable content, enter the content you want,
then jump to the next variable component, enter that content, and continue
until all the variable components are complete.

The syntax for a tabstop is the dollar sign followed by a number, for example,
'$1'. Tabstops start at number 1 and are followed in sequential order. The
'$0' tabstop is a special tabstop. It is always the last tabstop in the
snippet no matter how many tabstops are defined. If there is no '$0' defined,
'$0' tabstop will be defined at the end of snippet.

Here is a simple example.

------------------- SNIP -------------------
snippet letter
Dear $1,
$0
Yours sincerely,
$2
endsnippet
------------------- SNAP -------------------
letter<tab>Ben<c-j>Paul<c-j>Thanks for suggesting UltiSnips!->
Dear Ben,
Thanks for suggesting UltiSnips!
Yours sincerely,
Paul

You can use <c-j> to jump to the next tabstop, and <c-k> to jump to the
previous. The <Tab> key was not used for jumping forward because many people
(myself included) use <Tab> for completion. See |UltiSnips-triggers| for
help on defining different keys for tabstops.

It is often useful to have some default text for a tabstop. The default text
may be a value commonly used for the variable component, or it may be a word
or phrase that reminds you what is expected for the variable component. To
include default text, the syntax is '${1:value}'.

The following example illustrates a snippet for the shell 'case' statement.
The tabstops use default values to remind the user of what value is expected.

------------------- SNIP -------------------
snippet case
case ${1:word} in
    ${2:pattern} ) $0;;
esac
endsnippet
------------------- SNAP -------------------

case<tab>$option<c-j>-v<c-j>verbose=true
case $option in
    -v ) verbose=true;;
esac


Sometimes it is useful to have a tabstop within a tabstop. To do this, simply
include the nested tabstop as part of the default text. Consider the following
example illustrating an HTML anchor snippet.

------------------- SNIP -------------------
snippet a
<a href="${1:http://www.${2:example.com}}"</a>
    $0
</a>
endsnippet
------------------- SNAP -------------------

When this snippet is expanded, the first tabstop has a default value of
'http://www.example.com'. If you want the 'http://' schema, jump to the next
tabstop. It has a default value of 'example.com'. This can be replaced by
typing whatever domain you want.

a<tab><c-j>google.com<c-j>Google ->
<a href="http://www.google.com">
    Google
</a>

If at the first tabstop you want a different url schema or want to replace the
default url with a named anchor, '#name', for example, just type the value you
want.

a<tab>#top<c-j>Top ->
<a href="#top">
    Top
</a>

In the last example, typing any text at the first tabstop replaces the default
value, including the second tabstop, with the typed text. So the second
tabstop is essentially deleted. When a tabstop jump is triggered, UltiSnips
moves to the next remaining tabstop '$0'. This feature can be used
intentionally as a handy way for providing optional tabstop values to the
user. Here is an example to illustrate.

------------------- SNIP -------------------
snippet a
<a href="$1"${2: class="${3:link}"}>
    $0
</a>
endsnippet
------------------- SNAP -------------------

Here, '$1' marks the first tabstop. It is assumed you always want to add a
value for the 'href' attribute. After entering the url and pressing <c-j>, the
snippet will jump to the second tabstop, '$2'. This tabstop is optional. The
default text is ' class="link"'. You can press <c-j> to accept the tabstop,
and the snippet will jump to the third tabstop, '$3', and you can enter the
class attribute value, or, at the second tabstop you can press the backspace
key thereby replacing the second tabstop default with an empty string,
essentially removing it. In either case, continue by pressing <c-j> and the
snippet will jump to the final tabstop inside the anchor.

a<tab>http://www.google.com<c-j><c-j>visited<c-j>Google ->
<a href="http://www.google.com" class="visited">
    Google
</a>

a<tab>http://www.google.com<c-j><BS><c-j>Google ->
<a href="http://www.google.com">
    Google
</a>

The default text of tabstops can also contain mirrors, transformations or
interpolation.


4.6 Mirrors                                               *UltiSnips-mirrors*
-----------

Mirrors repeat the content of a tabstop. During snippet expansion when you
enter the value for a tabstop, all mirrors of that tabstop are replaced with
the same value. To mirror a tabstop simply insert the tabstop again using the
"dollar sign followed by a number" syntax, e.g., '$1'.

A tabstop can be mirrored multiple times in one snippet, and more than one
tabstop can be mirrored in the same snippet. A mirrored tabstop can have a
default value defined. Only the first instance of the tabstop need have a
default value. Mirrored tabstop will take on the default value automatically.

Mirrors are handy for start-end tags, for example, TeX 'begin' and 'end' tag
labels, XML and HTML tags, and C code #ifndef blocks. Here are some snippet
examples.

------------------- SNIP -------------------
snippet env
\begin{${1:enumerate}}
    $0
\end{$1}
endsnippet
------------------- SNAP -------------------
env<tab>itemize ->
\begin{itemize}

\end{itemize}

------------------- SNIP -------------------
snippet ifndef
#ifndef ${1:SOME_DEFINE}
#define $1
$0
#endif /* $1 */
endsnippet
------------------- SNAP -------------------
ifndef<tab>WIN32 ->
#ifndef WIN32
#define WIN32

#endif /* WIN32 */


4.7 Transformations                               *UltiSnips-transformations*
-------------------

Note: Transformations are a bit difficult to grasp so this chapter is divided
into two sections. The first describes transformations and their syntax, and
the second illustrates transformations with demos.

Transformations are like mirrors but instead of just copying text from the
original tabstop verbatim, a regular expression is matched to the content of
the referenced tabstop and a transformation is then applied to the matched
pattern. The syntax and functionality of transformations in UltiSnips follow
very closely to TextMate transformations.

A transformation has the following syntax: >
   ${<tab_stop_no/regular_expression/replacement/options}

The components are defined as follows: >
   tab_stop_no        - The number of the tabstop to reference
   regular_expression - The regular expression the value of the referenced
                        tabstop is matched on
   replacement        - The replacement string, explained in detail below
   options            - Options for the regular expression

The options can be any combination of >
   g    - global replace
          By default, only the first match of the regular expression is
          replaced. With this option all matches are replaced.
   i    - case insensitive
          By default, regular expression matching is case sensitive. With this
          option, matching is done without regard to case.
   m    - multiline
          By default, the '^' and '$' special characters only apply to the
          start and end of the entire string; so if you select multiple lines,
          transformations are made on them entirely as a whole single line
          string. With this option, '^' and '$' special characters match the
          start or end of any line within a string ( separated by newline
          character - '\n' ).
   a    - ascii conversion
          By default, transformation are made on the raw utf-8 string. With
          this option, matching is done on the corresponding ASCII string
          instead, for example 'à' will become 'a'.
          This option required the python package 'unidecode'.

The syntax of regular expressions is beyond the scope of this document. Python
regular expressions are used internally, so the python 're' module can be used
as a guide. See http://docs.python.org/library/re.html.

The syntax for the replacement string is unique. The next paragraph describes
it in detail.


 4.7.1 Replacement String:                     *UltiSnips-replacement-string*

The replacement string can contain $no variables, e.g., $1, which reference
matched groups in the regular expression. The $0 variable is special and
yields the whole match. The replacement string can also contain special escape
sequences: >
   \u   - Uppercase next letter
   \l   - Lowercase next letter
   \U   - Uppercase everything till the next \E
   \L   - Lowercase everything till the next \E
   \E   - End upper or lowercase started with \L or \U
   \n   - A newline
   \t   - A literal tab

Finally, the replacement string can contain conditional replacements using the
syntax (?no:text:other text). This reads as follows: if the group $no has
matched, insert "text", otherwise insert "other text". "other text" is
optional and if not provided defaults to the empty string, "". This feature
is very powerful. It allows you to add optional text into snippets.


 4.7.2 Demos:                                               *UltiSnips-demos*

Transformations are very powerful but often the syntax is convoluted.
Hopefully the demos below help illustrate transformation features.

Demo: Uppercase one character
------------------- SNIP -------------------
snippet title "Title transformation"
${1:a text}
${1/\w+\s*/\u$0/}
endsnippet
------------------- SNAP -------------------
title<tab>big small ->
big small
Big small


Demo: Uppercase one character and global replace
------------------- SNIP -------------------
snippet title "Titlelize in the Transformation"
${1:a text}
${1/\w+\s*/\u$0/g}
endsnippet
------------------- SNAP -------------------
title<tab>this is a title ->
this is a title
This Is A Title


Demo: ASCII transformation
------------------- SNIP -------------------
snippet ascii "Replace non ascii chars"
${1: an accentued text}
${1/.*/$0/a}
endsnippet
------------------- SNAP -------------------
ascii<tab>à la pêche aux moules
à la pêche aux moules
a la peche aux moules


Demo: Regular expression grouping
      This is a clever c-like printf snippet, the second tabstop is only shown
      when there is a format (%) character in the first tabstop.

------------------- SNIP -------------------
snippet printf
printf("${1:%s}\n"${1/([^%]|%%)*(%.)?.*/(?2:, :\);)/}$2${1/([^%]|%%)*(%.)?.*/(?2:\);)/}
endsnippet
------------------- SNAP -------------------
printf<tab>Hello<c-j> // End of line ->
printf("Hello\n"); // End of line

But
printf<tab>A is: %s<c-j>A<c-j> // End of line ->
printf("A is: %s\n", A); // End of line


There are many more examples of what can be done with transformations in the
bundled snippets.


4.8 Clearing snippets                           *UltiSnips-clearing-snippets*

To remove snippets for the current file type, use the 'clearsnippets'
directive.

------------------- SNIP -------------------
clearsnippets
------------------- SNAP -------------------

'clearsnippets' removes all snippets with a priority lower than the current
one. For example, the following cleares all snippets that have priority <= 1,
even though the example snippet is defined after the 'clearsnippets'.

------------------- SNIP -------------------
priority 1
clearsnippets

priority -1
snippet example "Cleared example"
    This will never be expanded.
endsnippet
------------------- SNAP -------------------

To clear one or more specific snippet, provide the triggers of the snippets as
arguments to the 'clearsnippets' command. The following example will clear the
snippets 'trigger1' and 'trigger2'.

------------------- SNIP -------------------
clearsnippets trigger1 trigger2
------------------- SNAP -------------------



4.10 Snippets actions                             *UltiSnips-snippet-actions*
---------------------

Snippet actions is an arbitrary python code which can be executed at specific
points in lifetime of the snippet.

There are three types of actions:

* Pre-expand - invoked just after trigger condition was matched, but before
  snippet actually expanded;
* Post-expand - invoked after snippet was expanded and interpolations
  was applied for the first time, but before jump on the first placeholder.
* Jump - invoked just after jump to the next/prev placeholder.

Specified code will be evaluated at stages defined above and same global
variables and modules will be available that are stated in
the |UltiSnips-context-snippets| section.

                                                *UltiSnips-buffer-proxy*

Note: special variable called 'snip.buffer' should be used for all buffer
modifications. Not 'vim.current.buffer' and not 'vim.command("...")', because
of in that case UltiSnips will not be able to track changes in buffer from
actions.

'snip.buffer' has the same interface as 'vim.current.window.buffer'.

4.10.1 Pre-expand actions                       *UltiSnips-pre-expand-actions*

Pre-expand actions can be used to match snippet in one location and then
expand it in the different location. Some useful cases are: correcting
indentation for snippet; expanding snippet for function declaration in another
function body with moving expansion point beyond initial function; performing
extract method refactoring via expanding snippet in different place.

Pre-expand action declared as follows: >
    pre_expand "python code here"
    snippet ...
    endsnippet

Buffer can be modified in pre-expand action code through variable called
'snip.buffer', snippet expansion position will be automatically adjusted.

If cursor line (where trigger was matched) need to be modified, then special
variable method 'snip.cursor.set(line, column)' must be called with the
desired cursor position. In that case UltiSnips will not remove any matched
trigger text and it should be done manually in action code.

To addition to the scope variables defined above 'snip.visual_content' will be
also declared and will contain text that was selected before snippet expansion
(similar to $VISUAL placeholder).

Following snippet will be expanded at 4 spaces indentation level no matter
where it was triggered.

------------------- SNIP -------------------
pre_expand "snip.buffer[snip.line] = ' '*4; snip.cursor.set(line, 4)"
snippet d
def $1():
    $0
endsnippet
------------------- SNAP -------------------

Following snippet will move the selected code to the end of file and create
new method definition for it:

------------------- SNIP -------------------
pre_expand "del snip.buffer[snip.line]; snip.buffer.append(''); snip.cursor.set(len(snip.buffer)-1, 0)"
snippet x
def $1():
    ${2:${VISUAL}}
endsnippet
------------------- SNAP -------------------

4.10.2 Post-expand actions                     *UltiSnips-post-expand-actions*

Post-expand actions can be used to perform some actions based on the expanded
snippet text. Some cases are: code style formatting (e.g. inserting newlines
before and after method declaration), apply actions depending on python
interpolation result.

Post-expand action declared as follows: >
    post_expand "python code here"
    snippet ...
    endsnippet

Buffer can be modified in post-expand action code through variable called
'snip.buffer', snippet expansion position will be automatically adjusted.

Variables 'snip.snippet_start' and 'snip.snippet_end' will be defined at the
action code scope and will point to positions of the start and end of expanded
snippet accordingly in the form '(line, column)'.

Note: 'snip.snippet_start' and 'snip.snippet_end' will automatically adjust to
the correct positions if post-action will insert or delete lines before
expansion.

Following snippet will expand to method definition and automatically insert
additional newline after end of the snippet. It's very useful to create a
function that will insert as many newlines as required in specific context.

------------------- SNIP -------------------
post_expand "snip.buffer[snip.snippet_end[0]+1:snip.snippet_end[0]+1] = ['']"
snippet d "Description" b
def $1():
    $2
endsnippet
------------------- SNAP -------------------

4.10.3 Post-jump actions                         *UltiSnips-post-jump-actions*

Post-jump actions can be used to trigger some code based on user input into
the placeholders. Notable use cases: expand another snippet after jump or
anonymous snippet after last jump (e.g. perform move method refactoring and
then insert new method invokation); insert heading into TOC after last jump.

Jump-expand action declared as follows: >
    post_jump "python code here"
    snippet ...
    endsnippet

Buffer can be modified in post-jump action code through variable called
'snip.buffer', snippet expansion position will be automatically adjusted.

Next variables and methods will be also defined in the action code scope:
* 'snip.tabstop' - number of tabstop jumped onto;
* 'snip.jump_direction' - '1' if jumped forward and '-1' otherwise;
* 'snip.tabstops' - list with tabstop objects, see above;
* 'snip.snippet_start' - (line, column) of start of the expanded snippet;
* 'snip.snippet_end' - (line, column) of end of the expanded snippet;
* 'snip.expand_anon()' - alias for 'UltiSnips_Manager.expand_anon()';

Tabstop object has several useful properties:
* 'start' - (line, column) of the starting position of the tabstop (also
  accessible as 'tabstop.line' and 'tabstop.col').
* 'end' - (line, column) of the ending position;
* 'current_text' - text inside the tabstop.

Following snippet will insert section in the Table of Contents in the vim-help
file:

------------------- SNIP -------------------
post_jump "if snip.tabstop == 0: insert_toc_item(snip.tabstops[1], snip.buffer)"
snippet s "section" b
`!p insert_delimiter_0(snip, t)`$1`!p insert_section_title(snip, t)`
`!p insert_delimiter_1(snip, t)`
$0
endsnippet
------------------- SNAP -------------------

'insert_toc_item' will be called after first jump and will add newly entered
section into the TOC for current file.

Note: It is also possible to trigger snippet expansion from the jump action.
In that case method 'snip.cursor.preserve()' should be called, so UltiSnips
will know that cursor is already at the required position.

Following example will insert method call at the end of file after user jump
out of method declaration snippet.

------------------- SNIP -------------------
global !p
def insert_method_call(name):
    vim.command('normal G')
    snip.expand_anon(name + '($1)\n')
endglobal

post_jump "if snip.tabstop == 0: insert_method_call(snip.tabstops[1].current_text)"
snippet d "method declaration" b
def $1():
    $2
endsnippet
------------------- SNAP -------------------

4.11 Autotrigger                                       *UltiSnips-autotrigger*
----------------

Note: vim should be newer than 7.4.214 to support this feature.

Many language constructs can occur only at specific places, so it's
possible to use snippets without manually triggering them.

Snippet can be marked as autotriggered by specifying 'A' option in the snippet
definition.

After snippet is defined as being autotriggered, snippet condition will be
checked on every typed character and if condition matches, then snippet will
be triggered.

*Warning:* using of this feature can lead to significant vim slowdown. If you
discovered that, report an issue to the github.com/SirVer/UltiSnips.

Consider following snippets, that can be usefull in Go programming:
------------------- SNIP -------------------
snippet "^p" "package" rbA
package ${1:main}
endsnippet

snippet "^m" "func main" rbA
func main() {
    $1
}
endsnippet
------------------- SNAP -------------------

When "p" character will occur in the beginning of the line, it will be
automatically expanded into "package main". Same with "m" character. There is
no need to press trigger key after "m""

==============================================================================
5. UltiSnips and Other Plugins                      *UltiSnips-other-plugins*

unite - UltiSnips has a source for unite. As an example of how you can use
it add the following function and mappings to your vimrc: >

  fu! UltiSnipsCallUnite() abort
      Unite -start-insert -winheight=100 -immediately -no-empty ultisnips
      return ''
  endfu

  ino  <silent>  <F12>   <c-r>=(pumvisible()? "\<lt>c-e>" : '')<cr><c-r>=UltiSnipsCallUnite()<cr>
  nno  <silent>  <F12>  a<c-r>=(pumvisible()? "\<lt>c-e>" : '')<cr><c-r>=UltiSnipsCallUnite()<cr>

When typing <F12> in either insert or normal mode you will get the unite
interface with matching snippets. Pressing enter will expand the corresponding
snippet. If only one snippet matches the text in front of the cursor will be
expanded when you press the <F12> key.

5.2 Extending UltiSnips                               *UltiSnips-extending*
-------------------------

UltiSnips allows other plugins to add new snippets on the fly. Since UltiSnips
is written in python, the integration is also on a python basis. A small
example can be found in `test.py`, search for AddNewSnippetSource. Please
contact us on github if you integrate UltiSnips with your plugin so it can be
listed in the docs.

==============================================================================
https://github.com/SirVer/ultisnips/tree/master/doc/examples/autojump-if-empty

        Autojump from tabstop when it's empty

https://github.com/SirVer/ultisnips/tree/master/doc/examples/snippets-aliasing

        Aliases for snippets

https://github.com/SirVer/ultisnips/tree/master/doc/examples/tabstop-generation

        Dynamic tabstop generation

https://github.com/reconquest/vim-pythonx/ (1163 sloc, after removing `tests` and all `__init__.py` files)
https://github.com/reconquest/vim-pythonx/issues/11

        Python library

https://github.com/reconquest/snippets

        Snippets

https://github.com/SirVer/ultisnips/pull/507

        PR: pre/post-expand and post-jump actions

https://github.com/seletskiy/dotfiles/blob/8e04f6a47fa1509be96094e5c8923f4b49b22775/.vim/UltiSnips/go.snippets#L11-23

        Interesting snippet.

                “It   covers  all   three   cases   using  one   single-character
                trigger. You don't need to remember three different snippets.”

==============================================================================
------------------------------------------------------------------------------
==============================================================================
VIM-EASY-ALIGN

Screencast:
https://raw.githubusercontent.com/junegunn/i/master/vim-easy-align.gif

https://raw.githubusercontent.com/junegunn/i/master/vim-easy-align-slow.gif

See {EXAMPLES.md}{9} for more examples.

        {9} https://github.com/junegunn/vim-easy-align/blob/master/EXAMPLES.md

==============================================================================
Voca

    délimiteur

            Une opération d'alignement peut être configurée via certaines options.

            Pour éviter de devoir reconfigurer ces options à chaque fois qu'on veut réaliser un même alignement,
            on peut associer un simple caractère à un ensemble prédéfini d'options.

            Ce caractère est appelé délimiteur. Par défaut, 8 délimiteurs sont définis:

                    espace
                    =
                    :
                    .
                    |
                    &
                    #
                    ,


    règle d'alignement

            L'association d'un ensemble d'options à un délimiteur est appelé règle d'alignement.
            On peut la voir comme un raccourci.
            Plutôt que d'écrire une regex, et de configurer plusieurs options, on peut se contenter
            de taper un simple caractère.


On peut utiliser le plugin en mode:

        - interactif via des mappings
        - non-interactif via des commandes Ex

        ----------------------+---------------+--------------------------------------------
        Mapping               | Mode          | Description                                         ~
        ----------------------+---------------+--------------------------------------------
        <Plug>(EasyAlign)     | normal/visual | lance mode interactif
        <Plug>(LiveEasyAlign) | normal/visual | lance mode interactif avec prévisualisation
        ----------------------+---------------+--------------------------------------------

        -------------------------------------------+-----------------------------------------
        Mode                                       | Commande                                       ~
        -------------------------------------------+-----------------------------------------
        interactif                                 | `:EasyAlign[!] [OPTIONS]`
        interactif avec prévisualisation           | `:LiveEasyAlign[!] […]`
        non-interactif (règles d'alignement)       | `:EasyAlign[!] [N-th] DELIMITER [OPTIONS]`
        non-interactif (regex)                     | `:EasyAlign[!] [N-th] /REGEX/ [OPTIONS]`
        -------------------------------------------+-----------------------------------------

NOTE:
Il est possible que par moment, l'aide de vim-easy-align explique qu'il faut appuyer sur Enter
en mode visuel alors qu'en réalité il faut appuyer sur `ga`.
En effet, l'aide suppose qu'on a installé le mapping suivant:

        xmap <Enter> <Plug>(EasyAlign)

Je ne l'ai pas installé, par souci de cohérence, `ga` en mode normal, `ga` en mode visuel.
De plus, Enter en mode visuel pourrait être utilisé pour autre chose…


Un alignement via un mapping se fait en 4 étapes:

        1. `ga` suivi d'un mouvement ou d'un text-object

        2. Optionnel: `Enter` pour alterner entre plusieurs modes d'alignement (gauche, droit, centre)

        3. Optionnel: N-ième délimiteur (défaut: 1)

                - `1` autour des 1e occurrences du délimiteur
                - `2` "          2e "
                - …
                - `*` autour de toutes les occurrences du délimiteur
                - `**` idem, mais en alternant de quel côté le texte situé entre 2 délimiteurs est aligné:

                        droite-gauche-droite-gauche …

                - `-` autour des dernières occurrences du délimiteur
                - `-2` "         avant-dernières "
                - …


        4. délimiteur (<Space>, `=`, `:`, `.`, `|`, `&`, `#`, `,`)


Règles d'alignement prédéfinies:

        -----------+-------------------------------------------------------------
        Délimiteur | Description / Exemples d'utilisation
        -----------+-------------------------------------------------------------
        <Space>    | alignement autour de whitespaces
                   |
        =          | "                 d'opérateurs d'affectation / test tq:
                   |
                   |         =
                   |         ==
                   |         !=
                   |         +=
                   |         &&=
                   |
        #          | utile pour aligner des commentaires shell / Python
        "          | "                                   Vim
                   |
        <Bar>      | "                                   tableau Markdown
        &          | tableaux LaTeX (match  `&`  and  `\\` )
                   |
        :          | utile pour formater du code JSON ou YAML
        .          | "          un chaînage de méthode multi-ligne (ex: foo.bar.baz.qux ???)
        ,          | "          des arguments d'une méthode multi-ligne
        -----------+-------------------------------------------------------------

On peut redéfinir ces règles d'alignement par défaut ou créer les nôtres via la variable `g:easy_align_delimiters`.


Exemples en mode visuel:

        ------------------+-------------------------------------------------+------------------------
        Touches           | Description                                     | Commande Ex équivalente
        ------------------+-------------------------------------------------+------------------------
        Enter Space       | autour des 1ers whitespaces                     | :*EasyAlign\
        Enter 2 Space     | "          2e   "                               | :*EasyAlign2\
        Enter - Space     | "          derniers "                           | :*EasyAlign-\
        Enter -2 Space    | "          avant-avant-derniers "               | :*EasyAlign-2\
        Enter :           | "          premiers double-points (`key:  value`) | :*EasyAlign:
        Enter Right :     | "                                 (`key : value`) | :*EasyAlign:<l1
        Enter   =         | "          premiers opérateurs incluant =       | :*EasyAlign=
        Enter  3=         | "          3èmes    "                           | :*EasyAlign3=
        Enter  *=         | "          tous     "                           | :*EasyAlign*=
        Enter **=         | Left-right alternating around =                 | :*EasyAlign**=
        Enter Enter =     | Right alignment around 1st =                    | :*EasyAlign!=
        Enter Enter **=   | Right-left alternating around =                 | :*EasyAlign!**=
        ------------------+-------------------------------------------------+------------------------


Using regular expressions~

Instead of finishing the command with a predefined delimiter key, you can type
in a regular expression after `C-x`. For example, if you want to align text around all occurrences of numbers:

        - Enter
        - `*`
        - C-x
            - `[0-9]\+`


Alignment options in interactive mode~

While in interactive mode, you can set alignment options using special
shortcut keys listed below.
The meaning of each option will be described in the following sections.

------+------------------+---------------------------------------------------
Key   | Option           | Values                                            ~
------+------------------+---------------------------------------------------
C-f   | `filter`           | Input string ( `[gv]/.*/?` )
C-i   | `indentation`      | shallow, deep, none, keep
C-l   | `left_margin`      | Input number or string
C-r   | `right_margin`     | Input number or string
C-d   | `delimiter_align`  | left, center, right
C-u   | `ignore_unmatched` | 0, 1
C-g   | `ignore_groups`    | [], ["String'], ["Comment'], ["String', "Comment']
C-a   | `align`            | Input string ( `/[lrc]+\*{0,2}/` )
Left  | `stick_to_left`    | `{ 'stick_to_left': 1, 'left_margin': 0 }`
Right | `stick_to_left`    | `{ 'stick_to_left': 0, 'left_margin': 1 }`
Down  | `*_margin`         | `{ 'left_margin': 0, 'right_margin': 0 }`
------+------------------+---------------------------------------------------


< Live interactive mode >_____________________________________________________~

If you're performing a complex alignment where multiple options should be
carefully adjusted, try "live interactive mode" where you can preview the
result of the alignment on-the-fly as you type in.

Live interactive mode can be started with either `<Plug>(LiveEasyAlign)` map or
`:LiveEasyAlign` command. Or you can switch to live interactive mode while in
ordinary interactive mode by pressing `C-p`. (P for Preview)

In live interactive mode, you have to type in the same delimiter (or `C-x` on
regular expression) again to finalize the alignment. This allows you to
preview the result of the alignment and freely change the delimiter using
backspace key without leaving the interactive mode.


< Non-interactive mode >______________________________________________________~

Instead of starting interactive mode, you can use declarative, non-interactive
`:EasyAlign` command.
>
    " Using predefined alignment rules
    "   :EasyAlign[!] [N-th] DELIMITER_KEY [OPTIONS]
    :EasyAlign :
    :EasyAlign =
    :EasyAlign *=
    :EasyAlign 3\

    " Using arbitrary regular expressions
    "   :EasyAlign[!] [N-th] /REGEXP/ [OPTIONS]
    :EasyAlign /[:;]\+/
    :EasyAlign 2/[:;]\+/
    :EasyAlign */[:;]\+/
    :EasyAlign **/[:;]\+/
<
A command can end with alignment options, in Vim dictionary format.

 - `:EasyAlign * /[:;]\+/ { 'stick_to_left': 1, 'left_margin': 0 }`

`stick_to_left` of 1 means that the matched delimiter should be positioned
right next to the preceding token, and `left_margin` of 0 removes the margin
on the left. So we get:
>
    apple;: banana::   cake
    data;;  exchange:; format
<
Option names are fuzzy-matched, so you can write as follows:

 - `:EasyAlign * /[:;]\+/ { 'stl': 1, 'l': 0 }`

You can even omit spaces between the arguments, so concisely (or cryptically):

 - `:EasyAlign*/[:;]\+/{'s':1,'l':0}`

Nice. But let's make it even shorter. Option values can be written in shorthand notation.

 - `:EasyAlign*/[:;]\+/<l0`

The following table summarizes the shorthand notation.

        -----------------+-----------
        Option           | Expression
        -----------------+-----------
        filter           | [gv]/.*/
        left_margin      | l[0-9]+
        right_margin     | r[0-9]+
        stick_to_left    | `<`  or  `>`
        ignore_unmatched | iu[01]
        ignore_groups    | ig\[.*\]
        align            | a[lrc*]*
        delimiter_align  | d[lrc]
        indentation      | i[ksdn]
        -----------------+-----------

For your information, the same operation can be done in interactive mode as follows:

        - Enter
        - `*`
        - Left
        - C-x
        - `[:;]\+`


< Partial alignment in blockwise-visual mode >________________________________~

In blockwise-visual mode (`C-v`), EasyAlign command aligns only the selected
text in the block, instead of the whole lines in the range.

Consider the following case where you want to align text around `=>`
operators.
>
    my_hash = { :a => 1,
                :aa => 2,
                :aaa => 3 }
<
In non-blockwise visual mode (`v` / `V`), `Enter =` won't work since the
assignment operator in the first line gets in the way. So we instead enter
blockwise-visual mode (`C-v`), and select the text around`=>` operators, then press `Enter =`
>
    my_hash = { :a   => 1,
                :aa  => 2,
                :aaa => 3 }
<
However, in this case, we don't really need blockwise visual mode since the
same can be easily done using the negative N-th parameter: `Enter -=`

==============================================================================
List of options

-------------------+---------+-----------------------+--------------------------------------------------------
Option             | Type    | Default               | Description                                            ~
-------------------+---------+-----------------------+--------------------------------------------------------
 `filter`            | string  |                       | Line filtering expression:  `g/../`  or  `v/../`
 `left_margin`       | number  | 1                     | Number of spaces to attach before delimiter
 `left_margin`       | string  |  `' '`                  | String to attach before delimiter
 `right_margin`      | number  | 1                     | Number of spaces to attach after delimiter
 `right_margin`      | string  |  `' '`                  | String to attach after delimiter
 `stick_to_left`     | boolean | 0                     | Whether to position delimiter on the left-side
 `ignore_groups`     | list    | ["String', "Comment'] | Delimiters in these syntax highlight groups are ignored
 `ignore_unmatched`  | boolean | 1                     | Whether to ignore lines without matching delimiter
 `indentation`       | string  |  `k`                    | Indentation method (keep, deep, shallow, none)
 `delimiter_align`   | string  |  `r`                    | Determines how to align delimiters of different lengths
 `align`             | string  |  `l`                    | Alignment modes for multiple occurrences of delimiters
-------------------+---------+-----------------------+--------------------------------------------------------

There are 4 ways to set alignment options (from lowest precedence to highest):

        1. Some option values can be set with corresponding global variables
        2. Option values can be specified in the definition of each alignment rule
        3. Option values can be given as arguments to `:EasyAlign` command
        4. Option values can be set in interactive mode using special shortcut keys

------------------+--------------+-------------+------------------------------
Option name       | Shortcut key | Abbreviated | Global variable                ~
------------------+--------------+-------------+------------------------------
 `filter`           | C-f          | `[gv]/.*/`    |
 `left_margin`      | C-l          | `l[0-9]+`     |
 `right_margin`     | C-r          | `r[0-9]+`     |
 `stick_to_left`    | Left, Right  | `<`  or  `>`    |
 `ignore_groups`    | C-g          | `ig\[.*\]`    | `g:easy_align_ignore_groups`
 `ignore_unmatched` | C-u          | `iu[01]`      | `g:easy_align_ignore_unmatched`
 `indentation`      | C-i          | `i[ksdn]`     | `g:easy_align_indentation`
 `delimiter_align`  | C-d          | `d[lrc]`      | `g:easy_align_delimiter_align`
 `align`            | C-a          | `a[lrc*]*`    |
------------------+--------------+-------------+------------------------------


< Filtering lines >___________________________________________________________~

With `filter` option, you can align lines that only match or do not match a
given pattern. There are several ways to set the pattern.

        1. Press `C-f` in interactive mode and type in `g/pat/` or `v/pat/`
        2. In command-line, it can be written in dictionary format: `{'filter': 'g/pat/'}`
        3. Or in shorthand notation: `g/pat/` or `v/pat/`

(You don't need to escape "/'s in the regular expression)


Examples~
>
    " Start interactive mode with filter option set to g/hello/
    EasyAlign g/hello/

    " Start live interactive mode with filter option set to v/goodbye/
    LiveEasyAlign v/goodbye/

    " Align the lines with 'hi' around the first colons
    EasyAlign:g/hi/
<

< Ignoring delimiters in comments or strings >________________________________~

EasyAlign can be configured to ignore delimiters in certain syntax highlight
groups, such as code comments or strings. By default, delimiters that are
highlighted as code comments or strings are ignored.
>
    " Default:
    "   If a delimiter is in a highlight group whose name matches
    "   any of the followings, it will be ignored.
    let g:easy_align_ignore_groups = ['Comment', 'String']
<
For example, the following paragraph
>
    {
      # Quantity of apples: 1
      apple: 1,
      # Quantity of bananas: 2
      bananas: 2,
      # Quantity of grape:fruits: 3
      'grape:fruits': 3
    }
<
becomes as follows on `Enter`: (or `:EasyAlign:`)
>
    {
      # Quantity of apples: 1
      apple:          1,
      # Quantity of bananas: 2
      bananas:        2,
      # Quantity of grape:fruits: 3
      'grape:fruits': 3
    }
<
Naturally, this feature only works when syntax highlighting is enabled.

You can change the default rule by using one of these 4 methods.

        1. Press C-g in interactive mode to switch groups
        2. Define global `g:easy_align_ignore_groups` list
        3. Define a custom rule in `g:easy_align_delimiters` with `ignore_groups` option
        4. Provide `ignore_groups` option to `:EasyAlign` command. e.g. `:EasyAlign:ig[]`

For example if you set `ignore_groups` option to be an empty list, you get
>
    {
      # Quantity of apples:  1
      apple:                 1,
      # Quantity of bananas: 2
      bananas:               2,
      # Quantity of grape:   fruits: 3
      'grape:                fruits': 3
    }
<
If a pattern in `ignore_groups` is prepended by a `!`, it will have the
opposite meaning. For instance, if `ignore_groups` is given as `['!Comment']`,
delimiters that are not highlighted as Comment will be ignored during the
alignment.


< Ignoring unmatched lines >__________________________________________________~

`ignore_unmatched` option determines how EasyAlign command processes lines
that do not have N-th delimiter.

        1. In left-alignment mode, they are ignored

        2. In right or center-alignment mode, they are not ignored, and the last tokens
           from those lines are aligned as well as if there is an invisible trailing
           delimiter at the end of each line

        3. If `ignore_unmatched` is 1, they are ignored regardless of the alignment mode

        4. If `ignore_unmatched` is 0, they are not ignored regardless of the mode

Let's take an example. When we align the following code block around the (1st)
colons,
>
    {
      apple: proc {
        this_line_does_not_have_a_colon
      },
      bananas: 2,
      grapefruits: 3
    }
<
this is usually what we want.
>
    {
      apple:       proc {
        this_line_does_not_have_a_colon
      },
      bananas:     2,
      grapefruits: 3
    }
<
However, we can override this default behavior by setting `ignore_unmatched`
option to zero using one of the following methods.

        1. Press `C-u` in interactive mode to toggle `ignore_unmatched` option
        2. Set the global `g:easy_align_ignore_unmatched` variable to 0
        3. Define a custom alignment rule with `ignore_unmatched` option set to 0
        4. Provide `ignore_unmatched` option to `:EasyAlign` command. e.g. `:EasyAlign:iu0`

Then we get,
>
    {
      apple:                             proc {
        this_line_does_not_have_a_colon
      },
      bananas:                           2,
      grapefruits:                       3
    }
<

< Aligning delimiters of different lengths >__________________________________~

Global `g:easy_align_delimiter_align` option and rule-wise/command-wise
`delimiter_align` option determines how matched delimiters of different lengths are aligned.
>
    apple = 1
    banana += apple
    cake ||= banana
<
By default, delimiters are right-aligned as follows.
>
    apple    = 1
    banana  += apple
    cake   ||= banana
<
However, with `:EasyAlign=dl`, delimiters are left-aligned.
>
    apple  =   1
    banana +=  apple
    cake   ||= banana
<
And on `:EasyAlign=dc`, center-aligned.
>
    apple   =  1
    banana +=  apple
    cake   ||= banana
<
In interactive mode, you can change the option value with `C-d`.


< Adjusting indentation >_____________________________________________________~

By default :EasyAlign command keeps the original indentation of the lines. But
then again we have `indentation` option. See the following example.
>
    # Lines with different indentation
      apple = 1
        banana = 2
          cake = 3
            daisy = 4
         eggplant = 5

    # Default: _k_eep the original indentation
    #   :EasyAlign=
      apple       = 1
        banana    = 2
          cake    = 3
            daisy = 4
         eggplant = 5

    # Use the _s_hallowest indentation among the lines
    #   :EasyAlign=is
      apple    = 1
      banana   = 2
      cake     = 3
      daisy    = 4
      eggplant = 5

    # Use the _d_eepest indentation among the lines
    #   :EasyAlign=id
            apple    = 1
            banana   = 2
            cake     = 3
            daisy    = 4
            eggplant = 5

    # Indentation: _n_one
    #   :EasyAlign=in
    apple    = 1
    banana   = 2
    cake     = 3
    daisy    = 4
    eggplant = 5
<
In interactive mode, you can change the option value with `C-i`.


< Alignments over multiple occurrences of delimiters >________________________~

As stated above, 'N-th' parameter is used to target specific occurrences of
the delimiter when it appears multiple times in each line.

To recap:
>
    " Left-alignment around the FIRST occurrences of delimiters
    :EasyAlign =

    " Left-alignment around the SECOND occurrences of delimiters
    :EasyAlign 2=

    " Left-alignment around the LAST occurrences of delimiters
    :EasyAlign -=

    " Left-alignment around ALL occurrences of delimiters
    :EasyAlign *=

    " Left-right ALTERNATING alignment around all occurrences of delimiters
    :EasyAlign **=

    " Right-left ALTERNATING alignment around all occurrences of delimiters
    :EasyAlign! **=
<
In addition to these, you can fine-tune alignments over multiple occurrences
of the delimiters with "align' option.
The option can also be set in interactive mode with `C-a`.
>
    " Left alignment over the first two occurrences of delimiters
    :EasyAlign = { 'align': 'll' }

    " Right, left, center alignment over the 1st to 3rd occurrences of delimiters
    :EasyAlign = { 'a': 'rlc' }

    " Using shorthand notation
    :EasyAlign = arlc

    " Right, left, center alignment over the 2nd to 4th occurrences of delimiters
    :EasyAlign 2=arlc

    " (*) Repeating alignments (default: l, r, or c)
    "   Right, left, center, center, center, center, ...
    :EasyAlign *=arlc

    " (**) Alternating alignments (default: lr or rl)
    "   Right, left, center, right, left, center, ...
    :EasyAlign **=arlc

    " Right, left, center, center, center, ... repeating alignment
    " over the 3rd to the last occurrences of delimiters
    :EasyAlign 3=arlc*

    " Right, left, center, right, left, center, ... alternating alignment
    " over the 3rd to the last occurrences of delimiters
    :EasyAlign 3=arlc**
<

< Extending alignment rules >_________________________________________________~

Although the default rules should cover the most of the use cases, you can
extend the rules by setting a dictionary named `g:easy_align_delimiters`.

You may refer to the definitions of the default alignment rules {here}{7}.

{7} https://github.com/junegunn/vim-easy-align/blob/2.9.6/autoload/easy_align.vim#L32-L46


Examples~
>
    let g:easy_align_delimiters = {
    \ '>': { 'pattern': '>>\|=>\|>' },
    \ '/': {
    \     'pattern':         '//\+\|/\*\|\*/',
    \     'delimiter_align': 'l',
    \     'ignore_groups':   ['!Comment'] },
    \ ']': {
    \     'pattern':       '[[\]]',
    \     'left_margin':   0,
    \     'right_margin':  0,
    \     'stick_to_left': 0
    \   },
    \ ')': {
    \     'pattern':       '[()]',
    \     'left_margin':   0,
    \     'right_margin':  0,
    \     'stick_to_left': 0
    \   },
    \ 'd': {
    \     'pattern':      ' \(\S\+\s*[;=]\)\@=',
    \     'left_margin':  0,
    \     'right_margin': 0
    \   }
    \ }
<
==============================================================================
OTHER OPTIONS

< Disabling &foldmethod during alignment >____________________________________~

{It is reported}{8} that 'foldmethod' value of `expr` or `syntax` can
significantly slow down the alignment when editing a large, complex file with
many folds. To alleviate this issue, EasyAlign provides an option to
temporarily set 'foldmethod' to `manual` during the alignment task. In order
to enable this feature, set `g:easy_align_bypass_fold` switch to 1.
>
    let g:easy_align_bypass_fold = 1
<
                      {8} https://github.com/junegunn/vim-easy-align/issues/14


< Left/right/center mode switch in interactive mode >_________________________~

In interactive mode, you can choose the alignment mode you want by pressing
enter keys. The non-bang command, `:EasyAlign` starts in left-alignment mode
and changes to right and center mode as you press enter keys, while the bang
version first starts in right-alignment mode.

        - `:EasyAlign`
            - Left, Right, Center
        - `:EasyAlign!`
            - Right, Left, Center

If you do not prefer this default mode transition, you can define your own
settings as follows.
>
    let g:easy_align_interactive_modes = ['l', 'r']
    let g:easy_align_bang_interactive_modes = ['c', 'r']
<
==============================================================================
------------------------------------------------------------------------------
==============================================================================
5   Éléments imbriqués

Lire et documenter `:h syn-containedin`.
On s'en est servi dans:

        ~/.vim/after/syntax/vim.vim

... pour masquer les caractères de masquage.
Parler aussi du nom de groupe syntaxique spécial `ALL` (`:h syn-contains`).



Take a look at this comment:

    %Get input  TODO: Skip white space ~

You want to highlight TODO in big yellow letters, even though it is in a
comment that is highlighted blue.  To let Vim know about this, you define the
following syntax groups: >

    syn keyword xTodo     TODO   contained
    syn match   xComment  /%.*/  contains=xTodo

In the first line, the "contained" argument tells Vim that this keyword can
exist only inside another syntax item.  The next line has "contains=xTodo".
This indicates that the xTodo syntax element is inside it.  The result is that
the comment line as a whole is matched with "xComment" and made blue.  The
word TODO inside it is matched by xTodo and highlighted yellow (highlighting
for xTodo was setup for this).


RECURSIVE NESTING

The x language defines code blocks in curly braces.  And a code block may
contain other code blocks.  This can be defined this way: >

    syn region xBlock start=/{/ end=/}/ contains=xBlock

Suppose you have this text:

    while i < b { ~
        if a { ~
            b = c; ~
        } ~
    } ~

First a xBlock starts at the { in the first line.  In the second line another
{ is found.  Since we are inside a xBlock item, and it contains itself, a
nested xBlock item will start here.  Thus the "b = c" line is inside the
second level xBlock region.  Then a } is found in the next line, which matches
with the end pattern of the region.  This ends the nested xBlock.  Because the
} is included in the nested region, it is hidden from the first xBlock region.
Then at the last } the first xBlock region ends.


KEEPING THE END

Consider the following two syntax items: >

    syn region xComment start=/%/ end=/$/ contained
    syn region xPreProc start=/#/ end=/$/ contains=xComment

You define a comment as anything from % to the end of the line.  A
preprocessor directive is anything from # to the end of the line.  Because you
can have a comment on a preprocessor line, the preprocessor definition
includes a "contains=xComment" argument.  Now look what happens with this
text:

    #define X = Y  % Comment text ~
    int foo = 1; ~

What you see is that the second line is also highlighted as xPreProc.  The
preprocessor directive should end at the end of the line.  That is why
you have used "end=/$/".  So what is going wrong?
   The problem is the contained comment.  The comment starts with % and ends
at the end of the line.  After the comment ends, the preprocessor syntax
continues.  This is after the end of the line has been seen, so the next
line is included as well.
   To avoid this problem and to avoid a contained syntax item eating a needed
end of line, use the "keepend" argument.  This takes care of
the double end-of-line matching: >

    syn region xComment start=/%/ end=/$/ contained
    syn region xPreProc start=/#/ end=/$/ contains=xComment keepend


CONTAINING MANY ITEMS

You can use the contains argument to specify that everything can be contained.
For example: >

    syn region xList start=/\[/ end=/\]/ contains=ALL

All syntax items will be contained in this one.  It also contains itself, but
not at the same position (that would cause an endless loop).
   You can specify that some groups are not contained.  Thus contain all
groups but the ones that are listed:
>
    syn region xList start=/\[/ end=/\]/ contains=ALLBUT,xString

With the "TOP" item you can include all items that don't have a "contained"
argument.  "CONTAINED" is used to only include items with a "contained"
argument.  See |:syn-contains| for the details.

==============================================================================
6   Following groups

The x language has statements in this form:

    if (condition) then ~

You want to highlight the three items differently.  But "(condition)" and
"then" might also appear in other places, where they get different
highlighting.  This is how you can do this: >

    syn match xIf           /if/       nextgroup=xIfCondition     skipwhite
    syn match xIfCondition  /([^)]*)/  contained nextgroup=xThen  skipwhite
    syn match xThen         /then/     contained

The "nextgroup" argument specifies which item can come next.  This is not
required.  If none of the items that are specified are found, nothing happens.
For example, in this text:

    if not (condition) then ~

The "if" is matched by xIf.  "not" doesn't match the specified nextgroup
xIfCondition, thus only the "if" is highlighted.

The "skipwhite" argument tells Vim that white space (spaces and tabs) may
appear in between the items.  Similar arguments are "skipnl", which allows a
line break in between the items, and "skipempty", which allows empty lines.
Notice that "skipnl" doesn't skip an empty line, something must match after
the line break.

==============================================================================
7   Autres arguments

MATCHGROUP

When you define a region, the entire region is highlighted according to the
group name specified.  To highlight the text enclosed in parentheses () with
the group xInside, for example, use the following command: >

    syn region xInside start=/(/ end=/)/

Suppose, that you want to highlight the parentheses differently.  You can do
this with a lot of convoluted region statements, or you can use the
"matchgroup" argument.  This tells Vim to highlight the start and end of a
region with a different highlight group (in this case, the xParen group): >

    syn region xInside matchgroup=xParen start=/(/ end=/)/

The "matchgroup" argument applies to the start or end match that comes after
it.  In the previous example both start and end are highlighted with xParen.
To highlight the end with xParenEnd: >

    syn region xInside matchgroup=xParen start=/(/
        \ matchgroup=xParenEnd end=/)/

A side effect of using "matchgroup" is that contained items will not match in
the start or end of the region.  The example for "transparent" uses this.


TRANSPARENT

In a C language file you would like to highlight the () text after a "while"
differently from the () text after a "for".  In both of these there can be
nested () items, which should be highlighted in the same way.  You must make
sure the () highlighting stops at the matching ).  This is one way to do this:
>
    syn region cWhile matchgroup=cWhile start=/while\s*(/ end=/)/
        \ contains=cCondNest
    syn region cFor matchgroup=cFor start=/for\s*(/ end=/)/
        \ contains=cCondNest
    syn region cCondNest start=/(/ end=/)/ contained transparent

Now you can give cWhile and cFor different highlighting.  The cCondNest item
can appear in either of them, but take over the highlighting of the item it is
contained in.  The "transparent" argument causes this.
   Notice that the "matchgroup" argument has the same group as the item
itself.  Why define it then?  Well, the side effect of using a matchgroup is
that contained items are not found in the match with the start item then.
This avoids that the cCondNest group matches the ( just after the "while" or
"for".  If this would happen, it would span the whole text until the matching
) and the region would continue after it.  Now cCondNest only matches after
the match with the start pattern, thus after the first (.


OFFSETS

Suppose you want to define a region for the text between ( and ) after an
"if".  But you don't want to include the "if" or the ( and ).  You can do this
by specifying offsets for the patterns.  Example: >

    syn region xCond start=/if\s*(/ms=e+1 end=/)/me=s-1

The offset for the start pattern is "ms=e+1".  "ms" stands for Match Start.
This defines an offset for the start of the match.  Normally the match starts
where the pattern matches.  "e+1" means that the match now starts at the end
of the pattern match, and then one character further.
   The offset for the end pattern is "me=s-1".  "me" stands for Match End.
"s-1" means the start of the pattern match and then one character back.  The
result is that in this text:

    if (foo == bar) ~

Only the text "foo == bar" will be highlighted as xCond.

More about offsets here: |:syn-pattern-offset|.


ONELINE

The "oneline" argument indicates that the region does not cross a line
boundary.  For example: >

    syn region xIfThen start=/if/ end=/then/ oneline

This defines a region that starts at "if" and ends at "then".  But if there is
no "then" after the "if", the region doesn't match.

    Note:
    When using "oneline" the region doesn't start if the end pattern
    doesn't match in the same line.  Without "oneline" Vim does _not_
    check if there is a match for the end pattern.  The region starts even
    when the end pattern doesn't match in the rest of the file.


CONTINUATION LINES AND AVOIDING THEM

Things now become a little more complex.  Let's define a preprocessor line.
This starts with a # in the first column and continues until the end of the
line.  A line that ends with \ makes the next line a continuation line.  The
way you handle this is to allow the syntax item to contain a continuation
pattern: >

    syn region xPreProc      start=/^#/ end=/$/ contains=xLineContinue
    syn match  xLineContinue "\\$"              contained

In this case, although xPreProc normally matches a single line, the group
contained in it (namely xLineContinue) lets it go on for more than one line.
For example, it would match both of these lines:

    #define SPAM  spam spam spam \ ~
            bacon and spam ~

In this case, this is what you want.  If it is not what you want, you can call
for the region to be on a single line by adding "excludenl" to the contained
pattern.  For example, you want to highlight "end" in xPreProc, but only at
the end of the line.  To avoid making the xPreProc continue on the next line,
like xLineContinue does, use "excludenl" like this: >

    syn region xPreProc start=/^#/ end=/$/
        \ contains=xLineContinue,xPreProcEnd
    syn match xPreProcEnd excludenl  /end$/  contained
    syn match xLineContinue          "\\$"   contained

"excludenl" must be placed before the pattern.  Since "xLineContinue" doesn't
have "excludenl", a match with it will extend xPreProc to the next line as
before.

==============================================================================
8   Clusters

One of the things you will notice as you start to write a syntax file is that
you wind up generating a lot of syntax groups.  Vim enables you to define a
collection of syntax groups called a cluster.
   Suppose you have a language that contains for loops, if statements, while
loops, and functions.  Each of them contains the same syntax elements: numbers
and identifiers.  You define them like this: >

    syn match xFor    /^for.*/    contains=xNumber,xIdent
    syn match xIf     /^if.*/     contains=xNumber,xIdent
    syn match xWhile  /^while.*/  contains=xNumber,xIdent

You have to repeat the same "contains=" every time.  If you want to add
another contained item, you have to add it three times.  Syntax clusters
simplify these definitions by enabling you to have one cluster stand for
several syntax groups.
   To define a cluster for the two items that the three groups contain, use
the following command: >

    syn cluster xState contains=xNumber,xIdent

Clusters are used inside other syntax items just like any syntax group.
Their names start with @.  Thus, you can define the three groups like this: >

    syn match xFor    /^for.*/    contains=@xState
    syn match xIf     /^if.*/     contains=@xState
    syn match xWhile  /^while.*/  contains=@xState

You can add new group names to this cluster with the "add" argument: >

    syn cluster xState add=xString

You can remove syntax groups from this list as well: >

    syn cluster xState remove=xNumber

==============================================================================
9   Inclure un autre fichier de syntaxe

The C++ language syntax is a superset of the C language.  Because you do not
want to write two syntax files, you can have the C++ syntax file read in the
one for C by using the following command: >

    runtime! syntax/c.vim

(NOTE: ça marche aussi pour un ftplugin:    `runtime! ftplugin/c.vim`)

The ":runtime!" command searches 'runtimepath' for all "syntax/c.vim" files.
This makes the C parts of the C++ syntax be defined like for C files.  If you
have replaced the c.vim syntax file, or added items with an extra file, these
will be loaded as well.
   After loading the C syntax items the specific C++ items can be defined.
For example, add keywords that are not used in C: >

    syn keyword cppStatement    new delete this friend using

This works just like in any other syntax file.

Now consider the Perl language.  A Perl script consists of two distinct parts:
a documentation section in POD format, and a program written in Perl itself.
The POD section starts with "=head" and ends with "=cut".
   You want to define the POD syntax in one file, and use it from the Perl
syntax file.  The ":syntax include" command reads in a syntax file and stores
the elements it defined in a syntax cluster.  For Perl, the statements are as
follows: >

    syn include @Pod <sfile>:p:h/pod.vim
    syn region perlPOD start=/^=head/ end=/^=cut/ contains=@Pod

When "=head" is found in a Perl file, the perlPOD region starts.  In this
region the @Pod cluster is contained.  All the items defined as top-level
items in the pod.vim syntax files will match here.  When "=cut" is found, the
region ends and we go back to the items defined in the Perl file.
   The ":syntax include" command is clever enough to ignore a ":syntax clear"
command in the included file.  And an argument such as "contains=ALL" will
only contain items defined in the included file, not in the file that includes
it.
   The "<sfile>:p:h/" part uses the name of the current file (<sfile>),
expands it to a full path (:p) and then takes the head (:h).  This results in
the directory name of the file.  This causes the pod.vim file in the same
directory to be included.

==============================================================================
10  Synchroniser

Compilers have it easy.  They start at the beginning of a file and parse it
straight through.  Vim does not have it so easy.  It must start in the middle,
where the editing is being done.  So how does it tell where it is?
   The secret is the ":syntax sync" command.  This tells Vim how to figure out
where it is.  For example, the following command tells Vim to scan backward
for the beginning or end of a C-style comment and begin syntax coloring from
there: >

    syn sync ccomment

You can tune this processing with some arguments.  The "minlines" argument
tells Vim the minimum number of lines to look backward, and "maxlines" tells
the editor the maximum number of lines to scan.
   For example, the following command tells Vim to look at least 10 lines
before the top of the screen: >

    syn sync ccomment minlines=10 maxlines=500

If it cannot figure out where it is in that space, it starts looking farther
and farther back until it figures out what to do.  But it looks no farther
back than 500 lines.  (A large "maxlines" slows down processing.  A small one
might cause synchronization to fail.)
   To make synchronizing go a bit faster, tell Vim which syntax items can be
skipped.  Every match and region that only needs to be used when actually
displaying text can be given the "display" argument.
   By default, the comment to be found will be colored as part of the Comment
syntax group.  If you want to color things another way, you can specify a
different syntax group: >

    syn sync ccomment xAltComment

If your programming language does not have C-style comments in it, you can try
another method of synchronization.  The simplest way is to tell Vim to space
back a number of lines and try to figure out things from there.  The following
command tells Vim to go back 150 lines and start parsing from there: >

    syn sync minlines=150

A large "minlines" value can make Vim slower, especially when scrolling
backwards in the file.
   Finally, you can specify a syntax group to look for by using this command:
>
    syn sync match {sync-group-name}
        \ grouphere {group-name} {pattern}

This tells Vim that when it sees {pattern} the syntax group named {group-name}
begins just after the pattern given.  The {sync-group-name} is used to give a
name to this synchronization specification.  For example, the sh scripting
language begins an if statement with "if" and ends it with "fi":

    if [ --f file.txt ] ; then ~
        echo "File exists" ~
    fi ~

To define a "grouphere" directive for this syntax, you use the following
command: >

    syn sync match shIfSync grouphere shIf "\<if\>"

The "groupthere" argument tells Vim that the pattern ends a group.  For
example, the end of the if/fi group is as follows: >

    syn sync match shIfSync groupthere NONE "\<fi\>"

In this example, the NONE tells Vim that you are not in any special syntax
region.  In particular, you are not inside an if block.

You also can define matches and regions that are with no "grouphere" or
"groupthere" arguments.  These groups are for syntax groups skipped during
synchronization.  For example, the following skips over anything inside {},
even if it would normally match another synchronization method: >

    syn sync match xSpecial /{.*}/

More about synchronizing in the reference manual: |:syn-sync|.

==============================================================================
Plugins for a filetype

How to start using filetype plugins has already been discussed here:
|add-filetype-plugin|.  But you probably are not satisfied with the default
settings, because they have been kept minimal.  Suppose that for C files you
want to set the 'softtabstop' option to 4 and define a mapping to insert a
three-line comment.  You do this with only two steps:

                            *your-runtime-dir*
1. Create your own runtime directory.  On Unix this usually is "~/.vim".  In
   this directory create the "ftplugin" directory: >

    mkdir ~/.vim
    mkdir ~/.vim/ftplugin
<
   When you are not on Unix, check the value of the 'runtimepath' option to
   see where Vim will look for the "ftplugin" directory: >

    set runtimepath

<  You would normally use the first directory name (before the first comma).
   You might want to prepend a directory name to the 'runtimepath' option in
   your |vimrc| file if you don't like the default value.

2. Create the file "~/.vim/ftplugin/c.vim", with the contents: >

    setlocal softtabstop=4
    noremap <buffer> <LocalLeader>c o/**************<CR><CR>/<Esc>
    let b:undo_ftplugin = "setl softtabstop< | unmap <buffer> <LocalLeader>c"

Try editing a C file.  You should notice that the 'softtabstop' option is set
to 4.  But when you edit another file it's reset to the default zero.  That is
because the ":setlocal" command was used.  This sets the 'softtabstop' option
only locally to the buffer.  As soon as you edit another buffer, it will be
set to the value set for that buffer.  For a new buffer it will get the
default value or the value from the last ":set" command.

Likewise, the mapping for "\c" will disappear when editing another buffer.
The ":map <buffer>" command creates a mapping that is local to the current
buffer.  This works with any mapping command: ":map!", ":vmap", etc.  The
|<LocalLeader>| in the mapping is replaced with the value of the
"maplocalleader" variable.

The line to set b:undo_ftplugin is for when the filetype is set to another
value.  In that case you will want to undo your preferences.  The
b:undo_ftplugin variable is executed as a command. Watch out for characters
with a special meaning inside a string, such as a backslash.

You can find examples for filetype plugins in this directory: >

    $VIMRUNTIME/ftplugin/

More details about writing a filetype plugin can be found here:
|write-plugin|.

==============================================================================
Adding a filetype

If you are using a type of file that is not recognized by Vim, this is how to
get it recognized.  You need a runtime directory of your own.  See
|your-runtime-dir| above.

Create a file "filetype.vim" which contains an autocommand for your filetype.
(Autocommands were explained in section |40.3|.)  Example: >

    augroup filetypedetect
    au BufNewFile,BufRead *.xyz setf xyz
    augroup END

This will recognize all files that end in ".xyz" as the "xyz" filetype.  The
":augroup" commands put this autocommand in the "filetypedetect" group.  This
allows removing all autocommands for filetype detection when doing ":filetype
off".  The "setf" command will set the 'filetype' option to its argument,
unless it was set already.  This will make sure that 'filetype' isn't set
twice.

You can use many different patterns to match the name of your file.  Directory
names can also be included.  See |autocmd-patterns|.  For example, the files
under "/usr/share/scripts/" are all "ruby" files, but don't have the expected
file name extension.  Adding this to the example above: >

    augroup filetypedetect
    au BufNewFile,BufRead *.xyz         setf xyz
    au BufNewFile,BufRead /usr/share/scripts/*  setf ruby
    augroup END

However, if you now edit a file /usr/share/scripts/README.txt, this is not a
ruby file.  The danger of a pattern ending in "*" is that it quickly matches
too many files.  To avoid trouble with this, put the filetype.vim file in
another directory, one that is at the end of 'runtimepath'.  For Unix for
example, you could use "~/.vim/after/filetype.vim".
   You now put the detection of text files in ~/.vim/filetype.vim: >

    augroup filetypedetect
    au BufNewFile,BufRead *.txt         setf text
    augroup END

That file is found in 'runtimepath' first.  Then use this in
~/.vim/after/filetype.vim, which is found last: >

    augroup filetypedetect
    au BufNewFile,BufRead /usr/share/scripts/*  setf ruby
    augroup END

What will happen now is that Vim searches for "filetype.vim" files in each
directory in 'runtimepath'.  First ~/.vim/filetype.vim is found.  The
autocommand to catch *.txt files is defined there.  Then Vim finds the
filetype.vim file in $VIMRUNTIME, which is halfway 'runtimepath'.  Finally
~/.vim/after/filetype.vim is found and the autocommand for detecting ruby
files in /usr/share/scripts is added.
   When you now edit /usr/share/scripts/README.txt, the autocommands are
checked in the order in which they were defined.  The *.txt pattern matches,
thus "setf text" is executed to set the filetype to "text".  The pattern for
ruby matches too, and the "setf ruby" is executed.  But since 'filetype' was
already set to "text", nothing happens here.
   When you edit the file /usr/share/scripts/foobar the same autocommands are
checked.  Only the one for ruby matches and "setf ruby" sets 'filetype' to
ruby.


RECOGNIZING BY CONTENTS

If your file cannot be recognized by its file name, you might be able to
recognize it by its contents.  For example, many script files start with a
line like:

    #!/bin/xyz ~

To recognize this script create a file "scripts.vim" in your runtime directory
(same place where filetype.vim goes).  It might look like this: >

    if did_filetype()
      finish
    endif
    if getline(1) =~ '^#!.*[/\\]xyz\>'
      setf xyz
    endif

The first check with did_filetype() is to avoid that you will check the
contents of files for which the filetype was already detected by the file
name.  That avoids wasting time on checking the file when the "setf" command
won't do anything.
   The scripts.vim file is sourced by an autocommand in the default
filetype.vim file.  Therefore, the order of checks is:

    1. filetype.vim files before $VIMRUNTIME in 'runtimepath'
    2. first part of $VIMRUNTIME/filetype.vim
    3. all scripts.vim files in 'runtimepath'
    4. remainder of $VIMRUNTIME/filetype.vim
    5. filetype.vim files after $VIMRUNTIME in 'runtimepath'

If this is not sufficient for you, add an autocommand that matches all files
and sources a script or executes a function to check the contents of the file.

==============================================================================
11  Installer un fichier de syntaxe

When your new syntax file is ready to be used, drop it in a "syntax" directory
in 'runtimepath'.  For Unix that would be "~/.vim/syntax".
  The name of the syntax file must be equal to the file type, with ".vim"
added.  Thus for the x language, the full path of the file would be:

    ~/.vim/syntax/x.vim ~

You must also make the file type be recognized.  See |43.2|.

If your file works well, you might want to make it available to other Vim
users.  First read the next section to make sure your file works well for
others.  Then e-mail it to the Vim maintainer: <maintainer@vim.org>.  Also
explain how the filetype can be detected.  With a bit of luck your file will
be included in the next Vim version!


ADDING TO AN EXISTING SYNTAX FILE

We were assuming you were adding a completely new syntax file.  When an existing
syntax file works, but is missing some items, you can add items in a separate
file.  That avoids changing the distributed syntax file, which will be lost
when installing a new version of Vim.
   Write syntax commands in your file, possibly using group names from the
existing syntax.  For example, to add new variable types to the C syntax file:
>
    syn keyword cType off_t uint

Write the file with the same name as the original syntax file.  In this case
"c.vim".  Place it in a directory near the end of 'runtimepath'.  This makes
it loaded after the original syntax file.  For Unix this would be:

    ~/.vim/after/syntax/c.vim ~

==============================================================================
12  Architecture d'un fichier de syntaxe portable

Wouldn't it be nice if all Vim users exchange syntax files?  To make this
possible, the syntax file must follow a few guidelines.

Start with a header that explains what the syntax file is for, who maintains
it and when it was last updated.  Don't include too much information about
changes history, not many people will read it.  Example: >

    " Vim syntax file
    " Language: C
    " Maintainer:   Bram Moolenaar <Bram@vim.org>
    " Last Change:  2001 Jun 18
    " Remark:   Included by the C++ syntax.

Use the same layout as the other syntax files.  Using an existing syntax file
as an example will save you a lot of time.

Choose a good, descriptive name for your syntax file.  Use lowercase letters
and digits.  Don't make it too long, it is used in many places: The name of
the syntax file "name.vim", 'filetype', b:current_syntax and the start of each
syntax group (nameType, nameStatement, nameString, etc).

Start with a check for "b:current_syntax".  If it is defined, some other
syntax file, earlier in 'runtimepath' was already loaded: >

    if exists('b:current_syntax')
        finish
    endif

To be compatible with Vim 5.8 use: >

    if version < 600
        syntax clear
    elseif exists("b:current_syntax")
        finish
    endif

Set "b:current_syntax" to the name of the syntax at the end.  Don't forget
that included files do this too, you might have to reset "b:current_syntax" if
you include two files.

If you want your syntax file to work with Vim 5.x, add a check for v:version.
See yacc.vim for an example.

Do not include anything that is a user preference.  Don't set 'tabstop',
'expandtab', etc.  These belong in a filetype plugin.

Do not include mappings or abbreviations.  Only include setting 'iskeyword' if
it is really necessary for recognizing keywords.

To allow users select their own preferred colors, make a different group name
for every kind of highlighted item.  Then link each of them to one of the
standard highlight groups.  That will make it work with every color scheme.
If you select specific colors it will look bad with some color schemes.  And
don't forget that some people use a different background color, or have only
eight colors available.

For the linking use "hi def link", so that the user can select different
highlighting before your syntax file is loaded.  Example: >

      hi def link nameString    String
      hi def link nameNumber    Number
      hi def link nameCommand   Statement
      ... etc ...

Add the "display" argument to items that are not used when syncing, to speed
up scrolling backwards and `C-l`.

==============================================================================
 Sh: EMBEDDING LANGUAGES~

Lire ce passage (tiré de `:h sh-awk`), pour apprendre à colorier du code shell, python, …
différemment dans nos notes markdown.


You may wish to embed languages into sh.  I'll give an example courtesy of
Lorance Stinson on how to do this with awk as an example. Put the following
file into $HOME/.vim/after/syntax/sh/awkembed.vim: >

    " AWK Embedding:
    "
    " Shamelessly ripped from aspperl.vim by Aaron Hope.
    if exists("b:current_syntax")
      unlet b:current_syntax
    endif
    syn include @AWKScript syntax/awk.vim
    syn region AWKScriptCode matchgroup=AWKCommand start=+[=\\]\@<!'+ skip=+\\'+ end=+'+ contains=@AWKScript contained
    syn region AWKScriptEmbedded matchgroup=AWKCommand start=+\<awk\>+ skip=+\\$+ end=+[=\\]\@<!'+me=e-1 contains=@shIdList,@shExprList2 nextgroup=AWKScriptCode
    syn cluster shCommandSubList add=AWKScriptEmbedded
    hi def link AWKCommand Type
<
This code will then let the awk code in the single quotes: >
    awk '...awk code here...'
be highlighted using the awk highlighting syntax.  Clearly this may be
extended to other languages.
