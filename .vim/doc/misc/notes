==============================================================================
http://mislav.net/2014/02/hidden-documentation/
==============================================================================
Create Hyper modifier to install various global key bindings

https://www.reddit.com/r/vim/comments/5kgw7x/what_sort_of_vim_tricks_are_there_for_editing_text/dboofjy/

CapsLock is the  evil. Escape is an  improvement, but when you  realise that vim
was designed on a keyboard with the Ctrl key in that spot, default commands make
a lot more sense.

I have the CapsLock key function as Ctrl when held and Escape when tapped, using
xcape. It's beautiful. Here are my configs: .Xmodmap

clear      lock
clear   control
clear      mod1
clear      mod2
clear      mod3
clear      mod4
clear      mod5
keycode      37 = Hyper_L
add     control = Control_L Control_R
add        mod1 = Alt_L Alt_R Meta_L
add        mod2 = Num_Lock
add        mod3 = Hyper_L
add        mod4 = Super_L Super_R
add        mod5 = Mode_switch ISO_Level3_Shift

(This also makes the physical Ctrl key "Hyper"; a long-forgotten modifier, that you can use to bind a plethora of global binds if you want)

Oh, another cool thing; you can still keep Capslock when the key is rebound; press both shift keys!

setxkbmap us -option ctrl:nocaps -option shift:both_capslock

.xinitrc

xmodmap ~/.Xmodmap &
xcape -t 170 &
setxkbmap us -option ctrl:nocaps -option shift:both_capslock

(the -t 170 flag gives a timeout; here, it will only register quick taps as Escape. Adjust to taste)

==============================================================================
There are inconsistencies between the different implementations of the modulo
operation over negative numbers, depending on the compiler, environment,
programming language…

    http://stackoverflow.com/questions/4467539/javascript-modulo-not-behaving#comment4882815_4467559
    https://www.reddit.com/r/vim/comments/4lfc4v/psa_modulo_returns_negative_numbers/d3mwlds/
    http://stackoverflow.com/a/11720975

    $ perl -E 'say -10 % 3'              →  2
    $ perl -Minteger -E 'say -10 % 3'    → -1

In VimL, when we use the modulo operation over a negative number, it seems we get a negative
result:
        :echo -5%4    →    -1

In math, we would get a positive one (3).

What's the solution to get back consistency across all programming languages and environment?
Use the formula described here:
http://javascript.about.com/od/problemsolving/a/modulobug.htm

    ((n%p)+p)%p

… where `n` and `p` are resp. a negative and positive number.

Adding `p` converts a possible negative result given by the modulo
operator into a positive number:

    if     (-5 % 4)     = -1
    then   (-5 % 4) + 4 = 3

But adding `p` would give us a too big result if `n` was a positive
number, instead of being negative:

    (5 % 4) + 4 = 5

So we need the second modulo to cover both cases with the same
formula:

    ((5 % 4) + 4) % 4 = 1

==============================================================================
User Manual (Built-in)
:h usr_toc.txt
:h quickref
:viu[sage]
:exu[sage]

https://romainl.github.io/the-patient-vimmer/1.html
https://bling.github.io/blog/2013/08/16/modularizing-vimscript/
https://ujihisa.blogspot.fr/2010/11/something-like-closure-for-vim-script.html

http://eduncan911.com/software/fix-slow-scrolling-in-vim-and-neovim.html
:syntime on
:syntime report
:set lazyredraw

:set synmaxcol=128
:syntax sync minlines=256

==============================================================================
'scrollbind' 'scb' option locale à la fenêtre, off par défaut
Toutes les fenêtres pour lesquelles cette option est active scrollent de façon synchronisée.


'scrollopt' 'sbo'   string  (default 'ver,jump')
            global

    This is a comma-separated list of words that specifies how
    'scrollbind' windows should behave.  'sbo' stands for ScrollBind
    Options. The following words are available:

        ver     Bind vertical scrolling for 'scrollbind' windows

        hor     Bind horizontal scrolling for 'scrollbind' windows

        jump    Applies to the offset between two windows for vertical
                scrolling.  This offset is the difference in the first
                displayed line of the bound windows.  When moving
                around in a window, another 'scrollbind' window may
                reach a position before the start or after the end of
                the buffer.  The offset is not changed though, when
                moving back the 'scrollbind' window will try to scroll
                to the desired position when possible.
                When now making that window the current one, two
                things can be done with the relative offset:

                1. When "jump" is not included, the relative offset is
                   adjusted for the scroll position in the new current
                   window.  When going back to the other window, the
                   new relative offset will be used.

                2. When "jump" is included, the other windows are
                   scrolled to keep the same relative offset.  When
                   going back to the other window, it still uses the
                   same relative offset.

    Also see |scroll-binding|.
    When 'diff' mode is active there always is vertical scroll binding,
    even when "ver" isn't there.


'scrolljump' 'sj'   number  (default 1)
            global

    Minimal number of lines to scroll when the cursor gets off the
    screen (e.g., with "j").  Not used for scroll commands (e.g., CTRL-E,
    CTRL-D).  Useful if your terminal scrolls very slowly.
    When set to a negative number from -1 to -100 this is used as the
    percentage of the window height.  Thus -50 scrolls half the window
    height.
    NOTE: This option is set to 1 when 'compatible' is set.


'scrolloff' 'so'    number  (default 0)
            global

    Minimal number of screen lines to keep above and below the cursor.
    This will make some context visible around where you are working.  If
    you set it to a very large value (999) the cursor line will always be
    in the middle of the window (except at the start or end of the file or
    when long lines wrap).
    For scrolling horizontally see 'sidescrolloff'.
    NOTE: This option is set to 0 when 'compatible' is set.


'sidescroll' 'ss'   number  (default 0)
            global

    The minimal number of columns to scroll horizontally.  Used only when
    the 'wrap' option is off and the cursor is moved off of the screen.
    When it is zero the cursor will be put in the middle of the screen.
    When using a slow terminal set it to a large number or 0.  When using
    a fast terminal use a small number or 1.  Not used for "zh" and "zl"
    commands.


'sidescrolloff' 'siso'  number (default 0)
            global

    The minimal number of screen columns to keep to the left and to the
    right of the cursor if 'nowrap' is set.  Setting this option to a
    value greater than 0 while having |'sidescroll'| also at a non-zero
    value makes some context visible in the line you are scrolling in
    horizontally (except at beginning of the line).  Setting this option
    to a large value (like 999) has the effect of keeping the cursor
    horizontally centered in the window, as long as one does not come too
    close to the beginning of the line.
    NOTE: This option is set to 0 when 'compatible' is set.

    Example: Try this together with 'sidescroll' and 'listchars' as
         in the following example to never allow the cursor to move
         onto the "extends" character:

         :set nowrap sidescroll=1 listchars=extends:>,precedes:<
         :set sidescrolloff=1

==============================================================================
List modification ~

    :call sort(list)                " sort a list alphabetically
    :call uniq(sort(list))          " sort and remove duplicates

    uniq(list[, func, dict])

        retourne   list,  mais   qd   un  item   se   répète  plusieurs   fois
        consécutivement, seule la 1e occurrence  est conservée les autres sont
        supprimées

        La suppression est faite in-place ; utiliser copy() pour conserver list intacte.
        Par défaut, la comparaison utilise la représentation sous forme de chaîne de chaque item.

        For the use of {func} and {dict} see |sort()|.

    :[range]sort[!] [iurn] [/pattern/]

        trie les lignes du buffer

        NOTE:
        • Si un pattern vide est fourni //, il est remplacé par la dernière recherche

        • Si un pattern est utilisé et que des lignes ne le contiennent pas:
          leur ordre est préservé (ou inversé avec un bang: sort!),
          mais elles sont déplacées avant les lignes qui matchent pattern.

        • ! inverse l'ordre de tri
        • si aucune rangée n'est fournie, toutes les lignes du buffer sont triées

    :sort /[^,]*,/

        trier toutes les lignes du buffer en fonction du texte situé après la 1e virgule (2e champ)

    :.,$!sort -k2 -r    :.,$sort! /\S\+\s\+/

        trier les lignes depuis la courante jusqu'à la dernière, en fonction du 2e champ et en inversant
        l'ordre du tri

    :%!sort -k3 -t,    :sort /\v([^,]*,){2}/

        trier en fonction du texte situé dans le 3e champ (les champs étant délimités par des virgules)

    :10,20 sort! /\a\a\a/ r

        trier les lignes 10 à 20 en fonction de leurs 3 premières lettres en inversant l'ordre de tri

        ! inverse l'ordre de tri

        r  effectue  le  tri  en  fonction du  texte  contenu  dans  le  pattern
        (autrement le tri commence après le pattern)

        Il existe d'autres flags intéressants (en + de r):

                i    ignore case
                n    sort on first decimal number
                u    uniq (only keep the 1st of a sequence of identical lines)

    :sort /.\{-}\ze\d/

        trier en fonction du 1er nb sur la ligne

        /.\{-}\ze\d/ élimine tout le texte qui précède le 1er chiffre
        en excluant/préservant (\ze) ce dernier

        FIXME: Ne semble pas très fiable. Tester là-dessus:

                foo 69
                bar 9
                baz 19

        Plus fiable:

                %!sort -rn -k2

        Tri numérique (-n), inversé (-r) sur le 2e champ (-k2).

    sort(mylist)

        retourne mylist triée

        NOTE:

        • Le tri est réalisé sur place / in-place.
          Pour éviter de modifier mylist: sort(copy(mylist))

        • Le tri utilise la représentation sous forme de chaîne de chaque item.
          Ceci implique pex que 123 apparaîtra avant 21 (pour trier des nombres, utiliser le 2e argument 'n').

        • Si my list contient un mélange de chaînes, nb et listes, ils sont triés de la façon suivante:

                chaînes > nb > listes

        • Le tri est stable: deux items considérés comme égaux conservent leur position relative.

    sort(mylist, 'i')

        retourne mylist triée, en ignorant la casse

    sort(mylist, 'n')    sort(mylist, 'N')

        retourne mylist triée, en utilisant un tri numérique et non la représentation sous forme de chaîne
        Les chaînes, listes, dictionnaires, références de fonctions sont tous considérés comme nuls.

        'N' réalise un tri numérique comme 'n' mais convertit en plus les chaînes contenant des nbs en ces derniers.

    sort(mylist, 'MySort')

        retourne mylist triée, en utilisant la fonction MySort() ou la funcref MySort pour comparer 2 éléments

        MySort() doit accepter 2 arguments, et retourner 0 qd ils sont égaux, un nb >=1 qd le 1er est trié
        après le 2nd, un nb <=-1 autrement.

        Ex de fonction de tri custom:

                fu MySort(i1, i2)
                    return a:i1 - a:i2
                    " ou return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
                endfu

==============================================================================
*41.8*  Lists and Dictionaries

DICTIONARIES

    :let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}

DICTIONARY FUNCTIONS

And now for something special: you can directly define a function and store a
reference to it in the dictionary: >

    :function uk2nl.translate(line) dict
    :  return join(map(split(a:line), 'get(self, v:val, "???")'))
    :endfu

Let's first try it out: >

    :echo uk2nl.translate('three two five one')
<   drie twee ??? een ~

The first special thing you notice is the "dict" at the end of the ":function"
line.  This marks the function as being used from a Dictionary.  The "self"
local variable will then refer to that Dictionary.

The get() function checks if a key is present in a Dictionary.  If it is, then
the value is retrieved.  If it isn't, then the default value is returned, in
the example it's '???'.  This is a convenient way to handle situations where a
key may not be present and you don't want an error message.

This combination of split(), map() and join() is a nice way to filter a line
of words in a very compact way.


OBJECT ORIENTED PROGRAMMING

Now that you can put both values and functions in a Dictionary, you can
actually use a Dictionary like an object.
   Above we used a Dictionary for translating Dutch to English.  We might want
to do the same for other languages.  Let's first make an object (aka
Dictionary) that has the translate function, but no words to translate: >

    :let transdict = {}
    :function transdict.translate(line) dict
    :  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
    :endfu

It's slightly different from the function above, using 'self.words' to lookup
word translations.  But we don't have a self.words.  Thus you could call this
an abstract class.

Now we can instantiate a Dutch translation object: >

    :let uk2nl = copy(transdict)
    :let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
    :echo uk2nl.translate('three one')
<   drie een ~

And a German translator: >

    :let uk2de = copy(transdict)
    :let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}
    :echo uk2de.translate('three one')
<   drei ein ~

You see that the copy() function is used to make a copy of the "transdict"
Dictionary and then the copy is changed to add the words.  The original
remains the same, of course.

Now you can go one step further, and use your preferred translator: >

    :if $LANG =~ "de"
    :  let trans = uk2de
    :else
    :  let trans = uk2nl
    :endif
    :echo trans.translate('one two three')
<   een twee drie ~

Here "trans" refers to one of the two objects (Dictionaries).  No copy is
made.  More about List and Dictionary identity can be found at |list-identity|
and |dict-identity|.

Now you might use a language that isn't supported.  You can overrule the
translate() function to do nothing: >

    :let uk2uk = copy(transdict)
    :fu uk2uk.translate(line)
    :  return a:line
    :endfu
    :echo uk2uk.translate('three one wladiwostok')
<   three one wladiwostok ~

Notice that a ! was used to overwrite the existing function reference.  Now
use "uk2uk" when no recognized language is found: >

    :if $LANG =~ "de"
    :  let trans = uk2de
    :elseif $LANG =~ "nl"
    :  let trans = uk2nl
    :else
    :  let trans = uk2uk
    :endif
    :echo trans.translate('one two three')
<   one two three ~

==============================================================================
*41.9*  Exceptions

Let's start with an example: >

    :try
    :   read ~/templates/pascal.tmpl
    :catch /E484:/
    :   echo "Sorry, the Pascal template file cannot be found."
    :endtry

The ":read" command will fail if the file does not exist.  Instead of
generating an error message, this code catches the error and gives the user a
nice message.

For the commands in between ":try" and ":endtry" errors are turned into
exceptions.  An exception is a string.  In the case of an error the string
contains the error message.  And every error message has a number.  In this
case, the error we catch contains "E484:".  This number is guaranteed to stay
the same (the text may change, e.g., it may be translated).

When the ":read" command causes another error, the pattern "E484:" will not
match in it.  Thus this exception will not be caught and result in the usual
error message.

You might be tempted to do this: >

    :try
    :   read ~/templates/pascal.tmpl
    :catch
    :   echo "Sorry, the Pascal template file cannot be found."
    :endtry

This means all errors are caught.  But then you will not see errors that are
useful, such as "E21: Cannot make changes, 'modifiable' is off".

Another useful mechanism is the ":finally" command: >

    :let tmp = tempname()
    :try
    :   exe ".,$write " . tmp
    :   exe "!filter " . tmp
    :   .,$delete
    :   exe "$read " . tmp
    :finally
    :   call delete(tmp)
    :endtry

This filters the lines from the cursor until the end of the file through the
"filter" command, which takes a file name argument.  No matter if the
filtering works, something goes wrong in between ":try" and ":finally" or the
user cancels the filtering by pressing CTRL-C, the "call delete(tmp)" is
always executed.  This makes sure you don't leave the temporary file behind.

More information about exception handling can be found in the reference
manual: |exception-handling|.

==============================================================================
*41.10* Various remarks

Here is a summary of items that apply to Vim scripts.  They are also mentioned
elsewhere, but form a nice checklist.

The end-of-line character depends on the system.  For Unix a single <NL>
character is used.  For MS-DOS, Windows, OS/2 and the like, <CR><LF> is used.
This is important when using mappings that end in a <CR>.  See |:source_crnl|.


WHITE SPACE

Blank lines are allowed and ignored.

Leading whitespace characters (blanks and TABs) are always ignored.  The
whitespaces between parameters (e.g. between the 'set' and the 'cpoptions' in
the example below) are reduced to one blank character and plays the role of a
separator, the whitespaces after the last (visible) character may or may not
be ignored depending on the situation, see below.

For a ":set" command involving the "=" (equal) sign, such as in: >

    :set cpoptions    =aABceFst

the whitespace immediately before the "=" sign is ignored.  But there can be
no whitespace after the "=" sign!

To include a whitespace character in the value of an option, it must be
escaped by a "\" (backslash)  as in the following example: >

    :set tags=my\ nice\ file

The same example written as: >

    :set tags=my nice file

will issue an error, because it is interpreted as: >

    :set tags=my
    :set nice
    :set file


COMMENTS

The character " (the double quote mark) starts a comment.  Everything after
and including this character until the end-of-line is considered a comment and
is ignored, except for commands that don't consider comments, as shown in
examples below.  A comment can start on any character position on the line.

There is a little "catch" with comments for some commands.  Examples: >

    :abbrev dev development     " shorthand
    :map <F3> o#include     " insert include
    :exe cmd            " do it
    :!ls *.c            " list C files

The abbreviation 'dev' will be expanded to 'development     " shorthand'.  The
mapping of <F3> will actually be the whole line after the 'o# ....' including
the '" insert include'.  The "execute" command will give an error.  The "!"
command will send everything after it to the shell, causing an error for an
unmatched '"' character.
   There can be no comment after ":map", ":abbreviate", ":execute" and "!"
commands (there are a few more commands with this restriction).  For the
":map", ":abbreviate" and ":execute" commands there is a trick: >

    :abbrev dev development|" shorthand
    :map <F3> o#include|" insert include
    :execute cmd            |" do it

With the '|' character the command is separated from the next one.  And that
next command is only a comment.  For the last command you need to do two
things: |:execute| and use '|': >
    :exe '!ls *.c'          |" list C files

Notice that there is no white space before the '|' in the abbreviation and
mapping.  For these commands, any character until the end-of-line or '|' is
included.  As a consequence of this behavior, you don't always see that
trailing whitespace is included: >

    :map <F4> o#include

To spot these problems, you can set the 'list' option when editing vimrc
files.

For Unix there is one special way to comment a line, that allows making a Vim
script executable: >
    #!/usr/bin/env vim -S
    echo "this is a Vim script"
    quit

The "#" command by itself lists a line with the line number.  Adding an
exclamation mark changes it into doing nothing, so that you can add the shell
command to execute the rest of the file. |:#!| |-S|


PITFALLS

Even bigger problem arises in the following example: >

    :map ,ab o#include
    :unmap ,ab

Here the unmap command will not work, because it tries to unmap ",ab ".  This
does not exist as a mapped sequence.  An error will be issued, which is very
hard to identify, because the ending whitespace character in ":unmap ,ab " is
not visible.

And this is the same as what happens when one uses a comment after an 'unmap'
command: >

    :unmap ,ab     " comment

Here the comment part will be ignored.  However, Vim will try to unmap
',ab     ', which does not exist.  Rewrite it as: >

    :unmap ,ab|    " comment


RESTORING THE VIEW

Sometimes you want to make a change and go back to where the cursor was.
Restoring the relative position would also be nice, so that the same line
appears at the top of the window.
   This example yanks the current line, puts it above the first line in the
file and then restores the view: >

    map ,p ma"aYHmbgg"aP`bzt`a

What this does: >
    ma"aYHmbgg"aP`bzt`a
<   ma          set mark a at cursor position
      "aY           yank current line into register a
         Hmb        go to top line in window and set mark b there
        gg      go to first line in file
          "aP       put the yanked line above it
             `b     go back to top line in display
               zt   position the text in the window as before
             `a go back to saved cursor position


PACKAGING

To avoid your function names to interfere with functions that you get from
others, use this scheme:
- Prepend a unique string before each function name.  I often use an
  abbreviation.  For example, "OW_" is used for the option window functions.
- Put the definition of your functions together in a file.  Set a global
  variable to indicate that the functions have been loaded.  When sourcing the
  file again, first unload the functions.
Example: >

    " This is the XXX package

    if exists("XXX_loaded")
      delfun XXX_one
      delfun XXX_two
    endif

    function XXX_one(a)
        ... body of function ...
    endfu

    function XXX_two(b)
        ... body of function ...
    endfu

    let XXX_loaded = 1

==============================================================================
*41.11* Writing a plugin

You can write a Vim script in such a way that many people can use it.  This is
called a plugin.  Vim users can drop your script in their plugin directory and
use its features right away |add-plugin|.

There are actually two types of plugins:

  global plugins: For all types of files.
filetype plugins: Only for files of a specific type.

In this section the first type is explained.  Most items are also relevant for
writing filetype plugins.  The specifics for filetype plugins are in the next
section |write-filetype-plugin|.


NAME

First of all you must choose a name for your plugin.  The features provided
by the plugin should be clear from its name.  And it should be unlikely that
someone else writes a plugin with the same name but which does something
different.  And please limit the name to 8 characters, to avoid problems on
old Windows systems.

A script that corrects typing mistakes could be called "typecorr.vim".  We
will use it here as an example.

For the plugin to work for everybody, it should follow a few guidelines.  This
will be explained step-by-step.  The complete example plugin is at the end.


BODY

Let's start with the body of the plugin, the lines that do the actual work: >

 14 iabbrev teh the
 15 iabbrev otehr other
 16 iabbrev wnat want
 17 iabbrev synchronisation
 18     \ synchronization
 19 let s:count = 4

The actual list should be much longer, of course.

The line numbers have only been added to explain a few things, don't put them
in your plugin file!


HEADER

You will probably add new corrections to the plugin and soon have several
versions lying around.  And when distributing this file, people will want to
know who wrote this wonderful plugin and where they can send remarks.
Therefore, put a header at the top of your plugin: >

  1 " Vim global plugin for correcting typing mistakes
  2 " Last Change:  2000 Oct 15
  3 " Maintainer:   Bram Moolenaar <Bram@vim.org>

About copyright and licensing: Since plugins are very useful and it's hardly
worth restricting their distribution, please consider making your plugin
either public domain or use the Vim |license|.  A short note about this near
the top of the plugin should be sufficient.  Example: >

  4 " License:  This file is placed in the public domain.


LINE CONTINUATION, AVOIDING SIDE EFFECTS        *use-cpo-save*

In line 18 above, the line-continuation mechanism is used |line-continuation|.
Users with 'compatible' set will run into trouble here, they will get an error
message.  We can't just reset 'compatible', because that has a lot of side
effects.  To avoid this, we will set the 'cpoptions' option to its Vim default
value and restore it later.  That will allow the use of line-continuation and
make the script work for most people.  It is done like this: >

 11 let s:save_cpo = &cpo
 12 set cpo&vim
 ..
 42 let &cpo = s:save_cpo
 43 unlet s:save_cpo

We first store the old value of 'cpoptions' in the s:save_cpo variable.  At
the end of the plugin this value is restored.

Notice that a script-local variable is used |s:var|.  A global variable could
already be in use for something else.  Always use script-local variables for
things that are only used in the script.


NOT LOADING

It's possible that a user doesn't always want to load this plugin.  Or the
system administrator has dropped it in the system-wide plugin directory, but a
user has his own plugin he wants to use.  Then the user must have a chance to
disable loading this specific plugin.  This will make it possible: >

  6 if exists("g:loaded_typecorr")
  7   finish
  8 endif
  9 let g:loaded_typecorr = 1

This also avoids that when the script is loaded twice it would cause error
messages for redefining functions and cause trouble for autocommands that are
added twice.

The name is recommended to start with "loaded_" and then the file name of the
plugin, literally.  The "g:" is prepended just to avoid mistakes when using
the variable in a function (without "g:" it would be a variable local to the
function).

Using "finish" stops Vim from reading the rest of the file, it's much quicker
than using if-endif around the whole file.


MAPPING

Now let's make the plugin more interesting: We will add a mapping that adds a
correction for the word under the cursor.  We could just pick a key sequence
for this mapping, but the user might already use it for something else.  To
allow the user to define which keys a mapping in a plugin uses, the <Leader>
item can be used: >

 22   map <unique> <Leader>a  <Plug>TypecorrAdd

The "<Plug>TypecorrAdd" thing will do the work, more about that further on.

The user can set the "mapleader" variable to the key sequence that he wants
this mapping to start with.  Thus if the user has done: >

    let mapleader = "_"

the mapping will define "_a".  If the user didn't do this, the default value
will be used, which is a backslash.  Then a map for "\a" will be defined.

Note that <unique> is used, this will cause an error message if the mapping
already happened to exist. |:map-<unique>|

But what if the user wants to define his own key sequence?  We can allow that
with this mechanism: >

 21 if !hasmapto('<Plug>TypecorrAdd')
 22   map <unique> <Leader>a  <Plug>TypecorrAdd
 23 endif

This checks if a mapping to "<Plug>TypecorrAdd" already exists, and only
defines the mapping from "<Leader>a" if it doesn't.  The user then has a
chance of putting this in his vimrc file: >

    map ,c  <Plug>TypecorrAdd

Then the mapped key sequence will be ",c" instead of "_a" or "\a".


PIECES

If a script gets longer, you often want to break up the work in pieces.  You
can use functions or mappings for this.  But you don't want these functions
and mappings to interfere with the ones from other scripts.  For example, you
could define a function Add(), but another script could try to define the same
function.  To avoid this, we define the function local to the script by
prepending it with "s:".

We will define a function that adds a new typing correction: >

 30 function s:Add(from, correct)
 31   let to = input("type the correction for " . a:from . ": ")
 32   exe ":iabbrev " . a:from . " " . to
 ..
 36 endfu

Now we can call the function s:Add() from within this script.  If another
script also defines s:Add(), it will be local to that script and can only
be called from the script it was defined in.  There can also be a global Add()
function (without the "s:"), which is again another function.

<SID> can be used with mappings.  It generates a script ID, which identifies
the current script.  In our typing correction plugin we use it like this: >

 24 noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 ..
 28 noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>

Thus when a user types "\a", this sequence is invoked: >

    \a  →  <Plug>TypecorrAdd  →  <SID>Add  →  :call <SID>Add()

If another script would also map <SID>Add, it would get another script ID and
thus define another mapping.

Note that instead of s:Add() we use <SID>Add() here.  That is because the
mapping is typed by the user, thus outside of the script.  The <SID> is
translated to the script ID, so that Vim knows in which script to look for
the Add() function.

This is a bit complicated, but it's required for the plugin to work together
with other plugins.  The basic rule is that you use <SID>Add() in mappings and
s:Add() in other places (the script itself, autocommands, user commands).

We can also add a menu entry to do the same as the mapping: >

 26 noremenu <script> Plugin.Add\ Correction      <SID>Add

The "Plugin" menu is recommended for adding menu items for plugins.  In this
case only one item is used.  When adding more items, creating a submenu is
recommended.  For example, "Plugin.CVS" could be used for a plugin that offers
CVS operations "Plugin.CVS.checkin", "Plugin.CVS.checkout", etc.

Note that in line 28 ":noremap" is used to avoid that any other mappings cause
trouble.  Someone may have remapped ":call", for example.  In line 24 we also
use ":noremap", but we do want "<SID>Add" to be remapped.  This is why
"<script>" is used here.  This only allows mappings which are local to the
script. |:map-<script>|  The same is done in line 26 for ":noremenu".
|:menu-<script>|

                        *:map-<script>* *:map-script*
If the first argument to one of these commands is "<script>" and it is used to
define a new mapping or abbreviation, the mapping will only remap characters
in the {rhs} using mappings that were defined local to a script, starting with
"<SID>".  This can be used to avoid that mappings from outside a script
interfere (e.g., when CTRL-V is remapped in mswin.vim), but do use other
mappings defined in the script.
Note: ":map <script>" and ":noremap <script>" do the same thing.  The
"<script>" overrules the command name.  Using ":noremap <script>" is
preferred, because it's clearer that remapping is (mostly) disabled.


USER COMMAND

Now let's add a user command to add a correction: >

 38 if !exists(":Correct")
 39   command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40 endif

The user command is defined only if no command with the same name already
exists.  Otherwise we would get an error here.  Overriding the existing user
command with ":command!" is not a good idea, this would probably make the user
wonder why the command he defined himself doesn't work.  |:command|


SCRIPT VARIABLES

When a variable starts with "s:" it is a script variable.  It can only be used
inside a script.  Outside the script it's not visible.  This avoids trouble
with using the same variable name in different scripts.  The variables will be
kept as long as Vim is running.  And the same variables are used when sourcing
the same script again. |s:var|

The fun is that these variables can also be used in functions, autocommands
and user commands that are defined in the script.  In our example we can add
a few lines to count the number of corrections: >

 19 let s:count = 4
 ..
 30 function s:Add(from, correct)
 ..
 34   let s:count = s:count + 1
 35   echo s:count . " corrections now"
 36 endfu

First s:count is initialized to 4 in the script itself.  When later the
s:Add() function is called, it increments s:count.  It doesn't matter from
where the function was called, since it has been defined in the script, it
will use the local variables from this script.


THE RESULT

Here is the resulting complete example: >

  1 " Vim global plugin for correcting typing mistakes
  2 " Last Change:  2000 Oct 15
  3 " Maintainer:   Bram Moolenaar <Bram@vim.org>
  4 " License:  This file is placed in the public domain.
  5
  6 if exists("g:loaded_typecorr")
  7   finish
  8 endif
  9 let g:loaded_typecorr = 1
 10
 11 let s:save_cpo = &cpo
 12 set cpo&vim
 13
 14 iabbrev teh the
 15 iabbrev otehr other
 16 iabbrev wnat want
 17 iabbrev synchronisation
 18     \ synchronization
 19 let s:count = 4
 20
 21 if !hasmapto('<Plug>TypecorrAdd')
 22   map <unique> <Leader>a  <Plug>TypecorrAdd
 23 endif
 24 noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 25
 26 noremenu <script> Plugin.Add\ Correction      <SID>Add
 27
 28 noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
 29
 30 function s:Add(from, correct)
 31   let to = input("type the correction for " . a:from . ": ")
 32   exe ":iabbrev " . a:from . " " . to
 33   if a:correct | exe "normal viws\<C-R>\" \b\e" | endif
 34   let s:count = s:count + 1
 35   echo s:count . " corrections now"
 36 endfu
 37
 38 if !exists(":Correct")
 39   command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40 endif
 41
 42 let &cpo = s:save_cpo
 43 unlet s:save_cpo

Line 33 wasn't explained yet.  It applies the new correction to the word under
the cursor.  The |:normal| command is used to use the new abbreviation.  Note
that mappings and abbreviations are expanded here, even though the function
was called from a mapping defined with ":noremap".

Using "unix" for the 'fileformat' option is recommended.  The Vim scripts will
then work everywhere.  Scripts with 'fileformat' set to "dos" do not work on
Unix.  Also see |:source_crnl|.  To be sure it is set right, do this before
writing the file: >

    :set fileformat=unix


DOCUMENTATION                       *write-local-help*

It's a good idea to also write some documentation for your plugin.  Especially
when its behavior can be changed by the user.  See |add-local-help| for how
they are installed.

Here is a simple example for a plugin help file, called "typecorr.txt": >

  1 *typecorr.txt*  Plugin for correcting typing mistakes
  2
  3 If you make typing mistakes, this plugin will have them corrected
  4 automatically.
  5
  6 There are currently only a few corrections.  Add your own if you like.
  7
  8 Mappings:
  9 <Leader>a   or   <Plug>TypecorrAdd
 10     Add a correction for the word under the cursor.
 11
 12 Commands:
 13 :Correct {word}
 14     Add a correction for {word}.
 15
 16                         *typecorr-settings*
 17 This plugin doesn't have any settings.

The first line is actually the only one for which the format matters.  It will
be extracted from the help file to be put in the "LOCAL ADDITIONS:" section of
help.txt |local-additions|.  The first "*" must be in the first column of the
first line.  After adding your help file do ":help" and check that the entries
line up nicely.

You can add more tags inside ** in your help file.  But be careful not to use
existing help tags.  You would probably use the name of your plugin in most of
them, like "typecorr-settings" in the example.

Using references to other parts of the help in || is recommended.  This makes
it easy for the user to find associated help.


FILETYPE DETECTION                  *plugin-filetype*

If your filetype is not already detected by Vim, you should create a filetype
detection snippet in a separate file.  It is usually in the form of an
autocommand that sets the filetype when the file name matches a pattern.
Example: >

    au BufNewFile,BufRead *.foo         set filetype=foofoo

Write this single-line file as "ftdetect/foofoo.vim" in the first directory
that appears in 'runtimepath'.  For Unix that would be
"~/.vim/ftdetect/foofoo.vim".  The convention is to use the name of the
filetype for the script name.

You can make more complicated checks if you like, for example to inspect the
contents of the file to recognize the language.  Also see |new-filetype|.


SUMMARY                         *plugin-special*

Summary of special things to use in a plugin:

s:name          Variables local to the script.

<SID>           Script-ID, used for mappings and functions local to
            the script.

hasmapto()      Function to test if the user already defined a mapping
            for functionality the script offers.

<Leader>        Value of "mapleader", which the user defines as the
            keys that plugin mappings start with.

:map <unique>       Give a warning if a mapping already exists.

:noremap <script>   Use only mappings local to the script, not global
            mappings.

exists(":Cmd")      Check if a user command already exists.

==============================================================================
*41.14* Writing a plugin that loads quickly *write-plugin-quickload*

A plugin may grow and become quite long.  The startup delay may become
noticeable, while you hardly ever use the plugin.  Then it's time for a
quickload plugin.

The basic idea is that the plugin is loaded twice.  The first time user
commands and mappings are defined that offer the functionality.  The second
time the functions that implement the functionality are defined.

It may sound surprising that quickload means loading a script twice.  What we
mean is that it loads quickly the first time, postponing the bulk of the
script to the second time, which only happens when you actually use it.  When
you always use the functionality it actually gets slower!

Note that since Vim 7 there is an alternative: use the |autoload|
functionality |41.15|.

The following example shows how it's done: >

    " Vim global plugin for demonstrating quick loading
    " Last Change:  2005 Feb 25
    " Maintainer:   Bram Moolenaar <Bram@vim.org>
    " License:  This file is placed in the public domain.

    if !exists("s:did_load")
        command -nargs=* BNRead  call BufNetRead(<f-args>)
        map <F19> :call BufNetWrite('something')<CR>

        let s:did_load = 1
        exe 'au FuncUndefined BufNet* source ' . expand('<sfile>')
        finish
    endif

    function BufNetRead(...)
        echo 'BufNetRead(' . string(a:000) . ')'
        " read functionality here
    endfu

    function BufNetWrite(...)
        echo 'BufNetWrite(' . string(a:000) . ')'
        " write functionality here
    endfu

When the script is first loaded "s:did_load" is not set.  The commands between
the "if" and "endif" will be executed.  This ends in a |:finish| command, thus
the rest of the script is not executed.

The second time the script is loaded "s:did_load" exists and the commands
after the "endif" are executed.  This defines the (possible long)
BufNetRead() and BufNetWrite() functions.

If you drop this script in your plugin directory Vim will execute it on
startup.  This is the sequence of events that happens:

1. The "BNRead" command is defined and the <F19> key is mapped when the script
   is sourced at startup.  A |FuncUndefined| autocommand is defined.  The
   ":finish" command causes the script to terminate early.

2. The user types the BNRead command or presses the <F19> key.  The
   BufNetRead() or BufNetWrite() function will be called.

3. Vim can't find the function and triggers the |FuncUndefined| autocommand
   event.  Since the pattern "BufNet*" matches the invoked function, the
   command "source fname" will be executed.  "fname" will be equal to the name
   of the script, no matter where it is located, because it comes from
   expanding "<sfile>" (see |expand()|).

4. The script is sourced again, the "s:did_load" variable exists and the
   functions are defined.

Notice that the functions that are loaded afterwards match the pattern in the
|FuncUndefined| autocommand.  You must make sure that no other plugin defines
functions that match this pattern.

==============================================================================
*41.15* Writing library scripts         *write-library-script*

Some functionality will be required in several places.  When this becomes more
than a few lines you will want to put it in one script and use it from many
scripts.  We will call that one script a library script.

Manually loading a library script is possible, so long as you avoid loading it
when it's already done.  You can do this with the |exists()| function.
Example: >

    if !exists('*MyLibFunction')
       runtime library/mylibscript.vim
    endif
    call MyLibFunction(arg)

Here you need to know that MyLibFunction() is defined in a script
"library/mylibscript.vim" in one of the directories in 'runtimepath'.

To make this a bit simpler Vim offers the autoload mechanism.  Then the
example looks like this: >

    call mylib#myfunction(arg)

That's a lot simpler, isn't it?  Vim will recognize the function name and when
it's not defined search for the script "autoload/mylib.vim" in 'runtimepath'.
That script must define the "mylib#myfunction()" function.

You can put many other functions in the mylib.vim script, you are free to
organize your functions in library scripts.  But you must use function names
where the part before the '#' matches the script name.  Otherwise Vim would
not know what script to load.

If you get really enthusiastic and write lots of library scripts, you may
want to use subdirectories.  Example: >

    call netlib#ftp#read('somefile')

For Unix the library script used for this could be:

    ~/.vim/autoload/netlib/ftp.vim

Where the function is defined like this: >

    function netlib#ftp#read(fname)
        "  Read the file fname through ftp
    endfu

Notice that the name the function is defined with is exactly the same as the
name used for calling the function.  And the part before the last '#'
exactly matches the subdirectory and script name.

You can use the same mechanism for variables: >

    let weekdays = dutch#weekdays

This will load the script "autoload/dutch.vim", which should contain something
like: >

    let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
        \ 'donderdag', 'vrijdag', 'zaterdag']

Further reading: |autoload|.

==============================================================================
------------------------------------------------------------------------------
======================
reddit - medium - gist 

https://www.reddit.com/r/vim/comments/7bj837/favorite_console_tools_to_use_with_vim/
https://www.reddit.com/r/vim/comments/4ootmz/what_is_your_little_known_secret_vim_shortcut_or/
https://www.reddit.com/r/vim/comments/7iy03o/you_aint_gonna_need_it_your_replacement_for/dr2qo4k/
https://www.reddit.com/r/vim/comments/6tb492/vi_is_not_vim/dlkgv6f/
https://www.reddit.com/r/vim/comments/6ucyus/editing_prose_with_vim_help_with_using_vim_to/dlrrsfc/
https://medium.com/brigade-engineering/sharpen-your-vim-with-snippets-767b693886db
https://medium.com/@crashybang/supercharge-vim-with-fzf-and-ripgrep-d4661fc853d2#.hfnqelusz
https://nondev.io/Fuzzy-completion-in-Vim
https://blog.bugsnag.com/tmux-and-vim/

Relire le plugin sensible

Lire :h include-search

======================
Vim Stack Exchange

https://vi.stackexchange.com/questions/2115/can-i-be-notified-when-im-undoing-changes-from-the-undofile
https://vi.stackexchange.com/questions/9156/what-is-a-more-efficient-way-to-use-buffers
https://vi.stackexchange.com/questions/8122/how-to-open-a-file-from-active-buffer-into-a-split-window
https://vi.stackexchange.com/questions/8670/how-can-i-enable-folding-only-for-files-longer-than-a-certain-length/8672#8672
https://vi.stackexchange.com/questions/8674/how-to-save-and-restore-the-result-of-the-command-set
https://vi.stackexchange.com/questions/8709/keep-windows-reference-in-memory
https://vi.stackexchange.com/questions/8926/is-it-possible-to-obtain-the-displayable-area-width-and-height-of-current-buffe
https://stackoverflow.com/questions/26315925/get-usable-window-width-in-vim-script/26318602#26318602
https://vi.stackexchange.com/questions/9700/mutliple-choice-substitute
https://vi.stackexchange.com/questions/8683/mapping-without-polluting-the-global-namespace
http://vimcasts.org/blog/2014/02/follow-my-leader/
https://vi.stackexchange.com/questions/2543/how-can-i-map-dcountd/2546#2546

https://vi.stackexchange.com/questions/7925/quick-search-limited-to-a-c-function
https://vi.stackexchange.com/questions/6869/how-to-handle-a-nested-dictionary-with-mixed-key-values
https://vi.stackexchange.com/questions/471/why-do-i-need-both-a-vimrc-and-a-gvimrc
https://vi.stackexchange.com/questions/8127/is-there-a-way-to-restrict-search-results-to-differences-in-a-diff
https://vi.stackexchange.com/questions/8692/command-to-loop-through-spelling-suggestions/


https://vi.stackexchange.com/questions/2009/how-do-i-make-vim-look-in-a-set-of-directories-for-a-file-if-it-doesnt-exist-i



color scheme
https://vi.stackexchange.com/questions/6780/how-do-i-preserve-my-colorscheme-when-i-sudo-to-root
https://vi.stackexchange.com/questions/8575/neovim-default-colors-dont-match-vims
https://vi.stackexchange.com/questions/8607/how-do-putty-kitty-ansi-colors-affect-vim-colorschemes/

conceal
https://vi.stackexchange.com/questions/8559/vim-conceal-indentation-replace-indentation-spaces-with-utf-8-chars/
https://vi.stackexchange.com/questions/6474/how-do-i-hide-a-tex-macro-and-highlight-the-arguments

folding
https://vi.stackexchange.com/questions/8770/how-can-i-hide-blank-lines-in-vim-without-actually-removing-them-from-the-text-i
https://vi.stackexchange.com/questions/6738/is-it-possible-to-create-a-folding-inside-a-single-line

miscellaneous
https://vi.stackexchange.com/questions/6876/can-i-apply-one-files-filetype-to-another-without-actually-opening-the-first-f
https://vi.stackexchange.com/questions/6784/how-can-i-automate-filetype-detection-when-using-sudoedit
https://vi.stackexchange.com/questions/6773/how-can-i-make-vims-flowing-aware-of-email-replies
https://vi.stackexchange.com/questions/6705/use-shell-variable-substitution-with-current-filepath
https://vi.stackexchange.com/questions/6238/how-can-i-make-a-slow-ish-system-call-in-a-statusline-without-corrupting-the-d
https://vi.stackexchange.com/questions/5941/summary-of-functions-in-current-file
https://vi.stackexchange.com/questions/5869/edit-neovim-terminal-commandline-within-the-same-neovim-instance
https://vi.stackexchange.com/questions/5667/escape-return-value-key-in-mapping-function
https://vi.stackexchange.com/questions/3920/is-it-possible-to-use-a-delegate-or-to-pass-a-function-as-argument-in-vimscript
https://vi.stackexchange.com/questions/8958/align-code-functions-documentation
https://vi.stackexchange.com/questions/9880/retitling-tab-labels
https://vi.stackexchange.com/questions/10077/get-index-of-search-in-substitute-expression
https://vi.stackexchange.com/questions/10083/how-can-i-sort-a-file-by-word-frequency/10092#10092
https://vi.stackexchange.com/questions/10167/is-there-a-way-that-i-can-identify-which-window-is-a-terminal-after-calling-the/10173#10173
https://vi.stackexchange.com/questions/9416/how-do-you-find-where-a-variable-was-last-assigned

syntax highlighting

:h syntax-loading
http://vim.wikia.com/wiki/Creating_your_own_syntax_files
https://vi.stackexchange.com/questions/5855/is-it-possible-to-turn-on-spell-checking-for-only-parts-of-buffers
https://vi.stackexchange.com/questions/7445/nested-highlighting
https://vi.stackexchange.com/questions/6943/syntax-highlight-region-keyword-overlap
https://vi.stackexchange.com/questions/6731/vim-syntax-pattern-to-highlight-python-keyword-argument
https://vi.stackexchange.com/questions/7709/custom-syntax-highlighting-highlight-word-following-keyword
https://vi.stackexchange.com/questions/6703/start-of-match-zs-seems-to-break-my-pattern
https://vi.stackexchange.com/questions/9599/syntax-highlighting-for-custom-latex-commands
https://vi.stackexchange.com/questions/10132/vim-syntax-file-how-to-match-capturing-groups
https://vi.stackexchange.com/questions/10193/how-do-i-make-regexes-mutually-contain-each-other
http://stackoverflow.com/questions/2683521/vim-search-in-c-c-code-lines/2696143#2696143
https://vi.stackexchange.com/questions/11371/where-does-red-highlighting-come-from-with-syntax-off-and-spell-on-in-neovim



Is it possible to send a buffer in the arglist to another local arglist?
How to unload all buffers from the global arglist except the ones of a local arglist?


Is it possible to change the maximum number of entries in the changelist and in the jumplist?
'viminfo' seems to allow to control the maximum number of a lot of things but not these 2.



When closing a tab page, how to give the focus to the last tab page which had the focus instead
of the last tab page on the right?

aug my_tab_focus
    au!
    " Leave comes before Closed
    au TabLeave  * let s:my_last_tab = tabpagenr()
    au TabClosed * call s:tab_focus_restore()
aug END

fu s:tab_focus_restore() abort
    if s:my_last_tab < tabpagenr()
        let g:debug = { 'my_last_tab' : s:my_last_tab, 'cmd' : 'tabnext '.(s:my_last_tab - 1) }
    else
        let g:debug = { 'my_last_tab' : s:my_last_tab, 'cmd' : 'tabnext '.s:my_last_tab }
    endif
endfu

======================
                            *search()-sub-match*
        With the 'p' flag the returned value is one more than the
        first sub-match in \(\).  One if none of them matched but the
        whole pattern did match.
        To get the column number too use |searchpos()|.

        The cursor will be positioned at the match, unless the 'n'
        flag is used.

        Example (goes over all files in the argument list): >

            let n = 1
            " loop over all files in arglist
            while n <= argc()
              exe 'argument '.n

              " start at the last char in the file and wrap for the
              " first search to find match at start of file

              norm! G$

              let flags = 'w'
              while search('foo', flags) > 0
                s/foo/bar/g
                let flags = 'W'
              endwhile

              update
              let n += 1
            endwhile
<
        Example for using some flags: >

            echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')

<       This will search for the keywords "if", "else", and "endif"
        under or after the cursor.  Because of the 'p' flag, it
        returns 1, 2, or 3 depending on which keyword is found, or 0
        if the search fails.  With the cursor on the first word of the
        line:
            if (foo == 0) | let foo = foo + 1 | endif ~
        the function returns 1.  Without the 'c' flag, the function
        finds the "endif" and returns 3.  The same thing happens
        without the 'e' flag if the cursor is on the "f" of "if".
        The 'n' flag tells the function not to move the cursor.


searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])   *searchpos()*

        Same as |search()|, but returns a |List| with the line and
        column position of the match. The first element of the |List|
        is the line number and the second element is the byte index of
        the column position of the match. If no match is found,
        returns [0, 0].
        Example: >

    let [lnum, col] = searchpos('mypattern', 'n')

<       When the 'p' flag is given then there is an extra item with
        the sub-pattern match number |search()-sub-match|.  Example: >

    let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')

<       In this example "submatch" is 2 when a lowercase letter is
        found |/\l|, 3 when an uppercase letter is found |/\u|.

======================
Coming Home to Vim

Next are a few options that just make things better:

set visualbell
set ttyfast

The next section makes Vim handle long lines correctly:

set formatoptions=qrn1
set colorcolumn=85

These lines manage my line wrapping settings and also show a colored column at 85 characters
(so I can see when I write a too-long line of code).

See :help fo-table and the Vimcasts on soft wrapping and hard wrapping for more information.

Finally, I really like TextMate’s “save on losing focus” feature. I can’t remember a time when I didn’t want to save a file after tabbing away from my editor (especially with version control and Vim’s persistent undo):

au FocusLost * :wa

        https://github.com/tmux-plugins/vim-tmux-focus-events
        https://github.com/tmux-plugins/tmux-sensible
        Unfortunately doesn't seem to work with xfce4-terminal or guake (Sure?).

======================
cheatsheet

                        *[(*
[(          go to [count] previous unmatched '('.
            |exclusive| motion. {not in Vi}

                        *[{*
[{          go to [count] previous unmatched '{'.
            |exclusive| motion. {not in Vi}

                        *])*
])          go to [count] next unmatched ')'.
            |exclusive| motion. {not in Vi}

                        *]}*
]}          go to [count] next unmatched '}'.
            |exclusive| motion. {not in Vi}

The above four commands can be used to go to the start or end of the current
code block.  It is like doing "%" on the '(', ')', '{' or '}' at the other
end of the code block, but you can do this from anywhere in the code block.
Very useful for C programs.  Example: When standing on "case x:", "[{" will
bring you back to the switch statement.

                        *]m*
]m          Go to [count] next start of a method (for Java or
            similar structured language).  When not before the
            start of a method, jump to the start or end of the
            class.  When no '{' is found after the cursor, this is
            an error.  |exclusive| motion. {not in Vi}
                        *]M*
]M          Go to [count] next end of a method (for Java or
            similar structured language).  When not before the end
            of a method, jump to the start or end of the class.
            When no '}' is found after the cursor, this is an
            error. |exclusive| motion. {not in Vi}
                        *[m*
[m          Go to [count] previous start of a method (for Java or
            similar structured language).  When not after the
            start of a method, jump to the start or end of the
            class.  When no '{' is found before the cursor this is
            an error. |exclusive| motion. {not in Vi}
                        *[M*
[M          Go to [count] previous end of a method (for Java or
            similar structured language).  When not after the
            end of a method, jump to the start or end of the
            class.  When no '}' is found before the cursor this is
            an error. |exclusive| motion. {not in Vi}

The above two commands assume that the file contains a class with methods.
The class definition is surrounded in '{' and '}'.  Each method in the class
is also surrounded with '{' and '}'.  This applies to the Java language.  The
file looks like this: >

    // comment
    class foo {
        int method_one() {
            body_one();
        }
        int method_two() {
            body_two();
        }
    }
Starting with the cursor on "body_two()", using "[m" will jump to the '{' at
the start of "method_two()" (obviously this is much more useful when the
method is long!).  Using "2[m" will jump to the start of "method_one()".
Using "3[m" will jump to the start of the class.

                        *[#*
[#          go to [count] previous unmatched "#if" or "#else".
            |exclusive| motion. {not in Vi}

                        *]#*
]#          go to [count] next unmatched "#else" or "#endif".
            |exclusive| motion. {not in Vi}

These two commands work in C programs that contain #if/#else/#endif
constructs.  It brings you to the start or end of the #if/#else/#endif where
the current line is included.  You can then use "%" to go to the matching line.

                        *[star* *[/*
[*  or  [/      go to [count] previous start of a C comment "/*".
            |exclusive| motion. {not in Vi}

                        *]star* *]/*
]*  or  ]/      go to [count] next end of a C comment "*/".
            |exclusive| motion. {not in Vi}




tags
    Vim will read a 'tags' file automatically

    g] - list matching tags (évite de devoir faire C-] puis répéter :tn et :tp)

    :tag _initInputField - jump the function definition of _initInputField
    :tag /placeholder - jump to tag matching the text 'placeholder'

    :ptag placeholderUrl - open tag in preview window
    :tselect afterSave - select from multiple matching tags
    :tjump url - jump to unique tag, or list non-unique ones

external command
    :%! markdown - filter buffer via the external 'markdown' command
    :%! tidy - filter buffer via html tidy
    :!wc % - word count

filename
    use a % sign on the command line to denote the current file
    :! echo %

    :! markdown % > %:p:r.html

search and replace

    :%s/<br>\n<br>/\r<\/p>\r<p>/g - replace br with p

    :color - show current colorscheme

:%TOhtml - generate HTML page that looks like the current view

buffers

    :bdel galleries <Ctrl-a> - complete all matches

fileformat
    :set ff? - show fileformat

    convert in current buffer
        :setlocal ff=unix
        :w
======================

8. Views and Sessions                   *views-sessions*

This is introduced in sections |21.4| and |21.5| of the user manual.

                        *View* *view-file*
A View is a collection of settings that apply to one window.  You can save a
View and when you restore it later, the text is displayed in the same way.
The options and mappings in this window will also be restored, so that you can
continue editing like when the View was saved.

                        *Session* *session-file*
A Session keeps the Views for all windows, plus the global settings.  You can
save a Session and when you restore it later the window layout looks the same.
You can use a Session to quickly switch between different projects,
automatically loading the files you were last working on in that project.

Views and Sessions are a nice addition to viminfo-files, which are used to
remember information for all Views and Sessions together |viminfo-file|.

You can quickly start editing with a previously saved View or Session with the
|-S| argument: >
    vim -S Session.vim
<
All this is {not in Vi} and {not available when compiled without the
|+mksession| feature}.

                            *:mks* *:mksession*
:mks[ession][!] [file]  Write a Vim script that restores the current editing
            session.
            When [!] is included an existing file is overwritten.
            When [file] is omitted "Session.vim" is used.

The output of ":mksession" is like ":mkvimrc", but additional commands are
added to the file.  Which ones depends on the 'sessionoptions' option.  The
resulting file, when executed with a ":source" command:
1. Restores global mappings and options, if 'sessionoptions' contains
   "options".  Script-local mappings will not be written.
2. Restores global variables that start with an uppercase letter and contain
   at least one lowercase letter, if 'sessionoptions' contains "globals".
3. Unloads all currently loaded buffers.
4. Restores the current directory if 'sessionoptions' contains "curdir", or
   sets the current directory to where the Session file is if 'sessionoptions'
   contains "sesdir".
5. Restores GUI Vim window position, if 'sessionoptions' contains "winpos".
6. Restores screen size, if 'sessionoptions' contains "resize".
7. Reloads the buffer list, with the last cursor positions.  If
   'sessionoptions' contains "buffers" then all buffers are restored,
   including hidden and unloaded buffers.  Otherwise only buffers in windows
   are restored.
8. Restores all windows with the same layout.  If 'sessionoptions' contains
   "help", help windows are restored.  If 'sessionoptions' contains "blank",
   windows editing a buffer without a name will be restored.
   If 'sessionoptions' contains "winsize" and no (help/blank) windows were
   left out, the window sizes are restored (relative to the screen size).
   Otherwise, the windows are just given sensible sizes.
9. Restores the Views for all the windows, as with |:mkview|.  But
   'sessionoptions' is used instead of 'viewoptions'.
10. If a file exists with the same name as the Session file, but ending in
   "x.vim" (for eXtra), executes that as well.  You can use *x.vim files to
   specify additional settings and actions associated with a given Session,
   such as creating menu items in the GUI version.

After restoring the Session, the full filename of your current Session is
available in the internal variable "v:this_session" |this_session-variable|.
An example mapping: >
  :nmap <F2> :wa<Bar>exe "mksession! " . v:this_session<CR>:so ~/sessions/
This saves the current Session, and starts off the command to load another.

A session includes all tab pages, unless "tabpages" was removed from
'sessionoptions'. |tab-page|

The |SessionLoadPost| autocmd event is triggered after a session file is
loaded/sourced.
                        *SessionLoad-variable*
While the session file is loading the SessionLoad global variable is set to 1.
Plugins can use this to postpone some work until the SessionLoadPost event is
triggered.

                            *:mkvie* *:mkview*

http://vim.wikia.com/wiki/Make_views_automatic

:mkview[!] [file] écrit un fichier vimscript qui une fois sourcé restaure le contenu de la fenêtre courante.
Le bang sert à écraser [file] s'il existe déjà.
Si [file] est omis, la sauvegarde se fait dans un fichier au nom aléatoire dans le dossier ~/.vim/view (valeur de 'viewdir').

La sortie de :mkview contient:
* l'arglist utilisée par la fenêtre ainsi que l'index de l'argument courant (dernier buffer de l'arglist ayant été affiché).
* le fichier affiché dans la fenêtre
* abréviations, mappings et options locales à la fenêtre et au buffer si l'option 'viewoptions' contient la valeur options
  ou localoptions
* les plis créés par la méthode manuelle si 'viewoptions' contient la valeur folds
* la position du curseur
* le working directory local s'il est différent du working directory global
*
NOTE: les sessions et les views ont plusieurs défauts:
* elles ne restaurent pas



Note that Views and Sessions are not perfect:
- They don't restore everything.  For example, defined functions, autocommands
  and ":syntax on" are not included.  Things like register contents and
  command line history are in viminfo, not in Sessions or Views.
- Global option values are only set when they differ from the default value.
  When the current value is not the default value, loading a Session will not
  set it back to the default value.  Local options will be set back to the
  default value though.
- Existing mappings will be overwritten without warning.  An existing mapping
  may cause an error for ambiguity.
- When storing manual folds and when storing manually opened/closed folds,
  changes in the file between saving and loading the view will mess it up.

                            *:lo* *:loadview*
:lo[adview] [nr]    Load the view for the current file.  When [nr] is
            omitted, the view stored with ":mkview" is loaded.
            When [nr] is specified, the view stored with ":mkview
            [nr]" is loaded.

The combination of ":mkview" and ":loadview" can be used to store up to ten
different views of a file.  These are remembered in the directory specified
with the 'viewdir' option.  The views are stored using the file name.  If a
file is renamed or accessed through a (symbolic) link the view will not be
found.

You might want to clean up your 'viewdir' directory now and then.

To automatically save and restore views for *.c files: >
    au BufWinLeave *.c mkview
    au BufWinEnter *.c sil loadview

======================
'binary'

http://vim.wikia.com/wiki/VimTip1518


'fileformats' 'ffs'    (par défaut "unix,dos")    global

Cette option contient une liste de standards ("unix", "dos", "mac"), chacun déterminant à sa façon comment lire / écrire une fin de ligne <EOL>.
Vim teste différents standards jusqu'à en trouver un qui fonctionne pour le fichier qu'on veut éditer (:e)
(ou pour le fichier qu'on veut lire dans le buffer courant (:r)) et qui est présent dans 'ffs'.
Vim configure alors l'option 'fileformat' en lui donnant la valeur du standard trouvé.


'fileformat' 'ff'    (par défaut "unix")    local au buffer

Cette option détermine comment Vim lit / écrit une fin de ligne (<EOL>) pour le buffer courant.
dos  = <CR><LF>
unix = <LF>
mac  = <CR>

Elle est automatiquement configurée qd on édite un fichier si 'fileformats' est non vide et que 'binary' est désactivée.
Elle est considérée comme valant "unix" qd 'binary' est activée.


'binary' 'bin'    booléen (par défaut off)    local au buffer

Cette option devrait être activée avant d'éditer un fichier binaire.
Pour ce faire :    vim -b file    :e ++bin file
'set binary' est déconseillé car il affecte tous les fichiers édités (:setlocal ?).

Qd 'bin' est activée:

    - 'tw' = 'wrapmargin' = 'modeline' = 'expandtab' = 0
    - 'fileformat' et 'fileformats' sont ignorés
    - le fichier est lu et écrit comme si 'fileformat' = "unix", càd qu'une fin de ligne est considérée
      comme étant un <LF>
    - 'fileencoding' et 'fileencodings' sont ignorés, le fichier est lu sans conversion

Si on édite un autre fichier, ces options risquent d'être modifiées par des autocmd.
Pour cette raison, il est conseillé de réactiver l'option à nouveau qd on revient éditer le binaire.

Qd on désactive 'bin' les anciennes valeurs des options 'tw', 'wrapmargin', 'modeline' et 'expandtab' sont restaurés.


'fileencodings' 'fencs'    (par défaut: "ucs-bom,utf-8,default,latin1" qd 'encoding' = utf-8)    global

Qd Vim lit un fichier, il tente d'utiliser chaque encodage présent ds 'fencs' dans leur ordre d'apparition.
Qd il en trouve qui fonctionne, il configure la valeur de 'fileencoding' / 'fenc'.
Si tous les encodages de 'fencs' échouent, Vim donne à 'fenc' la valeur "", ce qui signifie qu'il utilisera la valeur
configurée par 'encoding'.

'fencs' est ignoré dans 3 cas de figure:

1- 'binary' est activé
2- le buffer a été chargé avec l'argument ++enc={encodage}
3- le buffer correspond à un nouveau fichier ('fenc' est utilisé)


    Note that 'fileencodings' is not used for a new file, the global value
    of 'fileencoding' is used instead.  You can set it with: >
        :setglobal fenc=iso-8859-2
<   This means that a non-existing file may get a different encoding than
    an empty file.
    The special value "ucs-bom" can be used to check for a Unicode BOM
    (Byte Order Mark) at the start of the file.  It must not be preceded
    by "utf-8" or another Unicode encoding for this to work properly.
    An entry for an 8-bit encoding (e.g., "latin1") should be the last,
    because Vim cannot detect an error, thus the encoding is always
    accepted.
    The special value "default" can be used for the encoding from the
    environment.  This is the default value for 'encoding'.  It is useful
    when 'encoding' is set to "utf-8" and your environment uses a
    non-latin1 encoding, such as Russian.
    When 'encoding' is "utf-8" and a file contains an illegal byte
    sequence it won't be recognized as UTF-8.  You can use the |8g8|
    command to find the illegal byte sequence.
    WRONG VALUES:           WHAT'S WRONG:
        latin1,utf-8        "latin1" will always be used
        utf-8,ucs-bom,latin1    BOM won't be recognized in an utf-8
                    file
        cp1250,latin1       "cp1250" will always be used
    If 'fileencodings' is empty, 'fileencoding' is not modified.
    See 'fileencoding' for the possible values.
    Setting this option does not have an effect until the next time a file
    is read.

                *'fileencoding'* *'fenc'* *E213*
'fileencoding' 'fenc'   string (default: "")
            local to buffer
            {only available when compiled with the |+multi_byte|
            feature}
            {not in Vi}
    Sets the character encoding for the file of this buffer.

    When 'fileencoding' is different from 'encoding', conversion will be
    done when writing the file.  For reading see below.
    When 'fileencoding' is empty, the same value as 'encoding' will be
    used (no conversion when reading or writing a file).
    Conversion will also be done when 'encoding' and 'fileencoding' are
    both a Unicode encoding and 'fileencoding' is not utf-8.  That's
    because internally Unicode is always stored as utf-8.
        WARNING: Conversion can cause loss of information!  When
        'encoding' is "utf-8" or another Unicode encoding, conversion
        is most likely done in a way that the reverse conversion
        results in the same text.  When 'encoding' is not "utf-8" some
        characters may be lost!

    See 'encoding' for the possible values.  Additionally, values may be
    specified that can be handled by the converter, see
    |mbyte-conversion|.

    When reading a file 'fileencoding' will be set from 'fileencodings'.
    To read a file in a certain encoding it won't work by setting
    'fileencoding', use the |++enc| argument.  One exception: when
    'fileencodings' is empty the value of 'fileencoding' is used.
    For a new file the global value of 'fileencoding' is used.

    Prepending "8bit-" and "2byte-" has no meaning here, they are ignored.
    When the option is set, the value is converted to lowercase.  Thus
    you can set it with uppercase values too.  '_' characters are
    replaced with '-'.  If a name is recognized from the list for
    'encoding', it is replaced by the standard name.  For example
    "ISO8859-2" becomes "iso-8859-2".

    When this option is set, after starting to edit a file, the 'modified'
    option is set, because the file would be different when written.

    Keep in mind that changing 'fenc' from a modeline happens
    AFTER the text has been read, thus it applies to when the file will be
    written.  If you do set 'fenc' in a modeline, you might want to set
    'nomodified' to avoid not being able to ":q".

======================
    :{range}pydo {func}

            remplace chaque ligne de {range} par la sortie de la fonction python définie par:

                `def _vim_pydo(line,linenr): {func}`

            Dans {func}, on peut se référer:

                    - au texte de la ligne à manipuler via l'argument line
                    - au n° de la ligne via l'argument linenr

            Tous les deux sont automatiquement passés à la fonction.

Cette commande est à développer en lisant:

        `:help python-buffer`

et

https://vi.stackexchange.com/questions/849/how-to-execute-python-statement-for-each-line

`:py3do`, `:perldo` et `:rubydo` sont des commandes similaires
À ceci près qu'il semble que pour `:perldo` et `:rubydo` on se réfère à la ligne courante via l'expression `$_`.
Ex:
>
    perldo $_  = {instruction perl}     remplace
    perldo $_ += {instruction perl}     append

======================
input()

input({prompt} [, {text} [, {completion}]])     *input()*

        Example: >

            if input('Coffee or beer? ') == 'beer'
               echo 'Cheers!'
            endif
<
        If the optional {text} argument is present and not empty, this
        is used for the default reply, as if the user typed this.
        Example: >

            let color = input('Color? ', 'white')

<       The optional {completion} argument specifies the type of
        completion supported for the input.  Without it completion is
        not performed.  The supported completion types are the same as
        that can be supplied to a user-defined command using the
        `-complete=` argument.  Refer to |:command-completion| for
        more information.  Example: >

            let fname = input('File: ', '', 'file')
<
        Note: When input() is called from within a mapping it will
        consume remaining characters from that mapping, because a
        mapping is handled like the characters were typed.

        Use |inputsave()| before input() and |inputrestore()|
        after input() to avoid that.  Another solution is to avoid
        that further characters follow in the mapping, e.g., by using
        |:execute| or |:normal|.

        Example with a mapping: >

            nmap \x :call GetFoo()<CR>:exe '/' . Foo<CR>
            fu GetFoo()
                call inputsave()
                let g:Foo = input('enter search pattern: ')
                call inputrestore()
            endfu
==============================================================================
------------------------------------------------------------------------------
==============================================================================
http://blog.owen.cymru/fzf-ripgrep-navigate-with-bash-faster-than-ever-before/

FZF & RipGrep - Navigate with bash faster than ever before
Posted on Feb 12, 2017

I've always had fzf  and ripgrep on my radar, and I've  finally gotten around to
using them together.  Good lord it makes a world  of difference, especially when
added to Vim as well as Bash.

Add the following snippet to your  ~/.bashrc, this add's fzf keybindings to bash
and gets fzf to use ripgrep by default for faster searching.

        [ -f ~/.fzf.bash ] && source ~/.fzf.bash
        export FZF_DEFAULT_COMMAND='rg --files --no-ignore --hidden --follow -g "!{.git,node_modules}/*" 2> /dev/null'
        export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
        bind -x '"\C-p": vim $(fzf);'

Okay now what can you do?

        Ctrl + r - search through bash history with fzf
        Ctrl + p - edit a file in vim from fzf
        mv dir/** - expand a directory with (**) and select from fzf
        Alt + c - change directory from fzf - see the update at the bottom for faster search with bfs.
        Ctrl + t - insert file from fzf into command

Neat right! Now if you are a vim user  there is more, add the fzf plugin to your
~/.vimrc,  along  with  this  snippet. Obviously  customise  the  bindings,  and
excludes / includes to your workflows!

        let g:rg_command = '
        \ rg --column --line-number --no-heading --fixed-strings --ignore-case --no-ignore --hidden --follow --color "always"
        \ -g "*.{js,json,php,md,styl,jade,html,config,py,cpp,c,go,hs,rb,conf}"
        \ -g "!{.git,node_modules,vendor}/*" '

        command! -bang -nargs=* F call fzf#vim#grep(g:rg_command .shellescape(<q-args>), 1, <bang>0)

You now have a  killer free text search with :F that uses  ripgrep and is faster
than any I've seen before.

I've done  more with this, but  want to leave it  there for now. There  are even
more goodies in my .vimrc, and in  my .bashrc, including auto installing fzf and
ripgrep (admittedly  hackily) from the .vimrc  and a nice snippet  that uses fzf
for git logs.

Update

Just made this nice snippet for tmux:

        tm() {
        local session
        newsession=${1:-new}
        session=$(tmux list-sessions -F "#{session_name}" | \
            fzf --query="$1" --select-1 --exit-0) &&
            tmux attach-session -t "$session" || tmux new-session -s $newsession
        }


        - tm with no sessions open it will create a session called "new".
        - tm irc it will attach to the irc session (if it exists), else it will create it.
        - tm with one session open, it will attach to that session.
        - tm with more than one session open it will let you select the session via fzf.

And here is a nice snippet for looking through git logs:

        fzf_log() {
        hash=$(git log --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |  fzf | awk '{print $1}')
        echo $hash | xclip
        git showtool $hash
        }

It will let you select a commit, and display the diff off it, and put the commit
hash on  your clipboard using xclip.  I also have it  set to use icdiff  via git
showtool.

Update update...

A few  people have  pointed out that  doing this doesn't  work for  fzf's Ctrl+T
completion or the Alt+C completion. Thanks  to @mikepqr, for letting me know the
work around for Ctrl+T. I have updated the configurations at the top of the post
with what he sent me.

Alt+C  has proved  a bit  tricky  to get  working  with ripgrep,  as rg  doesn't
natively support searching  just for directories. Instead I have  been using bfs
(https://github.com/tavianator/bfs) by adding the following to me config.

        export FZF_ALT_C_COMMAND="bfs -type d -nohidden"

After   a   bit   of   quick   testing    it   appears   to   run   faster   and
give   slightly  nicer   results   that  the   ripgrep   solutions  I've   tried
(https://github.com/BurntSushi/ripgrep/issues/388),   although   it  does   mean
installing another tool!


http://www.wezm.net/technical/2016/09/ripgrep-with-vim/

Set grepprg, which is  used by :grep to search a project and  add the matches to
the quickfix list:

        if executable("rg")
            set grepprg=rg\ --vimgrep\ --no-heading
            set grepformat=%f:%l:%c:%m,%f:%l:%m
        endif

For use with ack.vim set g:ackprg as follows.  Now when you run :Ack it will use
rg instead:

        let g:ackprg = 'rg --vimgrep --no-heading'

One of my favourite plugins, fzf.vim has built-in support for ag. I’ve created
an experimental fork that  adds support for rg to it. My fork  adds the :Rg user
command, which works the same way as the existing :Ag command. To use my version
of the plugin with vim-plug add the following to your .vimrc:

        Plug 'wezm/fzf.vim', { 'branch': 'rg' }

==============================================================================
VIM-EASY-ALIGN

Screencast:
https://raw.githubusercontent.com/junegunn/i/master/vim-easy-align.gif

https://raw.githubusercontent.com/junegunn/i/master/vim-easy-align-slow.gif

See {EXAMPLES.md}{9} for more examples.

        {9} https://github.com/junegunn/vim-easy-align/blob/master/EXAMPLES.md

==============================================================================
Voca

    délimiteur

            Une opération d'alignement peut être configurée via certaines options.

            Pour éviter de devoir reconfigurer ces options à chaque fois qu'on veut réaliser un même alignement,
            on peut associer un simple caractère à un ensemble prédéfini d'options.

            Ce caractère est appelé délimiteur. Par défaut, 8 délimiteurs sont définis:

                    espace
                    =
                    :
                    .
                    |
                    &
                    #
                    ,


    règle d'alignement

            L'association d'un ensemble d'options à un délimiteur est appelé règle d'alignement.
            On peut la voir comme un raccourci.
            Plutôt que d'écrire une regex, et de configurer plusieurs options, on peut se contenter
            de taper un simple caractère.


On peut utiliser le plugin en mode:

        - interactif via des mappings
        - non-interactif via des commandes Ex

        ----------------------+---------------+--------------------------------------------
        Mapping               | Mode          | Description                                         ~
        ----------------------+---------------+--------------------------------------------
        <Plug>(EasyAlign)     | normal/visual | lance mode interactif
        <Plug>(LiveEasyAlign) | normal/visual | lance mode interactif avec prévisualisation
        ----------------------+---------------+--------------------------------------------

        -------------------------------------------+-----------------------------------------
        Mode                                       | Commande                                       ~
        -------------------------------------------+-----------------------------------------
        interactif                                 | `:EasyAlign[!] [OPTIONS]`
        interactif avec prévisualisation           | `:LiveEasyAlign[!] […]`
        non-interactif (règles d'alignement)       | `:EasyAlign[!] [N-th] DELIMITER [OPTIONS]`
        non-interactif (regex)                     | `:EasyAlign[!] [N-th] /REGEX/ [OPTIONS]`
        -------------------------------------------+-----------------------------------------

NOTE:
Il est possible que par moment, l'aide de vim-easy-align explique qu'il faut appuyer sur Enter
en mode visuel alors qu'en réalité il faut appuyer sur `ga`.
En effet, l'aide suppose qu'on a installé le mapping suivant:

        xmap <Enter> <Plug>(EasyAlign)

Je ne l'ai pas installé, par souci de cohérence, `ga` en mode normal, `ga` en mode visuel.
De plus, Enter en mode visuel pourrait être utilisé pour autre chose…


Un alignement via un mapping se fait en 4 étapes:

        1. `ga` suivi d'un mouvement ou d'un text-object

        2. Optionnel: `Enter` pour alterner entre plusieurs modes d'alignement (gauche, droit, centre)

        3. Optionnel: N-ième délimiteur (défaut: 1)

                - `1` autour des 1e occurrences du délimiteur
                - `2` "          2e "
                - …
                - `*` autour de toutes les occurrences du délimiteur
                - `**` idem, mais en alternant de quel côté le texte situé entre 2 délimiteurs est aligné:

                        droite-gauche-droite-gauche …

                - `-` autour des dernières occurrences du délimiteur
                - `-2` "         avant-dernières "
                - …


        4. délimiteur (<Space>, `=`, `:`, `.`, `|`, `&`, `#`, `,`)


Règles d'alignement prédéfinies:

        -----------+-------------------------------------------------------------
        Délimiteur | Description / Exemples d'utilisation
        -----------+-------------------------------------------------------------
        <Space>    | alignement autour de whitespaces
                   |
        =          | "                 d'opérateurs d'affectation / test tq:
                   |
                   |         =
                   |         ==
                   |         !=
                   |         +=
                   |         &&=
                   |
        #          | utile pour aligner des commentaires shell / Python
        "          | "                                   Vim
                   |
        <Bar>      | "                                   tableau Markdown
        &          | tableaux LaTeX (match  `&`  and  `\\` )
                   |
        :          | utile pour formater du code JSON ou YAML
        .          | "          un chaînage de méthode multi-ligne (ex: foo.bar.baz.qux ???)
        ,          | "          des arguments d'une méthode multi-ligne
        -----------+-------------------------------------------------------------

On peut redéfinir ces règles d'alignement par défaut ou créer les nôtres via la variable `g:easy_align_delimiters`.


Exemples en mode visuel:

        ------------------+-------------------------------------------------+------------------------
        Touches           | Description                                     | Commande Ex équivalente
        ------------------+-------------------------------------------------+------------------------
        Enter Space       | autour des 1ers whitespaces                     | :*EasyAlign\
        Enter 2 Space     | "          2e   "                               | :*EasyAlign2\
        Enter - Space     | "          derniers "                           | :*EasyAlign-\
        Enter -2 Space    | "          avant-avant-derniers "               | :*EasyAlign-2\
        Enter :           | "          premiers double-points (`key:  value`) | :*EasyAlign:
        Enter Right :     | "                                 (`key : value`) | :*EasyAlign:<l1
        Enter   =         | "          premiers opérateurs incluant =       | :*EasyAlign=
        Enter  3=         | "          3èmes    "                           | :*EasyAlign3=
        Enter  *=         | "          tous     "                           | :*EasyAlign*=
        Enter **=         | Left-right alternating around =                 | :*EasyAlign**=
        Enter Enter =     | Right alignment around 1st =                    | :*EasyAlign!=
        Enter Enter **=   | Right-left alternating around =                 | :*EasyAlign!**=
        ------------------+-------------------------------------------------+------------------------


Using regular expressions~

Instead of finishing the command with a predefined delimiter key, you can type
in a regular expression after `C-x`. For example, if you want to align text around all occurrences of numbers:

        - Enter
        - `*`
        - C-x
            - `[0-9]\+`


Alignment options in interactive mode~

While in interactive mode, you can set alignment options using special
shortcut keys listed below.
The meaning of each option will be described in the following sections.

------+------------------+---------------------------------------------------
Key   | Option           | Values                                            ~
------+------------------+---------------------------------------------------
C-f   | `filter`           | Input string ( `[gv]/.*/?` )
C-i   | `indentation`      | shallow, deep, none, keep
C-l   | `left_margin`      | Input number or string
C-r   | `right_margin`     | Input number or string
C-d   | `delimiter_align`  | left, center, right
C-u   | `ignore_unmatched` | 0, 1
C-g   | `ignore_groups`    | [], ["String'], ["Comment'], ["String', "Comment']
C-a   | `align`            | Input string ( `/[lrc]+\*{0,2}/` )
Left  | `stick_to_left`    | `{ 'stick_to_left': 1, 'left_margin': 0 }`
Right | `stick_to_left`    | `{ 'stick_to_left': 0, 'left_margin': 1 }`
Down  | `*_margin`         | `{ 'left_margin': 0, 'right_margin': 0 }`
------+------------------+---------------------------------------------------


< Live interactive mode >_____________________________________________________~

If you're performing a complex alignment where multiple options should be
carefully adjusted, try "live interactive mode" where you can preview the
result of the alignment on-the-fly as you type in.

Live interactive mode can be started with either `<Plug>(LiveEasyAlign)` map or
`:LiveEasyAlign` command. Or you can switch to live interactive mode while in
ordinary interactive mode by pressing `C-p`. (P for Preview)

In live interactive mode, you have to type in the same delimiter (or `C-x` on
regular expression) again to finalize the alignment. This allows you to
preview the result of the alignment and freely change the delimiter using
backspace key without leaving the interactive mode.


< Non-interactive mode >______________________________________________________~

Instead of starting interactive mode, you can use declarative, non-interactive
`:EasyAlign` command.
>
    " Using predefined alignment rules
    "   :EasyAlign[!] [N-th] DELIMITER_KEY [OPTIONS]
    :EasyAlign :
    :EasyAlign =
    :EasyAlign *=
    :EasyAlign 3\

    " Using arbitrary regular expressions
    "   :EasyAlign[!] [N-th] /REGEXP/ [OPTIONS]
    :EasyAlign /[:;]\+/
    :EasyAlign 2/[:;]\+/
    :EasyAlign */[:;]\+/
    :EasyAlign **/[:;]\+/
<
A command can end with alignment options, in Vim dictionary format.

 - `:EasyAlign * /[:;]\+/ { 'stick_to_left': 1, 'left_margin': 0 }`

`stick_to_left` of 1 means that the matched delimiter should be positioned
right next to the preceding token, and `left_margin` of 0 removes the margin
on the left. So we get:
>
    apple;: banana::   cake
    data;;  exchange:; format
<
Option names are fuzzy-matched, so you can write as follows:

 - `:EasyAlign * /[:;]\+/ { 'stl': 1, 'l': 0 }`

You can even omit spaces between the arguments, so concisely (or cryptically):

 - `:EasyAlign*/[:;]\+/{'s':1,'l':0}`

Nice. But let's make it even shorter. Option values can be written in shorthand notation.

 - `:EasyAlign*/[:;]\+/<l0`

The following table summarizes the shorthand notation.

        -----------------+-----------
        Option           | Expression
        -----------------+-----------
        filter           | [gv]/.*/
        left_margin      | l[0-9]+
        right_margin     | r[0-9]+
        stick_to_left    | `<`  or  `>`
        ignore_unmatched | iu[01]
        ignore_groups    | ig\[.*\]
        align            | a[lrc*]*
        delimiter_align  | d[lrc]
        indentation      | i[ksdn]
        -----------------+-----------

For your information, the same operation can be done in interactive mode as follows:

        - Enter
        - `*`
        - Left
        - C-x
        - `[:;]\+`


< Partial alignment in blockwise-visual mode >________________________________~

In blockwise-visual mode (`C-v`), EasyAlign command aligns only the selected
text in the block, instead of the whole lines in the range.

Consider the following case where you want to align text around `=>`
operators.
>
    my_hash = { :a => 1,
                :aa => 2,
                :aaa => 3 }
<
In non-blockwise visual mode (`v` / `V`), `Enter =` won't work since the
assignment operator in the first line gets in the way. So we instead enter
blockwise-visual mode (`C-v`), and select the text around`=>` operators, then press `Enter =`
>
    my_hash = { :a   => 1,
                :aa  => 2,
                :aaa => 3 }
<
However, in this case, we don't really need blockwise visual mode since the
same can be easily done using the negative N-th parameter: `Enter -=`

==============================================================================
List of options

-------------------+---------+-----------------------+--------------------------------------------------------
Option             | Type    | Default               | Description                                            ~
-------------------+---------+-----------------------+--------------------------------------------------------
 `filter`            | string  |                       | Line filtering expression:  `g/../`  or  `v/../`
 `left_margin`       | number  | 1                     | Number of spaces to attach before delimiter
 `left_margin`       | string  |  `' '`                  | String to attach before delimiter
 `right_margin`      | number  | 1                     | Number of spaces to attach after delimiter
 `right_margin`      | string  |  `' '`                  | String to attach after delimiter
 `stick_to_left`     | boolean | 0                     | Whether to position delimiter on the left-side
 `ignore_groups`     | list    | ["String', "Comment'] | Delimiters in these syntax highlight groups are ignored
 `ignore_unmatched`  | boolean | 1                     | Whether to ignore lines without matching delimiter
 `indentation`       | string  |  `k`                    | Indentation method (keep, deep, shallow, none)
 `delimiter_align`   | string  |  `r`                    | Determines how to align delimiters of different lengths
 `align`             | string  |  `l`                    | Alignment modes for multiple occurrences of delimiters
-------------------+---------+-----------------------+--------------------------------------------------------

There are 4 ways to set alignment options (from lowest precedence to highest):

        1. Some option values can be set with corresponding global variables
        2. Option values can be specified in the definition of each alignment rule
        3. Option values can be given as arguments to `:EasyAlign` command
        4. Option values can be set in interactive mode using special shortcut keys

------------------+--------------+-------------+------------------------------
Option name       | Shortcut key | Abbreviated | Global variable                ~
------------------+--------------+-------------+------------------------------
 `filter`           | C-f          | `[gv]/.*/`    |
 `left_margin`      | C-l          | `l[0-9]+`     |
 `right_margin`     | C-r          | `r[0-9]+`     |
 `stick_to_left`    | Left, Right  | `<`  or  `>`    |
 `ignore_groups`    | C-g          | `ig\[.*\]`    | `g:easy_align_ignore_groups`
 `ignore_unmatched` | C-u          | `iu[01]`      | `g:easy_align_ignore_unmatched`
 `indentation`      | C-i          | `i[ksdn]`     | `g:easy_align_indentation`
 `delimiter_align`  | C-d          | `d[lrc]`      | `g:easy_align_delimiter_align`
 `align`            | C-a          | `a[lrc*]*`    |
------------------+--------------+-------------+------------------------------


< Filtering lines >___________________________________________________________~

With `filter` option, you can align lines that only match or do not match a
given pattern. There are several ways to set the pattern.

        1. Press `C-f` in interactive mode and type in `g/pat/` or `v/pat/`
        2. In command-line, it can be written in dictionary format: `{'filter': 'g/pat/'}`
        3. Or in shorthand notation: `g/pat/` or `v/pat/`

(You don't need to escape "/'s in the regular expression)


Examples~
>
    " Start interactive mode with filter option set to g/hello/
    EasyAlign g/hello/

    " Start live interactive mode with filter option set to v/goodbye/
    LiveEasyAlign v/goodbye/

    " Align the lines with 'hi' around the first colons
    EasyAlign:g/hi/
<

< Ignoring delimiters in comments or strings >________________________________~

EasyAlign can be configured to ignore delimiters in certain syntax highlight
groups, such as code comments or strings. By default, delimiters that are
highlighted as code comments or strings are ignored.
>
    " Default:
    "   If a delimiter is in a highlight group whose name matches
    "   any of the followings, it will be ignored.
    let g:easy_align_ignore_groups = ['Comment', 'String']
<
For example, the following paragraph
>
    {
      # Quantity of apples: 1
      apple: 1,
      # Quantity of bananas: 2
      bananas: 2,
      # Quantity of grape:fruits: 3
      'grape:fruits': 3
    }
<
becomes as follows on `Enter`: (or `:EasyAlign:`)
>
    {
      # Quantity of apples: 1
      apple:          1,
      # Quantity of bananas: 2
      bananas:        2,
      # Quantity of grape:fruits: 3
      'grape:fruits': 3
    }
<
Naturally, this feature only works when syntax highlighting is enabled.

You can change the default rule by using one of these 4 methods.

        1. Press C-g in interactive mode to switch groups
        2. Define global `g:easy_align_ignore_groups` list
        3. Define a custom rule in `g:easy_align_delimiters` with `ignore_groups` option
        4. Provide `ignore_groups` option to `:EasyAlign` command. e.g. `:EasyAlign:ig[]`

For example if you set `ignore_groups` option to be an empty list, you get
>
    {
      # Quantity of apples:  1
      apple:                 1,
      # Quantity of bananas: 2
      bananas:               2,
      # Quantity of grape:   fruits: 3
      'grape:                fruits': 3
    }
<
If a pattern in `ignore_groups` is prepended by a `!`, it will have the
opposite meaning. For instance, if `ignore_groups` is given as `['!Comment']`,
delimiters that are not highlighted as Comment will be ignored during the
alignment.


< Ignoring unmatched lines >__________________________________________________~

`ignore_unmatched` option determines how EasyAlign command processes lines
that do not have N-th delimiter.

        1. In left-alignment mode, they are ignored

        2. In right or center-alignment mode, they are not ignored, and the last tokens
           from those lines are aligned as well as if there is an invisible trailing
           delimiter at the end of each line

        3. If `ignore_unmatched` is 1, they are ignored regardless of the alignment mode

        4. If `ignore_unmatched` is 0, they are not ignored regardless of the mode

Let's take an example. When we align the following code block around the (1st)
colons,
>
    {
      apple: proc {
        this_line_does_not_have_a_colon
      },
      bananas: 2,
      grapefruits: 3
    }
<
this is usually what we want.
>
    {
      apple:       proc {
        this_line_does_not_have_a_colon
      },
      bananas:     2,
      grapefruits: 3
    }
<
However, we can override this default behavior by setting `ignore_unmatched`
option to zero using one of the following methods.

        1. Press `C-u` in interactive mode to toggle `ignore_unmatched` option
        2. Set the global `g:easy_align_ignore_unmatched` variable to 0
        3. Define a custom alignment rule with `ignore_unmatched` option set to 0
        4. Provide `ignore_unmatched` option to `:EasyAlign` command. e.g. `:EasyAlign:iu0`

Then we get,
>
    {
      apple:                             proc {
        this_line_does_not_have_a_colon
      },
      bananas:                           2,
      grapefruits:                       3
    }
<

< Aligning delimiters of different lengths >__________________________________~

Global `g:easy_align_delimiter_align` option and rule-wise/command-wise
`delimiter_align` option determines how matched delimiters of different lengths are aligned.
>
    apple = 1
    banana += apple
    cake ||= banana
<
By default, delimiters are right-aligned as follows.
>
    apple    = 1
    banana  += apple
    cake   ||= banana
<
However, with `:EasyAlign=dl`, delimiters are left-aligned.
>
    apple  =   1
    banana +=  apple
    cake   ||= banana
<
And on `:EasyAlign=dc`, center-aligned.
>
    apple   =  1
    banana +=  apple
    cake   ||= banana
<
In interactive mode, you can change the option value with `C-d`.


< Adjusting indentation >_____________________________________________________~

By default :EasyAlign command keeps the original indentation of the lines. But
then again we have `indentation` option. See the following example.
>
    # Lines with different indentation
      apple = 1
        banana = 2
          cake = 3
            daisy = 4
         eggplant = 5

    # Default: _k_eep the original indentation
    #   :EasyAlign=
      apple       = 1
        banana    = 2
          cake    = 3
            daisy = 4
         eggplant = 5

    # Use the _s_hallowest indentation among the lines
    #   :EasyAlign=is
      apple    = 1
      banana   = 2
      cake     = 3
      daisy    = 4
      eggplant = 5

    # Use the _d_eepest indentation among the lines
    #   :EasyAlign=id
            apple    = 1
            banana   = 2
            cake     = 3
            daisy    = 4
            eggplant = 5

    # Indentation: _n_one
    #   :EasyAlign=in
    apple    = 1
    banana   = 2
    cake     = 3
    daisy    = 4
    eggplant = 5
<
In interactive mode, you can change the option value with `C-i`.


< Alignments over multiple occurrences of delimiters >________________________~

As stated above, 'N-th' parameter is used to target specific occurrences of
the delimiter when it appears multiple times in each line.

To recap:
>
    " Left-alignment around the FIRST occurrences of delimiters
    :EasyAlign =

    " Left-alignment around the SECOND occurrences of delimiters
    :EasyAlign 2=

    " Left-alignment around the LAST occurrences of delimiters
    :EasyAlign -=

    " Left-alignment around ALL occurrences of delimiters
    :EasyAlign *=

    " Left-right ALTERNATING alignment around all occurrences of delimiters
    :EasyAlign **=

    " Right-left ALTERNATING alignment around all occurrences of delimiters
    :EasyAlign! **=
<
In addition to these, you can fine-tune alignments over multiple occurrences
of the delimiters with "align' option.
The option can also be set in interactive mode with `C-a`.
>
    " Left alignment over the first two occurrences of delimiters
    :EasyAlign = { 'align': 'll' }

    " Right, left, center alignment over the 1st to 3rd occurrences of delimiters
    :EasyAlign = { 'a': 'rlc' }

    " Using shorthand notation
    :EasyAlign = arlc

    " Right, left, center alignment over the 2nd to 4th occurrences of delimiters
    :EasyAlign 2=arlc

    " (*) Repeating alignments (default: l, r, or c)
    "   Right, left, center, center, center, center, ...
    :EasyAlign *=arlc

    " (**) Alternating alignments (default: lr or rl)
    "   Right, left, center, right, left, center, ...
    :EasyAlign **=arlc

    " Right, left, center, center, center, ... repeating alignment
    " over the 3rd to the last occurrences of delimiters
    :EasyAlign 3=arlc*

    " Right, left, center, right, left, center, ... alternating alignment
    " over the 3rd to the last occurrences of delimiters
    :EasyAlign 3=arlc**
<

< Extending alignment rules >_________________________________________________~

Although the default rules should cover the most of the use cases, you can
extend the rules by setting a dictionary named `g:easy_align_delimiters`.

You may refer to the definitions of the default alignment rules {here}{7}.

{7} https://github.com/junegunn/vim-easy-align/blob/2.9.6/autoload/easy_align.vim#L32-L46


Examples~
>
    let g:easy_align_delimiters = {
    \ '>': { 'pattern': '>>\|=>\|>' },
    \ '/': {
    \     'pattern':         '//\+\|/\*\|\*/',
    \     'delimiter_align': 'l',
    \     'ignore_groups':   ['!Comment'] },
    \ ']': {
    \     'pattern':       '[[\]]',
    \     'left_margin':   0,
    \     'right_margin':  0,
    \     'stick_to_left': 0
    \   },
    \ ')': {
    \     'pattern':       '[()]',
    \     'left_margin':   0,
    \     'right_margin':  0,
    \     'stick_to_left': 0
    \   },
    \ 'd': {
    \     'pattern':      ' \(\S\+\s*[;=]\)\@=',
    \     'left_margin':  0,
    \     'right_margin': 0
    \   }
    \ }
<
==============================================================================
OTHER OPTIONS

< Disabling &foldmethod during alignment >____________________________________~

{It is reported}{8} that 'foldmethod' value of `expr` or `syntax` can
significantly slow down the alignment when editing a large, complex file with
many folds. To alleviate this issue, EasyAlign provides an option to
temporarily set 'foldmethod' to `manual` during the alignment task. In order
to enable this feature, set `g:easy_align_bypass_fold` switch to 1.
>
    let g:easy_align_bypass_fold = 1
<
                      {8} https://github.com/junegunn/vim-easy-align/issues/14


< Left/right/center mode switch in interactive mode >_________________________~

In interactive mode, you can choose the alignment mode you want by pressing
enter keys. The non-bang command, `:EasyAlign` starts in left-alignment mode
and changes to right and center mode as you press enter keys, while the bang
version first starts in right-alignment mode.

        - `:EasyAlign`
            - Left, Right, Center
        - `:EasyAlign!`
            - Right, Left, Center

If you do not prefer this default mode transition, you can define your own
settings as follows.
>
    let g:easy_align_interactive_modes = ['l', 'r']
    let g:easy_align_bang_interactive_modes = ['c', 'r']
<
