global !p
from snippet_helpers import *
endglobal

# global !p
# import px.snippets
# endglobal

# global !p
# # This function will jump to next placeholder when first is empty.
# def jump_to_second_when_first_is_empty(snip):
# 	if px.snippets.get_jumper_position(snip) == 1:
# 		if not px.snippets.get_jumper_text(snip):
# 			px.snippets.advance_jumper(snip)

# # This function will clean up first placeholder when this is empty.
# def clean_first_placeholder(snip):
# 	# Jumper is a helper for performing jumps in UltiSnips.
# 	px.snippets.make_jumper(snip)
# 	return

# 	if snip.tabstop == 2:
# 		line = snip.buffer[snip.cursor[0]]
# 		snip.buffer[snip.cursor[0]] = \
# 			line[:snip.tabstops[1].start[1]-2] + \
# 			line[snip.tabstops[1].end[1]+1:]
# 		snip.cursor.set(
# 			snip.cursor[0],
# 			snip.cursor[1] - 3,
# 		)
# endglobal

# FIXME:
# It's supposed to automatically jump to the 2nd tabstop
# if we empty the 1st.
# However, when we press Tab to jump from the 1st tabstop (non-empty)
# to the 2nd one, the 1st one is removed. Why?
#
# Update:
# We've fixed  the issue  by ending  `clean_first_placeholder()` earlier  (via a
# return statement).
# But why did the original code clean the 1st placeholder (unconditionally)?
# It should leave it like it was when we left it (empty or not).
#
#	  context "px.snippets.make_context(snip)"
#	  post_jump "clean_first_placeholder(snip)"
#	  snippet x "Description" b
#	  `!p jump_to_second_when_first_is_empty(snip)
#	  `func (${1:blah}) $2() {
#		$3
#	  }
#	  endsnippet



# TODO:
# Document all  of this,  in our notes  and when we  write global  python helper
# functions.
#
# List comprehension (python construct):
#
#     http://www.i-programmer.info/programming/python/3942-arrays-in-python.html?start=1
#
# Useful to understand the syntax of this statement:
#
#     opts = [ m[len(t):] for m in opts if m.startswith(t) ]
#              └────────┤ └───────────┤ └────────────────┤
#                       │             │                  └ but keep only the ones
#                       │             │                    which start with the text stored in `t`
#                       │             │
#                       │             └ make the variable `m` iterate over the values
#                       │               stored in the list `opts`
#                       │
#                       └ expression which will be evaluated with a range of values
#                         for `m` (`t` is fixed; it's passed as an argument to the
#                         surrounding function)
#
#                         the set of all the evaluations will populate the list `opts`
#
# Found in the last screencast of SirVer.
#
# Note that `opts` and `t` should probably be renamed `candidates` and `base`.
# To be consistent with how we write a completion function in Vim:
#
#     candidates = [ c[len(base):] for c in candidates if c.startswith(base) ]

# ?: {{{1

snippet ?: "(test ? expr1 : expr2)" im
($1 ? $2 : $3)
endsnippet

# abbrev {{{1

#                   ┌ text of 1st placeholder $1
#                ┌──┤
# `!p snip.rv = (t[1][0]).upper() + t[1][1:]`
#                     │                  └┤
#                     │                   └ remaining characters
#                     └ first character

snippet abbrev "uppercase abbreviation on command line" bm
cnorea <expr> <buffer> ${1:lhs}  getcmdtype() ==# ':' && getcmdline() ==# '$1'
\                                ?    '`!p snip.rv = (t[1][0]).upper() + t[1][1:]`'
\                                :    '$1'
endsnippet

# au {{{1

# Explanation of the mirror:{{{
#
#                 ┌ look for a space followed by a star,
#                 │ and capture it so that I can test whether the subpattern has been matched, via `?1`
#                 │
#                 │  ┌ OR, look for anything
#             ┌───┤ ┌┤
#		  ${2/( \*)|.*/(?1:: \*)/}
#                       └┤└┤└─┤
#                        │ │  └ otherwise, insert a space followed by a star
#                        │ │	(to leave the autocmd pattern unchanged)
#                        │ │
#                        │ └ replace its contents with nothing
#                        │   (SPC * SPC <buffer>  →  SPC <buffer>)
#                        │
#                        └ if the 1st capturing group is not empty (SPC *)
#}}}
# Also, from :h UltiSnips-replacement-string:{{{
#
#         Finally, the  replacement string can contain  conditional replacements
#         using the syntax (?123:foo:bar). This  reads as follows:
#
#             if the group 123 has matched, replace it with "foo", otherwise insert "bar"
#
#         "bar"  is  optional  and  if   not  provided  defaults  to  the  empty
#         string. This feature is  very powerful. It allows you  to add OPTIONAL
#         text into snippets.
#}}}

snippet au  "augroup ... autocmd block" bm
augroup ${1:augroup name}
	au!${2: * <buffer>}
	au ${3:BufWinEnter}${2/( \*)|.*/(?1:: \*)/} ${0:$VISUAL}
augroup END
endsnippet

# cfu {{{1

snippet cfu "Completion function for C-x C-u" bm
fu! s:${1:complete_strings}(findstart, base) abort
	if a:findstart
		return searchpos('${2:"}', 'bnW', line('.'))[1] - 1
	else
		let candidates = []
		${3:sil keepj keepp %s/".\\\{-1,\}"/\=add(candidates, submatch(0))/gne}
		return filter(candidates, {i,v -> stridx(v, a:arglead) == 0 })
	endif
endfu

${4:" make sure s:snr() is defined
}let &l:cfu = s:snr().'$1'
$0
endsnippet

# Why not using  v =~ '^'.a:arglead  ?{{{2
#
# To filter the candidates, we could write this condition:
#          v =~ '^'.a:arglead
#
# But instead, we write:
#          filter(candidates, { i,v -> stridx(v, a:arglead) == 0 })
#
# Because `a:arglead` could contain special characters.
# If there are, we don't want them to be interpreted by the regex engine.

# Is there a case-insensitive alternative?{{{2
#
# Yes:
#
#	  return empty(a:arglead)
#	  \?         candidates
#	  \:         filter(candidates, { i,v -> v[:strlen(a:arglead)-1] ==? a:arglead })
#                                                                      │
#                                                                      └ ignore case
#
# Why treating the case where `a:arglead` is an empty string separately?
#
# If `a:arglead` is empty, the test will fail for all candidates, and the completion
# function will not return anything. I don't want that. I want all candidates.
# MWE:
#
#                        ┌─ ''
#                        │
#          v[:strlen(a:arglead)-1]
#        → v[:-1]
#        → v
#          != a:arglead ('')


# conceal {{{1

# Why setting the priority of the match to 0 is important?{{{
#
# If the priority is greater, for some reason, any text matching the search register
# is concealed too.
#
# To reproduce the issue, start Vim with this minimal vimrc:
#
#	  let @/ = '\cconceal'
#	  set hlsearch
#	  setl cocu=nvc cole=1
#	  call matchadd('Conceal', '^.', 1, -1, {'conceal': 'x'})
#
# The text `conceal` will be wrongly concealed. Only the first character
# on every line should be.
#
# Here's a different, but related, issue:
#
#	  https://stackoverflow.com/a/24134318/8243465
#
# This link  explains that  the priorities  of syntax  highlighting, 'hlsearch',
# 'cursorline', and concealed characters, are fixed and cannot be overruled.
#}}}
snippet conceal "conceal using `matchadd()`" bm
setl cocu=nc cole=3
call matchadd('Conceal', ${2:'${1:pat}'}, 0, -1, {'conceal': '${3:x}'})
$0
endsnippet

# command {{{1

snippet com "command" bm
com! ${1:MyCmd} ${2:call s:my_function()}
$0
endsnippet

# doautocmd {{{1

snippet doautocmd "Create a hook to be able to register for callback" bm
if exists('#User#${1:PluginFuncPost}')
	doautocmd <nomodeline> User $1
endif
$0
endsnippet

# for {{{1

snippet for "for … in loop" bm
for $1 in $2
	${0:${VISUAL}}
endfor
endsnippet

# forkv {{{1

snippet forkv "for [key, value] in loop"
	for [$1,$2] in items($3)
		$0
	endfor
endsnippet

# fu {{{1

# How to trim whitespace automatically, when the visual selection contain empty lines?{{{
#
#		  post_expand "python code using snip.buffer" ?
#
# An issue was opened on the issue tracker:
#
#		  https://github.com/SirVer/ultisnips/issues/391
#
# The solution which was found was the `m` option. It doesn't work with
# the visual placeholder.
# Why? Is it a bug?
#}}}
post_expand "trim_ws(snip)"
snippet fu "function definition" bm
fu! ${1:`!v snippets#get_funcname()`${2:Func}}($3) abort
	${0:${VISUAL}}
endfu
endsnippet

# fu_comp {{{1

snippet fu_comp "Completion function for a custom command" bm
fu! ${1:completion_function}(arglead, _c, _p) abort
	let candidates = [ ${2:''} ]
	return join(candidates, "\n")
endfu
$0
endsnippet

# Is it necessary to filter the candidates?{{{2
#
# It depends on the attributes given to the command which invokes this function:
#
#	  • -complete=custom        Vim filters the candidates automatically
#	  • -complete=customlist    Vim doesn't

# guard {{{1

# snippet guard "script reload guard" bm
# 	if exists('${1:did_`vim_snippets#Filename()`}') || &cp${2: || version < 700}
# 		finish
# 	endif
# 	let $1 = 1${0}
# endsnippet

# guard_ftplugin {{{1

snippet guard_ftplugin "filetype plugin guard" bm
if exists('b:did_ftplugin')
	finish
endif
let b:did_ftplugin = 1

$0
endsnippet

# guard_plugin {{{1

snippet guard_plugin "plugin guard" bm
if exists('${2:g:`!v expand('%:p') =~# '/autoload/' ? 'auto' : ''`loaded_${1:`!v expand('%:p') =~# '/autoload/' ? substitute(matchstr(expand('%:p'), 'autoload/\zs.*\ze\.vim'), '/', '#', 'g') : expand('%:t:r')`}}')
	finish
endif
let $2 = 1
$0
endsnippet

# guard_syntax {{{1

snippet guard_syntax "guard for syntax file" bm
if exists('b:current_syntax')
	finish
endif

$0

let b:current_syntax = '$1'
endsnippet

# if {{{1

snippet if "if Condition" bm
if $1
	${0:${VISUAL}}
endif
endsnippet

# ife {{{1

snippet ife "if … else statement" bm
if $1
	${2:${VISUAL}}${5:
elseif $3
	$4}
else
	$0
endif
endsnippet

# map {{{1

snippet map "prototype mapping" bm
nno  `!v expand('%:p:h:t') ==# 'ftplugin' ? '<buffer><nowait><silent>' : '<silent>'`  ${1:cd}  :<c-u>call ${2:Func}()<cr>
endsnippet

# map_ft {{{1

snippet map_ft "mapping for ftplugin" bm
nno  <buffer><nowait><silent>  $0
endsnippet

# Rappels:
#
# Pour obtenir un quantificateur non-greedy, il faut le faire suivre de `?`.
#
# Dans la partie de remplacement d'une substitution, $1, $2 … correspondent aux
# groupes capturés.
#
# Ces différences par rapport aux regex VimL proviennent du fait qu'UltiSnips
# travaille avec des regex python.

# map_plug {{{1

snippet map_plug "plug mapping" bm
nmap  <unique>  ${1:lhs}  <plug>(${2:plugin_function})
nno  <silent>  <plug>($2)  :<c-u>call ${2/(.*?)_(.*)/$1#$2/}()<cr>
$0
endsnippet

# map_user {{{1

snippet map_user "Install user-respectful mappings" bm
if empty(mapcheck('${1:key}', '${3:mode}')) && !hasmapto('<plug>(${2:plugin_some_func})', '$3')
	$3map  <unique>  $1  <plug>($2)
endif
$3no  <silent>  <plug>($2)  :<c-u>call ${2/_/#/}()<cr>
$0
endsnippet

# op {{{1

snippet op "Custom Operator" bm
nno  <silent>  ${1:key}     :<c-u>set opfunc=${2:function name}<cr>g@
nno  <silent>  $1${1/.(.*)/$1/}    :<c-u>set opfunc=$2<bar>exe 'norm! '.v:count1.'g@_'<cr>
xno  <silent>  $1     :<c-u>call $2('vis')<cr>

com! -bar -range ${3:MyCom} call ${2/<(sid|SID)>/s:/}('Ex', <line1>, <line2>)

fu! ${2/<(sid|SID)>/s:/}(type, ...) abort
	let cb_save  = &cb
	let sel_save = &selection
	let reg_save = [ '"', getreg('"'), getregtype('"') ]
	try
		set cb-=unnamed cb-=unnamedplus
		set selection=inclusive

		if a:type ==# 'char'
			${4:sil norm! \`[v\`]y}
		elseif a:type ==# 'line'
			${5:sil norm! '[V']y}
		elseif a:type ==# 'block'
			${6:sil exe "norm! \`[\<c-v>\`]y"}
		elseif a:type ==# 'vis'
			${7:sil norm! gvy}
		${8:elseif a:type ==# 'Ex'
			${9:sil exe a:1.','.a:2.'y'}}
		else
			return
		endif
	catch
		return lg#catch_error()
	finally
		let &cb  = cb_save
		let &sel = sel_save
		call call('setreg', reg_save)
	endtry

	$0
endfu
endsnippet

# printf {{{1

snippet printf "execute printf()" m
exe printf('$1', $0)
endsnippet

# qf_title {{{1

snippet qf_title "set the title of the qf window"
call setqflist([], 'a', {'title': '${1:my title}'})
$0
endsnippet

# Alternative:
#	  let w:quickfix_title = '$1'
#
# Works, but only if we're inside the qf window.
#
# The previous syntax is a bit more complex, but also more flexible.
# It allows us to set the title even outside the qf window, for example inside
# a function which is building the qf list.

# reg_restore {{{1

snippet reg_restore "Restore the contents and type of registers" bm
call setreg('${1:z}', $1_reg, $1_type)
$0
endsnippet

# reg_save {{{1

snippet reg_save "Temporarily save the contents and type of registers" bm
let [ ${1:z}_reg, $1_type ] = [ getreg('$1'), getregtype('$1') ]
$0
endsnippet

# sidebar {{{1

snippet sidebar "sidebar" bm

vnew | exe 'vert resize '.(&columns/3)
setl bh=wipe bt=nofile nobl nowrap noswf

if !bufexists('${1:buffer name}') | sil file ${1/ /\\ /g} | endif

sil 0put =${2:put your text}
sil $d_

nno  <buffer><nowait><silent>  q  :<c-u>close<cr>
setl noma ro

$0
endsnippet

# snr {{{1

snippet snr "Function to get SNR number" bm
fu! s:snr()
	return matchstr(expand('<sfile>'), '<SNR>\d\+_')
endfu
$0
endsnippet

# We can call a script-local function:
#
#		  with `s:`     in its script
#		  with `<sid>`  in a mapping
#
# But there's no built-in way to call it outside of its script/mapping.
# `s:snr()` to the rescue.
#
# NOTE:
# We can't write `expand('<sfile>')` outside the function.
# It would give us the path to the script file, while we want the name
# of the function.

# timer {{{1

snippet timer "immediate timer" m
call timer_start(0, {-> ${1:execute('${3:${VISUAL}}'${2:, ''})}})
$0
endsnippet

# try {{{1

snippet try "try ... catch statement" bm
try
	${1:${VISUAL}}

${4:catch ${2:/^Vim\%((\a\+)\)\?:E123/}
	${3:echohl ErrorMsg
	echo v:exception
	echohl NONE}}

finally
	$0
endtry
endsnippet

# undo {{{1

snippet undo_inde "undo indent settings" bm
" teardown {{ {1

let b:undo_indent =         get(b:, 'undo_indent', '')
\                   .(empty(get(b:, 'undo_indent', '')) ? '' : '|')
\                   .'setl ${1:indk}<'
$0
endsnippet

# If there are  autocmds, do NOT delete their augroup. Even  if the autocmds for
# the current buffer are no longer relevant, and should be removed, that doesn't
# mean that  the augroup is empty. There  could still be other  buffers with the
# same filetype, using autocmds in this augroup.
snippet undo_ft "undo ftplugin settings" bm
" teardown {{ {1

let b:undo_ftplugin =         get(b:, 'undo_ftplugin', '')
\                     .(empty(get(b:, 'undo_ftplugin', '')) ? '' : '|')
\                     ."${1:
\                          setl ${2:option}<}${3:
\                        | unlet! b:${4:variable}}${5:
\                        | exe 'au! ${6:group_name} * <buffer>'}${7:
\                        | exe '${8:n}unmap <buffer> ${9:lhs}'}${10:
\                        | exe '${11:c}una   <buffer> ${12:lhs}'}${13:
\                        | delc ${14:Cmd}}
\                      "
$0
endsnippet

# FIXME:
# when you expand this snippet, if you remove the `setl` line,
# make sure to remove the first pipe on the next line.
# Otherwise, the value of `b:undo_ftplugin` may begin with a pipe:
#
#     | some commands
#
# The empty command before the pipe may have unexpected effect.
# MWE:
#		:|echo 'hello'
#		    → prints current line, then echo 'hello'
#
# Update:
# We could use this:
#
#	  `!p snip.rv = ' ' if t[1] == '' else '|'`
#
# But what if we remove `:setl …` and `:unlet! …`.
# And what if we remove `:setl …`, and `:unlet! …`, and `:exe 'au! …'`.
# …

# vim_plug {{{1

snippet vim_plug "Vim-Plug Plugin definition" bm
Plug '$0'
endsnippet

# vimrc_mini {{{1

# Adding `…/plugin/after` is only necessary if the plugin we want to test
# has something inside an `after/` subdirectory.
# If we don't add it, none of its file will be sourced.
snippet vimrc_mini "Minimal vimrc to test a plugin" bm
set rtp+=~/.vim/plugged/vim-lg-lib/
set rtp+=~/.vim/plugged/vim-readline/
set rtp+=${1:path/to/plugin/}${2:
set rtp+=${1/$/after/}}
filetype plugin indent on
syntax enable
set wildmenu showcmd
$0
endsnippet

# wh {{{1

snippet wh "while loop" bm
while $1
	${0:${VISUAL}}
endwhile
endsnippet

# win_loc_op {{{1

snippet win_loc_op "autocmd to set window local options" bm
augroup my_${1:filetype}_window_local_options
	au! * <buffer>
	au BufWinEnter  <buffer>  ${2:setl fdm=marker}
	$0
augroup END
endsnippet
