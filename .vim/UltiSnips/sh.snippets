# To document:
#
#         `vim.current.window.cursor[0]` can be used to access the line number.
#         Is it equivalent to `snip.line`, or is there an offset?
#
#         You can expand a snippet from another one, programmatically.
#         To do so, you need a `post_expand` statement, or a `post_jump` one.
#
#         `post_expand`  works only  if the  first  tabstop is  right after  the
#         tab_trigger of the second snippet.
#
#         `post_jump` works  on the  condition that the  first tabstop  is right
#         after the tab_trigger  of the second snippet, and you  test the number
#         of the tabstop before trying to expand the snippet:
#
#                 post_jump "if snip.tabstop == 1: vim.eval('feedkeys(\"\<c-r>=UltiSnips#ExpandSnippet()\<cr>\")')"
#                            ├──────────────────┘
#                            └ check we're on the first tabstop,
#                              because we've positioned the tab_trigger
#                              right before
#
#         You could position the tab_trigger of the second snippet before any
#         tabstop, not just the first one, but then its expansion wouldn't be
#         completely automatic. You would have to jump to it.
#         There's no need for that with the first tabstop, because UltiSnips
#         automatically jumps to the first tabstop after expanding a snippet.
#
snippet pr "print debug"
printf 'XXXXXX `!p
snip.rv = "{}:{}: {}".format(
	os.path.basename(vim.current.window.buffer.name),
	str(vim.current.window.cursor[0]),
	t[1] + ": %q\\n' "
)
`$1 >&2
endsnippet

# post_jump "if snip.tabstop == 2: vim.eval('feedkeys(\"\<c-r>=UltiSnips#ExpandSnippet()\<cr>\")')"
post_expand "vim.eval('feedkeys(\"\<c-r>=UltiSnips#ExpandSnippet()\<cr>\")')"
snippet pd "Description" b
pr$1 >${2:/tmp/debug}
endsnippet

snippet foo ""
hello
endsnippet

post_expand "vim.eval('feedkeys(\"\<c-r>=UltiSnips#ExpandSnippet()\<cr>\")')"
snippet bar ""
foo$1 world
endsnippet



# #! {{{1

snippet #! "bash shebang" bm
#!/bin/bash
endsnippet

# Executing bash via:
#
#         #!/usr/bin/env bash
#
# … would make scripts more portable, but the Shell Style Guide from Google
# recommends to use `#!/bin/bash`, because it's more secure.
# We know exactly which binary is going to be executed.
# `#!/usr/bin/env bash` could execute another `bash` binary from a directory
# in the `PATH`, one which would be before `/bin/`.

# $ {{{1

snippet $ "value of var in assigment" i
"${$0}"
endsnippet

# case {{{1

snippet case "case condition" bm
case ${1:my_var} in
	${2:val1})
		${3:action 1}
		;;
	${3:val2})
		${4:action 2}
		;;
	${5:val3})
		${6:action3}
		exit 1
		;;
	*)
		${0:final action}
esac
endsnippet

# elvi {{{1

snippet elvi "Template to create a custom elvi for surfraw" bm
#!/bin/sh
#
# elvis: ${1:name of the site} 	-- Search ${2:what} using $1 (${3:url of the main page})
. surfraw || exit 1

w3_usage_hook () {
	cat <<EOF
Usage: $w3_argv0 [options] [search words]...
Description:
	Search $2 using $1 ($3)
EOF
	w3_global_usage
}

w3_config
w3_parse_args "$@"
if test -z "$w3_args"; then
	w3_browse_url "$3"
else
	escaped_args=\`w3_url_of_arg $w3_args\`
	w3_browse_url "${4:url to search a keyword}${escaped_args}"
fi
endsnippet

# for {{{1

snippet for "for ... in ... done" bm
for ${1:i} in ${2:words}; do
	${0:#statements}
done
endsnippet

# fu {{{1

snippet fu "function" bm
${1:my_func}() {
	${0:${VISUAL}}
}
endsnippet

# http://mywiki.wooledge.org/BashPitfalls#function_foo.28.29
#
#     foo() { … ; }             ✔ more portable
#     function foo { … ; }      ✔ resists to alias collision (alias foo=…)
#     function foo() { … ; }    ✘

# guard_root {{{1

# https://stackoverflow.com/a/18216122/8243465
snippet guard_root "check we've enough rights to run script" bm
if [ "$EUID" -ne 0 ]
	then echo "Please run as root"
	exit
fi
endsnippet

# if {{{1

snippet if "if … fi" bm
if [[ $1 ]]; then
	${0:${VISUAL}}
fi
endsnippet

# ife {{{1

snippet ife "if … else … fi" bm
if [[ $1 ]]; then
	${0:${VISUAL}}
else
fi
endsnippet

# log {{{1

snippet log "log output of script" bm
exec 3>&1 4>&2
[ -d ~/log ] || mkdir ~/log
exec 1>~/log/"\$(basename "\$0" .sh)".log 2>&1


endsnippet

# rgx_comp {{{1

snippet rgx_comp "test if pattern match string" bm
case "${1:string}" in
	${2:pat1|pat2}) $3 ;;
	*) $4 ;;
esac
endsnippet
# This syntax doesn't seem to handle complex regexes, but is POSIX, contrary to:
#     [[ "string" == "pattern" ]]
#
# For other valid syntaxes:
# https://stackoverflow.com/questions/21115121/how-to-check-pattern-match-by-using-bin-sh-not-by-bin-bash

# select {{{1

snippet select "select instruction" bm
echo -e "\n${1:Which action do you want to perform?}\n"

select ${2:action} in ${3:list of values}; do
	$0
done
endsnippet

# tmp {{{1

snippet tmp "create temporary file" bm
TMP="$(mktemp /tmp/.${1:pgm}.XXXXXXXXXX)"
$0
rm "${TMP}"
endsnippet
