" OPTIONS_1 {{{1
" Why this setting?{{{
"
" When we use gVim, we don't want `$VIMRUNTIME/menu.vim` to be sourced.
" We won't use the menu. It makes Vim start around 50ms slower.
" https://www.reddit.com/r/vim/comments/5l939k/recommendation_deinvim_as_a_plugin_manager/dbu74zd/
"
" The default value is 'aegimrLtT'.
" We could also let 'go' unchanged, and write this instead:
"
"         let did_install_default_menus = 1
"         let did_install_syntax_menu = 1
"
" In this case, we would keep the menu bar but avoid loading the default menus.
" For more info, see :h menu.vim
"}}}
" Why here, before the plugins, and not after, with the other options?{{{
"
" From `:h 'go-M`:
"
" Note that  this flag  must be added  in the .vimrc  file, before  switching on
" syntax  or filetype  recognition (…;  the  `:syntax on`  and `:filetype  on`
" commands load the menu too). `:filetype on` and `:syntax on` source menu.vim.
"}}}
set go=M

" PLUGINS {{{1
" Disable plugins {{{2

" :h netrw-noload
"     no interface
let g:loaded_netrwPlugin = 1
"     no autoload/
let g:loaded_netrw = 1

" I don't  want to  see `GLVS`  nor `GetLatestVimScripts`  when I  press Tab/C-d
" after the beginning of the name of a command.
let g:loaded_getscriptPlugin = 1

" Disable the Vimball plugin.
" Alternative:{{{
" These commands remove the interface of the Vimball plugin:
"
"     sil! delc MkVimball
"     sil! delc RmVimball
"     sil! delc UseVimball
"     sil! delc VimballList
"     sil! delc Vimuntar
"}}}
" interface
let g:loaded_vimballPlugin= 1
" autoload
let g:loaded_vimball      = 1

" vim-plug:  installation {{{2

" We install vim-plug if it's not already.
"
" To know whether vim-plug is installed or not, we check whether the file:
"
"        ~/.vim/autoload/plug.vim
"
" … exists.

if empty(glob('~/.vim/autoload/plug.vim'))
    sil !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
                \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    au VimEnter * PlugInstall | source $MYVIMRC
endif

" Disable shallow cloning.
"
" We want the full copy of a repo, to see all the commit history.
" Can be explored later with `:[Fz][B]Commits`.
" Useful to understand why a particular change was introduced in a plugin
" without having to go to github.    Cost more bandwidth though.

let g:plug_shallow = 0

" vim-plug:  usage  {{{2

" Plugins must be declared after this line.
" They will be downloaded inside `~/.vim/plugged/`.
call plug#begin('~/.vim/plugged')

com! -bar -nargs=1 PlugCfg
\        if has('vim_starting')
\|           so $HOME/.vim/autoload/plugin_conf/<args>.vim
\|       endif

" TO_STUDY:
Plug 'lacygoill/vim-graph'
" FIXME: {{{

" Type: :fu! Func() C-v C-j endfu
"
" Now try to uppercase a word with `cru`. `abolish` raises the error:
"     E705: Variable name conflicts with existing function: Func
"
" I've fixed the bug by renaming `Func` into `l:Func` inside the `s:send()`
" function of the abolish plugin.
"}}}
Plug 'tpope/vim-abolish', { 'frozen': 1 }
Plug 'yegappan/asyncmake', { 'frozen': 1 }
Plug 'lacygoill/vim-debug'
Plug 'justinmk/vim-dirvish'
Plug 'junegunn/vim-easy-align'
Plug 'tommcdo/vim-exchange' | PlugCfg exchange
Plug 'tpope/vim-fugitive'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim' | PlugCfg fzf
Plug 'junegunn/goyo.vim', { 'frozen': 1 }
Plug 'ludovicchabant/vim-gutentags'
Plug 'junegunn/limelight.vim', { 'frozen': 1 } | PlugCfg limelight
Plug 'djmoch/vim-makejob'
Plug 'lacygoill/vim-man'
Plug 'lacygoill/vim-markdown'
Plug 'lacygoill/vim-matchit'
Plug 'kana/vim-operator-user/', { 'frozen': 1 }
Plug 'lacygoill/potion'
Plug 't9md/vim-quickhl', { 'frozen': 1} | PlugCfg quickhl
Plug 'tpope/vim-repeat', { 'frozen': 1 }
Plug 'tpope/vim-rhubarb'
Plug 'lacygoill/vim-cwd'
Plug 'lacygoill/vim-schlepp', { 'frozen': 1 }
Plug 'junegunn/seoul256.vim'
Plug 'justinmk/vim-sneak' | PlugCfg sneak
Plug 'tpope/vim-speeddating'
Plug 'kana/vim-submode', { 'frozen': 1 }
Plug 'jebaum/vim-tmuxify', { 'frozen': 1 }
Plug 'SirVer/ultisnips' | PlugCfg ultisnips
Plug 'lacygoill/vim-unix'

" DONE:
Plug 'lacygoill/vim-awk'
Plug 'lacygoill/vim-brackets'
Plug 'lacygoill/vim-breakdown'
Plug 'lacygoill/vim-bullet-list'
Plug 'lacygoill/vim-capslock'
Plug 'lacygoill/vim-cmdline'
Plug 'lacygoill/vim-column-object'
Plug 'lacygoill/vim-comment'
Plug 'lacygoill/vim-completion'
Plug 'lacygoill/vim-conf'
Plug 'lacygoill/vim-draw'
Plug 'lacygoill/vim-fold'
Plug 'lacygoill/vim-freekeys'
Plug 'lacygoill/vim-help'
Plug 'lacygoill/vim-hydra'
Plug 'lacygoill/vim-iabbrev'
Plug 'lacygoill/vim-interactive-lists'
Plug 'lacygoill/vim-lg-lib'
Plug 'lacygoill/vim-logevents'
Plug 'lacygoill/vim-math'
Plug 'lacygoill/vim-python'
Plug 'lacygoill/vim-qf'
Plug 'lacygoill/vim-readline'
Plug 'lacygoill/vim-reorder'
Plug 'lacygoill/vim-save'
Plug 'lacygoill/vim-search'
Plug 'lacygoill/vim-session'
Plug 'lacygoill/vim-sh'
Plug 'lacygoill/vim-source'
Plug 'lacygoill/vim-stacktrace'
Plug 'lacygoill/vim-statusline'
Plug 'lacygoill/vim-term'
Plug 'lacygoill/vim-titlecase'
Plug 'lacygoill/vim-toggle-settings'
Plug 'lacygoill/vim-vim'
Plug 'lacygoill/vim-selection-ring'
Plug 'lervag/vimtex' | PlugCfg vimtex
Plug 'lacygoill/vim-latex'
Plug 'lacygoill/vim-window'

" DGAF:
Plug 'mattn/emmet-vim', { 'for' : ['html', 'css'] } | PlugCfg emmet
Plug 'machakann/vim-sandwich' | PlugCfg sandwich
Plug 'keith/tmux.vim'
Plug 'mbbill/undotree', { 'on': 'UndotreeShow' } | PlugCfg undotree
Plug 'chrisbra/unicode.vim'

delc PlugCfg

" Some plugins, or their configuration, take too much time to source during startup.
" We delay their loading
augroup lazy_load_plugins
    au!
    au VimEnter * call timer_start(1000, {->  execute('runtime  autoload/toggle_settings.vim
    \|                                                 runtime! autoload/plugin_conf/lazy_load/*.vim', '')
    \                                    })
    \|            exe 'au! lazy_load_plugins'
    \|            aug! lazy_load_plugins
augroup END
call plug#end()

" OPTIONS_2 {{{1
" ENCODING {{{2
" Why should you leave this section at the top of our options configurations.{{{
"
" If for some reason (shell environment), 'encoding' = 'latin1', and we use an
" exotic character in our vimrc, it will raise an error. As an example, see
" the value we give to 'listchars'.
" We need to make sure that Vim will use 'utf-8' as an encoding as soon as
" possible. Note that the real important option to avoid an error during
" startup, isn't 'termencoding', but 'encoding'.
"}}}

" Sets the character encoding used inside Vim.  It applies to text in
" the buffers, registers, Strings in expressions, text stored in the
" viminfo file, etc.  It sets the kind of characters which Vim can work
" with.
set encoding=utf-8

" To avoid errors, we could also write:
"         scriptencoding utf-8
"
" This would tell Vim to convert the following lines in `vimrc` to utf-8.
" But setting `encoding` seems to have a broader scope, and hence be better,
" as I want every file sourced after `vimrc` to be read using the `utf-8`
" encoding (ex: filetype plugins).

" Encoding used for the terminal.  This specifies what character
" encoding the keyboard produces and the display will understand.
set termencoding=utf-8

" FTPLUGINS + SYNTAX {{{2

" Commented because we don't need this anymore. `vim-plug` already does it for us.
" I keep this section in case it might be necessary if one day we change our plugin
" manager.
"
" From: https://github.com/junegunn/vim-plug/wiki/faq
"
"         vim-plug does not require any extra statement other than plug#begin()
"         and plug#end(). You can remove filetype off, filetype plugin indent on
"         and syntax on from your .vimrc as they are automatically handled by
"         plug#begin() and plug#end().
"
" https://github.com/junegunn/vim-plug/issues/83


" filetype plugin indent on


"        ┌─ from `:h syn_cmd`:         Only define colors for groups that don't have highlighting yet
"        │  from `:h syntax_loading`:  ":syntax enable" only sets groups that weren't set yet
"        │
" syntax enable
"        │
"        └─ :so $VIMRUNTIME/syntax/syntax.vim
"             → :so $VIMRUNTIME/syntax/nosyntax.vim                clear old syntax, and remove `b:current_syntax`
"                                                                  so, don't expect a guard:
"
"                                                                      if exists('b:current_syntax')
"                                                                          finish
"                                                                      endif
"
"                                                                   … to prevent a syntax plugin from being
"                                                                   re-sourced when you re-enable the syntax
"                                                                   highlighting mechanism
"
"
"             → :so $VIMRUNTIME/syntax/synload.vim
"
"                 → :so $VIMRUNTIME/syntax/syncolor.vim            setup the colors for syntax highlighting
"                                                                  answer the question “how do we color?
"
"                 → install autocmd listening to `Syntax *`
"                   which sources:
"                   :so syntax/{&ft}.vim                           setup the syntax
"                   :so syntax/{&ft}/*.vim                         answer the question “what do we color?“
"
"             → :so $VIMRUNTIME/filetype.vim                       filetype detection
"               installs autocmd to set 'filetype'
"
"             → install autocmd listening to `FileType *`          syntax detection
"               which sets the value of 'syntax'
"
"             → execute this autocmd for all buffers:
"                   doautoall syntaxset FileType
"                   set syntax=…
"                   Syntax event
"                   source syntax files


" `:syntax on` and `:syntax enable` both source the file:
"
"         $VIMRUNTIME/syntax/syncolor.vim
"
" The latter execute the custom commands `:SynColor` and `:SynLink`, which,
" depending on the argument passed to `:syn` (`enable` or `on`), are defined
" differently:
"
"         on:
"             command -nargs=* SynColor hi          <args>
"             command -nargs=* SynLink  hi link     <args>
"
"         enable:
"             command -nargs=* SynColor hi def      <args>
"             command -nargs=* SynLink  hi def link <args>
"
" We can see  that for `:syntax enable`,  the commands use `:hi  def` instead of
" just `:hi`. The `def` argument prevents that we override a HG which was linked
" to a syntax element by a colorscheme.

" If you enable syntax manually, use a guard:
"
"         if !exists('g:syntax_on')
"             syntax enable
"         endif
"
" … so that it's not enabled every time you re-source the vimrc.

" GUI {{{2

if has('vim_starting') && has('gui_running')
    set guifont=DejaVu\ Sans\ Mono\ 20
endif

" ENVIRONMENT "{{{2

" Used in our notes when we create links between files, in a wiki on a topic.
let $MY_WIKI = $HOME.'/Dropbox/wiki'

" backspace {{{2

" Allow BS, Del, C-w, C-u to delete:
"
"             ┌─ whitespace (autoindent)
"             │      ┌─ end of line (join line)
"             │      │   ┌─ text which was before the cursor when we went
"             │      │   │  into insert mode
"             │      │   │
set backspace=indent,eol,start

" clipboard {{{2
" Do NOT tweak this option!
" Why could you be tempted to change the value of this option?{{{
"
" When you use a pasting command,  and you don't specify from which register you
" want the text to be pulled, Vim uses the `"` register.
" So, if you want to copy some text from a Vim buffer to Firefox, you'll need to
" explicitly mention the name of the `+` register:
"
"         "+yy
"
" Same thing if you want to paste  in a Vim buffer, some text you've just copied
" in Firefox:
"
"         "+p
"
" It would be convenient to just press `yy` and `p`, and Vim would automatically
" use the system register, instead of the unnamed one.
" That's what 'cb' is for.
"}}}
" How should you change it?{{{
"
"         set clipboard^=unnamedplus
"
" 'cb' contains a comma-separated list of values. Each stands for a register.
" The previous command PREpends `unnamedplus` to this list.
" `unnamedplus` stands for the system register.
"
" Do NOT execute this:
"
"         set clipboard+=unnamedplus
"
" It would APpend the value to the list.
"}}}
" Technically, what happens if you do it?{{{
"
" The system  register register will  now have  a similar (although  not exactly
" identical) behavior than the one of the unnamed:
"
"     • it will contain the text of the last changed register (like `"`)
"
"     •  … except  if  the  last changed  register  was  changed by  a  command
"       containing its explicit name:
"
"               "ayy
"
"       This  is different from `"`,  which always copy  the text of the  last changed
"       register.
"
" If you copy some text in Firefox,  it goes into `+` (regardless of 'cb').  But
" because  of the  new value  of 'cb',  `p` will  automatically paste  `+` (last
" copied text in Firefox).
"
" If you copy  some text in a  Vim buffer, it goes into  `0`. The latter becomes
" the last modified register, and thus  `+` will duplicate its contents (because
" of 'cb').
"
" `"` will still  copy the text of the last changed register:
"
"     set cb^=unnamedplus | let [@+, @"] = ['foo', 'bar'] | norm! p
"           → foo
"
"     set cb&             | let [@+, @"] = ['foo', 'bar'] | norm! p
"           → bar
"}}}
" Are there pitfalls?{{{
"
" Yes a shitload.
"
" 1. It pollutes the system clipboard after every yank, delete, change.
" 2. It may break a plugin which forgets to temporarily reset 'cb' to its default value.
" 3. It may break a plugin, even if it temporarily resets 'cb'.
"
" Example:
" Consider a buffer, with just the text `pat`.
" Execute this command on the line where `pat` is:
"
"         norm ysiw'
"
" vim-surround should surround `pat` with single quotes.
" Undo, and execute:
"
"         g/pat/norm ysiw'
"
" Nothing happens. The issue:
"
"         • does NOT come the fact that vim-surround forgets to temporarily resets 'cb';
"           vim-surround does NOT forget it
"
"         • is fixed if you don't tweak 'cb' (set cb&vim)
"}}}
" colorscheme {{{2

" For more info about how creating a colorscheme:
"
"         $VIMRUNTIME/colors/README.txt:70
"
" In particular, the right way to set  the name of the current colorscheme is to
" include in the latter:
"
"         let g:colors_name = expand('<sfile>:t:r')


" ┌─────────────────────────────────────┬──────────────────────────────────────────────────────────────────┐
" │ g:seoul256_current_bg               │ Current background color in ANSI code                            │
" │ g:seoul256_current_fg               │ Current foreground color in ANSI code                            │
" │                                     │                                                                  │
" │                                     │         ┌ dark                                                   │
" │                                     │         │                ┌ light                                 │
" │                                     │ ┌───────┤        ┌───────┤                                       │
" │                                     │ 233 … 239        252 … 256                                       │
" ├─────────────────────────────────────┼──────────────────────────────────────────────────────────────────┤
" │ g:seoul256_background               │ value to be used the NEXT time we execute `:colo seoul256`       │
" │                                     │                                                                  │
" │                                     │         Valid values: 233 … 237 … 239                            │
" │                                     │                       │     │     │                              │
" │                                     │                       │     │     └─ lightest                    │
" │                                     │                       │     └─ default                           │
" │                                     │                       └─ darkest                                 │
" ├─────────────────────────────────────┼──────────────────────────────────────────────────────────────────┤
" │ g:seoul256_light_background         │ value to be used the NEXT time we execute `:colo seoul256-light` │
" │                                     │                                                                  │
" │                                     │         Valid values: 252 … 253 … 256                            │
" │                                     │                       │     │     │                              │
" │                                     │                       │     │     └─ lightest                    │
" │                                     │                       │     └─ default                           │
" │                                     │                       └─ darkest                                 │
" └─────────────────────────────────────┴──────────────────────────────────────────────────────────────────┘

augroup my_colorscheme
    au!

    " We delay the loading of the colorscheme until VimEnter.{{{
    " This solves 3 issues:
    "
    "         • gVim encounters some errors when trying to set up too early
    "           some of our custom HGs (~/.vim/colors/my/customizations.vim)
    "
    "         • loading the colorscheme directly from vimrc would mean
    "           that every time we write it, the colorscheme would be reloaded,
    "           which would make us lose syntax highlighting in a `freekeys` buffer
    "
    "           this could be solved with a guard though (if has('vim_starting'))
    "           but it shows that `VimEnter` is a good choice
    "
    "         • we want to memorize somewhere the last colorscheme we used
    "           (atm it's an ANSI code: 233 … 239, 252 … 256)
    "
    "           We can either use an arbitrary file or viminfo.
    "           An arbitrary file is cumbersome, so we prefer viminfo.
    "           However, when the vimrc is read, the viminfo hasn't been read yet
    "           (:h startup), so we must delay the loading of the colorscheme
    "           until VimEnter.
"}}}
    au VimEnter * nested call s:set_colorscheme()
    "             │
    "             └─ the autocmds need to nest, so that when we set the colorscheme,
    "                `ColorScheme` is fired, and our customizations are sourced

    au ColorScheme * runtime colors/my/customizations.vim

    au VimLeavePre * let g:MY_LAST_COLORSCHEME = get(g:, 'seoul256_current_bg', 253)
augroup END

fu! s:set_colorscheme() abort
    let seoul_256_background = get(g:, 'MY_LAST_COLORSCHEME', 253)

    if seoul_256_background >= 233 && seoul_256_background <= 239
        let g:seoul256_background = seoul_256_background
        colo seoul256
    else
        let g:seoul256_light_background = seoul_256_background
        colo seoul256-light
    endif

    " If `let g:seoul256_srgb` is set to 1, the color mapping is altered to suit
    " the way  urxvt (and various  other terminals) renders them. That  way, the
    " colors of the terminal and GUI versions are uniformly colored on Linux.
    "
    "         https://github.com/junegunn/seoul256.vim#alternate-256-xterm---srgb-mapping

    let g:seoul256_srgb = 1
endfu

" cmd  mode  ruler{{{2

" When we move the cursor (hjkl wbe …) and Vim consumes a lot of cpu / is slow,
" it can be for 2 reasons:
"
"         • we're inside a deep nested fold:  solution → open folds (zR)
"         • 'showcmd' is enabled:             solution → disable it

" Even though it can have an impact on performance, we enable 'showcmd',
" because sometimes it's useful to see what we type. Also, it's useful to see
" the number of lines inside the visual selection.
set showcmd


" When we're in normal mode, some information can be displayed in the bar
" which replaces the command-line:
"
"         • current mode                  don't want to see it
"         • normal command being typed    DO    want to see it

set noshowmode


" When 'stl' is empty, Vim displays the current line address, and column
" number, in the statusline.  This region is called the “ruler bar“ (:h ruler).
"
" Even though we should never see it, disable it explicitly.
set noruler

" cms {{{2

" Without the  guard, when  you reload  the vimrc, the  fold titles  display the
" comment leader.
if has('vim_starting')
    set cms=
endif

" cpoptions {{{2

" When I type `:r some_file` or `:'<,'>w some_file`, I don't want `some_file`
" to become the alternate file of the current window.
set cpo-=aA

" 'cpo' doesn't contain the M flag by default.
" It means that escaped parentheses are ignored when we hit ib
" (inside parentheses text-object)
" E.g.:
" if we hit dib while the cursor is on O in the following text:
"     (hello \(fOo) world)
" We get:
"     () world)
" For the moment, we prefer that Vim doesn't ignore escaped parentheses:

set cpo+=M

" So instead we get:
"     (hello \() world)

" What the `y` flag does?{{{
" It allows you to redo a yank command with the dot command:
"
"     set cpo+=y
"}}}
" Why you shouldn't add it to 'cpo'?{{{
"
" It breaks  the repetition of an  edition on a  set of selected lines  with the
" :normal and dot command:
"
"         set cpo+=y
"         A ) Esc
"         visually select lines
"         :norm .
"}}}

" display {{{2

" When the last line of the window doesn't fit on the screen, Vim replaces it
" with character @. We want Vim to show us as much text as possible from the
" last line and, only when there isn't anymore room, replace the remaining text
" with @.

set display+=lastline

" fillchars {{{2

" guard to prevent Vim from appending the value every time we source manually
" our vimrc
if has('vim_starting')
    " Replace ugly separators (`|`) used for vertical splits, with prettier utf8
    " characters, to get a continuous line.
    set fillchars=vert:┃

    " Pad end of title lines with spaces instead of dashes.
    exe 'set fillchars+=fold:\ '
    " For some reason, this doesn't work:
    "
    "         let &fillchars .= 'fold: '
endif

" folding {{{2

" When starting  to edit another buffer  in a window, always  start editing with
" all folds closed. Technically, this global option sets the initial local value
" of 'foldlevel' in any window.
set foldlevelstart=0

" do NOT open folds when jumping with "(", "{", "[[", "[{", etc.
set foldopen-=block

" Close a fold even if it doesn't contain any line.
" Useful in our faq notes.
set foldminlines=0

" formatting {{{2 
"
" `par` is an external formatting program, more powerful than Vim's internal
" formatting function. The latter has several drawbacks:
"
"     • it uses a greedy algorithm, which makes it fill a line as much as it
"       can, without caring about the discrepancies between the lengths of
"       several lines in a paragraph
"
"     • it doesn't handle well multi-line comments, (like /* */)
"
" So, when hitting `gq`, we want `par` to be invoked.

" By default, `par` reads the environment  variable `PARINIT` to set some of its
" options.  Its current value is set in `~/.shrc` like this:
"
"         rTbgqR B=.,?_A_a Q=_s>|

set formatprg=par\ -w80rjeq
"                   │  ││││
"                   │  │││└── handle nested quotations, often found in the
"                   │  │││    plain text version of an email
"                   │  │││
"                   │  ││└── delete (expel) superfluous lines from the output
"                   │  ││
"                   │  │└── justify the output so that all lines (except the last)
"                   │  │    have the same length, by inserting spaces between words
"                   │  │
"                   │  └── fill empty comment lines with spaces (e.g.: /*    */)
"                   │
"                   └── no line bigger than 80 characters in the output paragraph


" 'formatoptions' / 'fo' handles the automatic formatting of text.
"
" I  don't   use  them,  but  the   `c`  and  `t`  flags   control  whether  Vim
" auto-wrap  Comments (using  textwidth,  inserting the  current comment  leader
" automatically), and Text (using textwidth).


" if:
"     1. we're in normal mode, on a line longer than `&l:tw`
"     2. we switch to insert mode
"     3. we insert something at the end
"
" … don't break the line automatically
set fo=l

" When  joining  lines, don't  insert  a  space  before  or after  a  multi-byte
" character.  Overrules the 'B' flag.
"
"         foo‐    →    foo- bar    ✘
"         bar
"
"         foo‐    →    foo-bar     ✔
"         bar
set fo+=M

"       ┌─ insert comment leader after hitting o O in normal mode, from a commented line
"       │┌─ same thing when we hit Enter in insert mode
"       ││
set fo+=or

"       ┌─ don't break a line after a one-letter word
"       │┌─ where it makes sense, remove a comment leader when joining lines
"       ││
set fo+=1jnq
"         ││
"         │└─ allow formatting of comments with "gq"
"         └─ when formatting text, use 'flp' to recognize numbered lists

if has('vim_starting')
    augroup my_default_local_formatoptions
        au!
        " We've configured the global value of 'fo'.
        " Do the same for its local value in ANY filetype.
        au FileType * let &l:fo = &g:fo
    augroup END
endif

" :grep {{{2

" --vimgrep =
"
"         --column
"         --nocolor
"         --nogroup
"
" … and displays multiple matches on a single line

" Define `ag` as the program to call when using the Ex commands:
"         :[l]grep[add]

"                 ┌─ don't group all matches in a same file in a single result
"                 │  instead, prepend the filename in front of each match
"                 │
"                 │                                    ┌─ print column number
"                 │                                    │
set grepprg=ag\ --nogroup\ --nocolor\ --ignore-case\ --column\ --vimgrep\ -f\ --ignore\ mthesaur.txt
"                                                                │         │
"               when several matches are found on the same line, ┘         │
"               report each of them in a dedicated entry                   │
"               like the `g` flag for `:vimgrep`                           │
"                                                                          │
"                                                          follow symlinks ┘
"
"     Suppose we're looking for `pat` under current directory:
"             $ ag pat .
"
"     If `pat` is in `link`, which is a symlink pointing to the real file
"     outside the current directory, ag won't find it, unless we tell it to
"     follow symlinks.

" Define how the output of ag must be parsed:
"
"               ┌─ filename
"               │  ┌─ line nr
"               │  │  ┌─ column nr
"               │  │  │  ┌─ error message
"               │  │  │  │
set grepformat=%f:%l:%c:%m,%f:%l:%m
"   │
"   └─ default value:  %f:%l:%m,%f:%l%m,%f  %l%m

" hidden {{{2

" Hide buffers when they are abandoned

set hidden

" history {{{2

" Remember up to 1000 past commands / search patterns.
set history=1000

" invisible characters {{{2

" We define which symbol Vim must use to display certain symbols:
"
"     tab                       ▸
"     end of line               ¬
"     scroll unwrapped lines    » «
"     no-break space            ∅

set listchars=tab:▸\ ,eol:¬,precedes:«,extends:»,nbsp:∅

" includeexpr (gf) {{{2

fu! s:snr()
    return matchstr(expand('<sfile>'), '<SNR>\d\+_')
endfu

let &inex = s:snr().'inex()'

fu! s:inex() abort
    let line = getline('.')

    " Why?{{{
    "
    " If gf  fails to open the  file whose path  is under cursor, make  it retry
    " with the path after the equal sign.
    "
    " Useful because sometimes, we have something like:
    "
    "         set option=path
    "
    " And Vim tries to open 'option=path' instead of 'path'.
    "}}}
    if line =~# '='
        return substitute(v:fname, '.*=', '', '')
    endif

    return v:fname
endfu

" indentation {{{2

set autoindent

set expandtab


" Why don't we set 'ts'?{{{
"
" It would mess the alignment in help files, where tabs are used with a width of
" 8 cells. Besides, 'ts' is NOT used when 'expandtab' is set.
"}}}


" When we hit:
"
"        • {count}>>
"        • {count}<<
"        • >{motion}
"        • <{motion}
"
" … on indented lines, we want the new level of indentation to be a multiple of `&sw`.
" Ex:
" The current level of indentation is 2, and `&sw` is 4.
" We hit `>>`:
"
"         • without `shiftround`, the new indent becomes 6
"         • with    `shiftround`, the new indent becomes 4

set shiftround

"  Number of spaces added/removed when you hit:
"
"          • {count}>>
"          • {count}<<
"          • >{motion}
"          • <{motion}

set shiftwidth=4

" When we hit `Tab` or `BS` in front of a line, we want to add/remove
" `&sw` spaces (and not `&ts` or `&sts`).
set smarttab

" By default, (when `smarttab` is not enabled), 'sts' controls how many spaces
" are added/removed when we hit `Tab` or `BS`.
"
"               ┌─ disable 'sts'; use 'sw' instead
"               │
set softtabstop=-1

" The way we've configured 'smarttab' and 'sts', we can now modify how tabs
" are handled by Vim, in all contexts, with a single option:    'sw'

" is_bash {{{2

" By default, Vim uses the Bourne shell syntax.
" We prefer to use `bash`.
"
" Indeed, most of the time, we'll use `bash`, and some bash constructs don't exist
" in Bourne shell, like commands substitutions ($(…)). These bashisms are
" considered as errors if   b:current_syntax is# 'sh'
"
" For more info, read `:h sh.vim`.
let g:is_bash = 1

" It's not needed when a shell script has a shebang containing `bash`.
" But it's  useful when we've just  created a shell file,  because initially Vim
" may not  be able  to deduce the  right shelltype (no  typical filename  and no
" shebang yet).


" For more info, see this:
"
"         https://github.com/neovim/neovim/issues/5559
"         https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=848663

" join {{{2

" Don't insert two spaces after a '.', '?' and '!' with a join command.
set nojoinspaces

" kp {{{2

" When I press `K` on a keyword, use Vim's help by default.
set kp=:help

" lazyredraw {{{2
" What does it do?{{{
"
" Prevent the screen  from being redrawn while executing  commands which haven't
" been typed (e.g.: macros, registers). Also,  postpone the update of the window
" title.
"}}}
" Why do you set it?{{{
"
" • Because of the previous description.
"
" • Setting this option prevents the screen to “flash” when we use a custom
"   mapping which makes the cursor move far from its initial position, then
"   come back. Example:  zv  *
"
" • junegunn, tpope, justinmk, blueyed,  mhinz … they all  set this option.
"}}}
" Is there any pitfall?{{{
"
" Yes.
" Because  of this  option, sometimes,  we may  need to  execute `:redraw`  in a
" (function called by a) mapping.
"
" Example:    C-g j    (scroll-window; vim-submode)
"}}}
" TODO: Is 'lazyredraw' broken in Neovim?{{{
"
" In the past, I think it caused the  index message after a search to be weirdly
" displayed.
"
"         https://github.com/neovim/neovim/pull/6366#issuecomment-289273001
"
" Revisit this when the PR is merged.
"}}}
set lazyredraw

" match (showmatch / matchtime) {{{2

" Show matching brackets.

set showmatch

" If I have the following html buffer:
"
"     foobar
"     foo
"
" then type {}, C-b to go back inside the curly brackets, the cursor stays where
" it is. I have to hit C-b twice (or wait half a second, &matchtime).
" The pb comes from the fact that the cursor jumps to the opening bracket for
" &matchtime. So, I set this option to 0.
"
" FIXME: matchtime bug
"
" Why does the pb appear only in html file?
" And why only with curly brackets, and not with round / square brackets?
" Edit:
" It seems to happen  in any file… And it's not an  issue with 'matchtime' but
" with 'showmatch'.

set matchtime=0

" matchpairs {{{2

augroup my_matchpairs
    au!
    au FileType * setl mps+=“:”,‘:’
augroup END

" modelines {{{2

" If 'modeline' is set, and the value of 'modelines' is greater than 0, then Vim
" will search inside  the first/last `&mls` lines of the  buffer and execute any
" `:set` commands it finds.

" This allows easy file-specific configuration.
" But I don't like that, for security reason.

set nomodeline
set modelines=0

" mouse {{{2

" Enable mouse usage (all modes)

set mouse=a

" nrformats {{{2

" when using the `c-a` and `c-x` commands, don't treat the numbers as octla
" E.g.:
"         `c-a` on 007  →  010  ✘
"         `c-a` on 007  →  008  ✔
set nrformats-=octal

" path {{{2

" Where should `:find` and `gf` look for a file?
set path=.,**
"        │ │
"        │ └─ and in the working directory recursively
"        └─ look in the directory of the current buffer, non-recursively

" Its default value was:
"
"     .,/usr/include,,
"     │ │            │
"     │ │            └─ empty value = working directory
"     │ └─ /usr/include directory
"     └─ directory of the current buffer

" scroll {{{2

" display at least 3 lines above/below the cursor
set scrolloff=3

" display at least 3 columns before/after the cursor
" when scrolling horizontally an unwrapped long line
set sidescrolloff=3

" minimum nr of columns to scroll horizontally
set sidescroll=5

" shortmess {{{2

" don't give the "ATTENTION" message when an existing swap file is found
" If we've edited the current file in another Vim instance, the change will
" be noticed when CursorHold will be fired (custom autocmd).
"
" If we change the file before CursorHold, then try to save, Vim will warn us:
"
"     WARNING: The file has been changed since reading it!!!
"     Do you really want to write to it (y/n)?
"
" Answer no.
" Then, wait for CursorHold, or execute `:checktime`.
set shm+=A
" FIXME:
" But now, if Vim crashes, when we restart  it to edit the file we were editing,
" we won't have any error message.
" Assimilate the plugins dealing with swap files (session “swap”).
" We could tell Vim to echom a message letting us know that a swap file has been
" found, and make it automatically recover the file.
" Read `:h usr_11`.

" enable all sort of abbreviations
set shm+=a

" Don't give |ins-completion-menu| messages.  For example:
"
"     - "-- XXX completion (YYY)"
"     - "match 1 of 2"
"     - "The only match"
"     - "Pattern not found"
"     - "Back at original"
set shm+=c

" don't give the file info when editing a file, as if `:silent` was used
set shm+=F

" When starting Vim without any argument, we enter into an unnamed buffer
" displaying a long message; hide this message
set shm+=I

" don't give "search hit BOTTOM, continuing at TOP" message
set shm+=s

" don't give "written" or "[w]" when writing a file
set shm+=W

" signcolumn {{{2

" We want a margin between the left of the screen and the text.
set signcolumn=yes

" OLD WAY:
" sign define dummy
" augroup dummy_sign
"     au!
"     au BufReadPost * exe 'sign place 9999 line=1 name=dummy buffer=' . bufnr('%')
" augroup END

" startofline {{{2

" Some commands move the cursor to the first non-blank of the line:
"
"         c-d, c-u, c-b, c-f, G, H, M, L, gg, :123, :+    (motions)
"         dd, <<, >>                                      (operators)
"         c-^, :bnext, :bprevious
"
" I prefer the cursor to stay on the same column as before.
set nostartofline

" switchbuf {{{2
"         How to configure 'swb'?{{{

" You give it a list of values. Example:
"
"     set switchbuf=useopen,usetab
"}}}
"         What does it do?{{{

" If you  try to open a  split to display  a loaded buffer with  `:sbuffer`, Vim
" will first check  whether the buffer is  already displayed in a  window of the
" current tab page (`useopen`), or in another tab page (`usetab`).
" And if  it finds one,  instead of  creating a split,  it will simply  give the
" focus to this window.
"}}}
"         Which commands honor 'swb'?{{{

" |quickfix| commands, when jumping to errors (`:cc`, `:cn`, `cp`, etc.).
" All buffer related split commands: `:sbuffer`, `:sbnext`, `:sbrewind`…
"}}}
"         Are there pitfalls?{{{

" When we move in the qfl quickly, the focus can change from a window to another
" and it's distracting.
" Besides, once the focus has changed, if  we advance further in the qf list, it
" can make us lose the buffer which was opened in the window.
"
" When we press `C-w CR` on an entry of  the qfl, and the latter is present in a
" buffer which is already displayed somewhere else, Vim opens a split displaying
" an unnamed buffer.
"
" Why?
" Because FIRST it splits the window,  THEN checks whether the buffer to display
" is already displayed  somewhere else. When it finds one, it  changes the focus
" as expected, but it doesn't close the  split with the unnamed buffer (which is
" unexpected).
"
" MWE:
"     vim -Nu NONE -c 'set swb+=useopen' ~/.bashrc
"     :vim /./ % | copen
"     C-w CR
"}}}
"         Are there workarounds?{{{

" You could temporarily reset 'swb' while:
"
"         • the qf window is opened; in a qf filetype plugin:
"
"                   if !exists('s:swb_save')
"                       let s:swb_save = &swb
"                       set swb=
"                   endif
"
"                   au BufWinLeave <buffer> let &swb = get(s:, 'swb_save', &swb) | unlet! s:swb_save
"
"         • when you execute some commands / mappings
"
"           you would need to create wrapper around default normal commands
"           with a try conditional, and a finally clause, to empty 'swb'
"           and/or,
"           you would need to install an autocmd listening to CmdlineLeave,
"           to set 'swb' only when you use some Ex commands
"
" You could install unimpaired-like mappings to toggle the value of 'swb'.
"}}}
"         Why don't we set it?{{{
"
"     • Too many issues.
"     • I don't need it atm.
"     • To give the focus to an already displayed buffer, there are alternatives:
"
"           :FzWindows  (<space>fw)
"           :drop       (:drop ~/**/*some_file)
"}}}
" synmaxcol {{{2

" don't syntax-highlight long lines
set synmaxcol=250
"             │
"             └─ weight in bytes
"                any character prefixed by a string heavier than that
"                will NOT be syntax highlighted

" tags {{{2

" When searching the tags file, ignore the case unless an upper case letter is used.
set tagcase=smart

" What's the default value? {{{
"
"         ./tags,./TAGS,tags,TAGS
"
" Explanation:
"
"        ┌────────┬──────────────────────────────────────────────────────────────────┐
"        │ ./tags │ file in the directory of the CURRENT FILE and whose name is tags │
"        ├────────┼──────────────────────────────────────────────────────────────────┤
"        │ tags   │ file in the WORKING DIRECTORY             and whose name is tags │
"        └────────┴──────────────────────────────────────────────────────────────────┘
"}}}
" What's the effect of this new value?{{{
"
" We define a new value by adding a semicolon after `./tags`.
" `;` tells Vim to look UP recursively.
" It's the opposite of `**` which looks DOWN recursively.
" You could also include the value `tags;`:
"
"         set tags=./tags;,tags;
"
" Explanation:
"
"       ┌─────────┬──────────────────────────────────────────────────────────────┐
"       │ ./tags; │ file in the directory of the CURRENT FILE, then              │
"       │         │ in its parent directory, then in the parent of the parent    │
"       │         │ and so on, recursively                                       │
"       ├─────────┼──────────────────────────────────────────────────────────────┤
"       │ tags;   │ file in the WORKING DIRECTORY, then in its parent directory, │
"       │         │ then in the parent of the parent and so on, recursively      │
"       └─────────┴──────────────────────────────────────────────────────────────┘
"
" The value of 'tags' influence commands such as `:tj` and `:ltag`.
" But also, tag completion in insert mode.
" The completion function  invoked by `i_^x^]` looks for candidates  in the tags
" files whose path are stored in the value of 'tags'.
"}}}
set tags=./tags;
" Why could a command such as `:tj` or `:ltag` include some irrelevant tags? {{{
"
" It's probably due to the combination of two factors:
"
"         • vim-gutentags is enabled
"
"         • you have a tags file in a big directory containing many different
"           projects
"
"           For example,  you may have  executed `$ ctags  -R` by accident  in a
"           wrong directory, such as `~/.vim` or `~/.vim/plugged`.
"
"           Or maybe it  was executed by `vim-gutentags`  because you accidently
"           created  a git  repo (via  something like  `git {add|commit|push}`),
"           where you shouldn't have.
"
" `vim-gutentags` appends the global value  of 'tags' to the buffer-local value,
" for buffers inside a git repo.
"
" So, if `./tags;` and/or `tags;` is  inside the global value of 'tags', because
" of `vim-gutentags`, it will also be in the local value.
"
" And thus, when  you'll be working on a project,  like the `vim-session` plugin
" for example, here's the kind of local value that 'tags' will contain:
"
"         tags=~/.vim/plugged/vim-session/tags,./tags;,tags;
"                                                    ^     ^
"  Because  of  the semicolons,  Vim  may  include a  wrong  tags  file such  as
" `~/.vim/tags`. If that happens, you'll end up with way too many tags.
"}}}
" What to do if that happens? {{{
"
" 1. Try  to configure  `vim-gutentags` and  prevent it  from including  the
"    global value of 'tags' inside the local one.
"
" 2. Remove wrong tags files (`$ rm`), and make sure there's no `.git/`
"    directory outside a valid  repository.
"    Otherwise, `vim-gutentags` may recreate a tags file.
"}}}

" In our vimrc file, we want the ability to jump from the call of a function
" defined in `myfuncs.vim`, to its definition, with `C-]`.
augroup tags_vimrc
    au!
    au BufReadPost $HOME/.vim/vimrc setl tags=$HOME/.vim/autoload/tags
    " update the tags file whenever we write `myfuncs.vim`
    exe 'au BufWritePost '.resolve($HOME.'/.vim/autoload/myfuncs.vim')
    \.  ' sil! !ctags -f $HOME/.vim/autoload/tags $HOME/.vim/autoload/myfuncs.vim'
augroup END

" temporary files:  undo, swap, backup {{{2

" FIXME:
" Review all this section.
" Finish implementing proper backup.
" Read files in `backup` session.
"
" And read this:
"
"         https://www.zachpfeffer.com/single-post/Practice-Recovering-a-File-in-Vim
"
" TODO:
" Read this:
" https://vi.stackexchange.com/a/53/13370
" Add a cron job to delete temp files when they've been changed for a long time
" (3 months?).


" In neovim, there's no need to create directories for backup, undo, swap.
" The default value of the relevant options are set so that all the temp files
" are created inside `~/.local/share/nvim`.


if !isdirectory($HOME.'/.vim')
    call mkdir($HOME.'/.vim', '', 0770)
endif

" 'directory' ('dir') est une option dont la valeur est une suite de chemins
" séparés par des virgules.
" Quand on commence à éditer le fichier bar, et que Vim doit créer un fichier
" d'échange pour ce dernier (.bar.swp), il utilise le 1er dossier présent dans
" l'option 'dir' et dans lequel il peut écrire (existe + droits suffisants).
"
" La valeur par défaut de 'dir' est:
"         .,~/tmp,/var/tmp,/tmp
"
" Ça signifie que Vim crée le fichier d'échange dans le même dossier que bar.
" Le problème est que ça pollue le système de fichiers avec des fichiers
" d'échange un peu partout.
"
" On veut les confiner dans un dossier qui leur sera dédié, pex:
"         ~/.vim/tmp/swap
" Pour ce faire, on ajoute au début (^=) de 'dir' la valeur:
"         "$HOME/.vim/tmp/swap//"
"
" Pk un double slash à la fin ?
" Par défaut, le fichier d'échange créé s'appellera: .bar.swp
" Ceci peut poser pb, si on édite plusieurs fichiers bar dans des dossiers
" différents. Leurs fichiers d'échange auront tous le même nom.
" Le double backslash demande à Vim d'utiliser le chemin vers bar pour créer
" un nom de fichier d'échange unique:
" %path%to%.bar.swp
" Au passage, on remarque que les slashs séparant les dossiers du chemin vers
" bar sont remplacés par des %.
set directory=$HOME/.vim/tmp/swap//

" make sure the swap directory exists
if !isdirectory(&directory)
    call mkdir(&directory, 'p', 0700)
endif


" enable persistent undo
set undofile

" choose location of undo files
set undodir=$HOME/.vim/tmp/undo

" make sure the undo directory exists
if !isdirectory(&undodir)
    call mkdir(&undodir, 'p', 0700)
endif


" Why don't we enable 'backup'?{{{
"
" Because  of  a bug,  'backupdir'  doesn't  support  the correct  double  slash
" filename expansion: the  name of a backup  file contains only the  name of the
" original file, not its whole path. If you  edit 2 files with the same name, in
" 2 different directories, only the last one will have a backup (overwrite).
" See:
"     https://code.google.com/p/vim/issues/detail?id=179
"     https://stackoverflow.com/a/38479550/8243465
"}}}
set nobackup
" Future Workaround:{{{

" This is the workaround for the backup filename expansion problem.
augroup my_backup
    au!
    " au BufWritePre * call s:save_backups()
augroup END

fu! s:save_backups() abort
    for pat in split(&backupskip, ',')
        if expand('%:p') =~# pat | return | endif
    endfor

    " If this is a newly created file, don't try to create a backup
    if !filereadable(expand('%:p')) | return | endif

    for backupdir in split(&backupdir, ',')
        if s:save_backup(backupdir)
            break
        endif
    endfor
endfu

fu! s:save_backup(backupdir) abort
    let filename = expand('%:p')
    let backup = a:backupdir =~# '//$'
             \ ?     escape(substitute(filename, '/', '%', 'g').&backupext, '%')
             \ :     escape(expand('%').&backupext, '%')
    let backup_path = a:backupdir.backup
    sil! exe '!cp '.resolve(filename).' '.backup_path
    if v:shell_error
        " reset `v:shell_error`
        call system('')
        return 1
    endif
endfu
"}}}

" Vim peut créer parfois un fichier de backup qui correspond à une copie du
" fichier tq qu'il était avant qu'on ne l'édite.
" La création d'un fichier de backup est déterminée par plusieurs options
" (dont 'backup' et 'writebackup') et expliquée dans l'aide: :h backup-table
"
" Par défaut, le chemin du backup du fichier bar est:
"         ./.bar~
" L'emplacement des fichiers de backup est déterminé par l'option 'backupdir'
" / 'bdir'.
" On veut qu'ils soient tous confinés dans ~/.vim/tmp/backup
set backupdir=~/.vim/tmp/backup//

" make sure the backup directory exists
if !isdirectory(&backupdir)
    call mkdir(&backupdir, 'p', 0700)
endif

" termguicolors {{{2

" Enable true color when supported.

" My current version of urxvt and xfce4-terminal don't support true color.
"
" FIXME:
" We should use a whitelist, not a blacklist.
"
" Atm,  the  only  terminals  which  I  can  install  and  support  true  color,
" are  Konsole  and  gnome-terminal. I  know  how to  detect  Konsole,  but  not
" gnome-terminal (there's no environment variable we could inspect).
if $COLORTERM isnot# 'rxvt-xpm' && $COLORTERM isnot# 'xfce4-terminal'
    set termguicolors
    if !has('nvim')
        " In Vim, if `$TERM` is not  'xterm', Vim won't automatically set 't_8f'
        " nor 't_8b'.  We need to do it manually. See: :h xterm-true-color.
        let &t_8f = "\e[38;2;%lu;%lu;%lum"
        let &t_8b = "\e[48;2;%lu;%lu;%lum"
    endif
endif

" thesaurus {{{2

" It is possible to replace the word before the cursor by a synonym.
" To do that, we must hit in insert mode C-x C-t.
" This should make the popup menu appear.
" The menu should be populated with various synonyms for the word.
" The completion function looks for synonyms in all the files whose path
" is present in the option 'thesaurus'.
" Each line of the file must contain a group of synonyms separated by
" a character which is not in 'isk' (space or comma for example).
"
" We can download such a file at the following url:
"         https://archive.org/stream/mobythesauruslis03202gut/mthesaur.txt
"
" Otherwise, search the following query on google:
"         mthesaur.txt filetype:txt

set thesaurus+=$HOME/.vim/tools/mthesaur.txt

" timeout {{{2

" enable a timeout for mappings
set timeout

" same thing for keycodes
set ttimeout

" set the timeout for mappings to 3s
set timeoutlen=3000

" … and 6 ms for keycodes.
" Previously we used 50ms, but 6 is the max value to prevent this error:
"
"       1. insert sth wrong
"       2. hit escape
"       3. hit u (undo)    →    M-u: uppercase next word
set ttimeoutlen=6
" the lower the value, the less risk there is for keys manually typed to be
" interpreted as a keycode
"
" E.g.:
" When Vim receives `Esc` then `d`, it has to decide:
"
" does it mean “escape to normal mode“, then “hit the `d` operator“,
" or does it mean `M-d` (delete the next word)?
" If `d` came less than `&ttimeoutlen` ms after `Esc`, Vim will assume it's
" the keycode for `M-d`. Otherwise, it will think we've just manually hit
" `Esc` then `d`.


" Si on a créé un mapping qui à la séquence de touches (keycodes) a et b,
" associe une action, qd on appuiera sur a, Vim attendra un certain temps pour
" nous laisser taper b. Au-delà si l'option 'timeout' est activée, Vim
" exécutera l'action associée à la touche a.
" Cette durée est définie par l'option 'timeoutlen' qui par défaut vaut 1000.
"
" De la même façon, les touches de contrôle produisent souvent une séquence
" d'échappement / de keycodes.
" Pex, F1 produit escape + O + P, on peut vérifier via la commande shell: $ xxd p
"
" Ainsi quand on tape sur escape puis sur O, Vim attend un certain temps avant
" d'ouvrir une nouvelle ligne au-dessus de l'actuelle, pour laisser le temps
" au keycode associé à P d'arriver.
"
" Cette durée est définie par l'option 'ttimeoutlen' qui par défaut vaut -1,
" ce qui signifie qu'elle prend la même valeur que 'timeoutlen', à savoir 1000.
"
" Cette valeur pose pb car elle introduit un délai d'une seconde quand on
" appuie sur escape puis O. Pour résoudre ce pb, on configure 'timeoutlen' à
" 3000 (3s), pour se laisser du temps quand on tape nos mappings, et on
" configure 'ttimeoutlen' à 100 pour raccourcir le délai après un escape + O.
"
" Ça ne devrait pas poser de pb puisqu'aucun de nos mappings ne commence
" par cette séquence de keycodes, par contre il faudra faire attention.
" Dans une session Vim qui tourne sur une machine distante, le lag ou la charge
" de la machine pourrait nous empêcher d'utiliser correctement des touches de
" contrôle (F1, F2, flèches …).
" En effet, 100ms pourrait s'avérer insuffisant pour que l'un des keycodes qui
" compose la séquence arrive à temps.

" ttymouse {{{2

" Pour redimensionner les viewports à la souris, il faut que 'ttymouse' ait pour
" valeur `xterm2` ou `sgr`. Par défaut, sa valeur dépend de `$TERM`.

" Atm, dans xfce4-terminal et dans guake :
"     TERM=xterm ⇒ ttym=sgr
"
" Et dans Tmux :
"     TERM=screen ⇒ ttym=xterm

" Résultat, le redimensionnement des viewports à la souris fonctionne dans Vim
" qd il tourne ds xfce4-terminal et ds guake mais pas dans Tmux.

" Pour résoudre ce pb, le code qui suit vérifie la valeur de l'option term, et
" si elle débute par screen il donne la valeur xterm2 à ttymouse.

" Source:
" http://superuser.com/a/550482

" FIXME:
" Is it really still needed?
" It seems we can resize viewports without.
"
" However:
"     1. resizing is brittle/wonky no matter what
"     2. `xterm2` might be a better value than default `xterm`:
"
"            “This works much faster and more precise.”
"
"     3. why do we sometimes get into visual mode when we try to resize?
"
"        ┌ nvim doesn't have this issue, and 'ttym' has been removed from it
"        │
if !has('nvim') && &term =~# '^\%(screen\|tmux\)'
    set ttym=xterm2
endif

" updatetime {{{2

"              ┌─ our current chosen value
"              │  if you change it, do the same in:
"              │
"              │          ~/.vim/plugged/vim-readline/autoload/readline.vim
"              │
"              │  function:
"              │
"              │          `readline#do_not_break_macro_replay()`
"              │
set updatetime=2000

" virtualedit {{{2

" In visual-block mode, let us move the cursor on a cell where there's no character:
"
"         • in the middle of a tab
"         • beyond the last char on a line
"
" Useful to select a rectangle out of irregular (different lengths) lines.
set virtualedit=block

" wildignore(case) {{{2

" Why?{{{
"
" Some files can't be edited by Vim. Or they shouldn't.
" We never want to see them:
"
"         • in a dirvish listing
"         • on the command-line after a tab completion
"         • in the output of `expand()`, `glob()`, `globpath()`
"}}}
if has('vim_starting')
    " vim temporary files
    set wig+=*.bak,*.swo,*.swp,*~

    " latex temporary files
    set wig+=*.aux,*.fdb_latexmk,*.fls,*/auxiliary/*,*/build/*

    " password databases
    set wig+=*.kdb,*.kdbx

    " media files (music, pictures, ...)
    set wig+=*.gif,*.jpeg,*.jpg,*.mp3,*.mp4,*.pdf,*.png

    " python objects/cache
    set wig+=*.pyc,*/__pycache__/*
    " Why not `*/__pycache__/**/*` ?{{{
    "
    " No need to. The depth of a python cache is 1.
    " See the contents of `~/.vim/pythonx/__pycache__/`.
    "}}}

    " undo files
    "
    "                          ┌─ `*` can match any string/path
    "                          │  (including as many `/` as you want, but not a dot)
    "                          │
    let &wig .= ','.&undodir.'/*'
    let &wig .= ','.&undodir.'/*.*'
    let &wig .= ','.&undodir.'/*.*.*,'
    "                          │
    "                          └─ `*` can't match a dot, and the path of an
    "                              undofile often contains 1 or 2 dots

    set wig+=*.gz,*.rar,*.tar.*,*.zip

    set wig+=tags

    " A file in a `.git/` subdirectory.
    set wig+=*/.git/**/*
    " Why not `*/.git/*`?{{{
    "
    " It would fail to match the files in the subdirectories of `.git/`.
    "}}}
    " Why not `**/.git/**/*`?{{{
    "
    " No need to. Probably because the  pattern is automatically anchored to the
    " end of the files.
    "}}}
    " If this setting causes an issue, read this:{{{
    "
    "     https://www.reddit.com/r/vim/comments/626no2/vim_without_nerd_tree_or_ctrlp/dfkbm97/
    "     https://github.com/tpope/vim-fugitive/issues/121#issuecomment-38720847
    "}}}
endif

" Tab completion should be case-insensitive.
" If we type `:e bar Tab`, and a file `Bar` exists, we should get:
"
"         :e Bar
set wildignorecase

" wildmenu  wildchar(m) {{{2

" enable wildmenu
set wildmenu

" The value of 'wildmode' is a comma-separated list of (up to 4) parts.
" Each part defines what happens when we press Tab (&wc) the 1st/2nd/3rd/4th time.
set wildmode=full

" 'wc' =  which key  to press  to start  wildcard expansion,
"         or to complete Ex command name / argument
"
" 'wcm' = which key to:
"                       • press during the recording of a macro
"                       • use in the {rhs} of a mapping
"
" … to start wildcard expansion.
"
" If &wc != &wcm, we can't replay a macro opening the wildmenu.
" So, we give them the same value:  9 / <tab>
set wc=9
set wcm=9

" winaltkeys {{{2

" disable `alt + {char}` key bindings used in gVim to access some menu entries
" They could shadow some of our custom mappings using the meta modifier key.

set winaltkeys=no

" word / line wrapping {{{2

" don't wrap long lines by default
set nowrap

" display a character in front of a wrapped line
set showbreak=↪

" a soft-wrapped line will be displayed with the same level of indentation as
" the first one
set breakindent

" soft-wrap long lines at a character in 'breakat' (punctuation, math
" operators, tab, @) rather than at the last character that fits on the screen
set linebreak

" allow to soft-wrap after ) ] }
set breakat+=)]}

" the nr column ('nu', 'rnu') will be taken into account to decide when to wrap
" long lines
set cpo+=n

" allow `h` and `l` motion to move across lines
set whichwrap+=h,l

" MAPPINGS {{{1
" DISABLED {{{2

fu! s:cancel_prefix(prefixes) abort
    for pfx in a:prefixes
        " We may press a prefix by accident, then want to cancel.
        " Without these mappings,  if the prefix is  bound to a default  command in Vim,
        " the latter would be executed. Example `U`.
        exe 'nno  '.pfx.'<esc>  <esc>'
        exe 'xno  '.pfx.'<esc>  <esc>'

        " Also, we may let the timeout elapse. In this case, the key should have
        " no effect.
        exe 'nno  '.pfx.'  <nop>'
        exe 'xno  '.pfx.'  <nop>'
    endfor
endfu
call s:cancel_prefix(['U', '<bar>', '+', '-'])

" Disable C-z (suspension / iconize) in operator-pending, visual, and select mode
ono  <c-z>  <nop>
vno  <c-z>  <nop>

" Disable keyword completion
" Why?
" When I want to move the cursor backward with C-b, I suspect I hit C-n
" by accident instead. Very annoying (slow popup menu; breaks workflow).
" We can still use C-p though.
ino  <expr>  <c-n>  pumvisible() ? '<c-n>' : ''

" We still hit other keys by accident, which break the workflow.
" Probably `C-i` (undistinguished from `Tab`), and sth like `C-c C-f`.
" The latter makes us leave insert mode, then move the cursor one screen
" forward. Very annoying.
" We can't disable `C-i`, it would disable `Tab` and we use it to complete
" text.
" However, we can disable `C-c C-f`.
" As well as `C-c C-b`, `C-c C-d`, `C-c C-u` for good measure.

" ino <c-c><c-b> <nop>
" ino <c-c><c-f> <nop>
" ino <c-c><c-u> <nop>
" ino <c-c><c-d> <nop>

" I often hit `do` and `dp` by accident, when in fact I only wanted to hit
" `o` or `p`.
" Anyway, `do` and `dp` are only useful in a buffer which is in diff mode.

nno  <expr>  do  &l:diff ? 'do' : ''
nno  <expr>  dp  &l:diff ? 'dp' : ''

" When we cancel `go` with Escape, Vim moves the cursor to the top of the
" buffer (1st byte, see `:h go`). Annoying.
nno  go<esc>  <nop>

nno  s<esc>  <nop>
nno  S<esc>  <nop>

nno  sS  <nop>
nno  Ss  <nop>
xno  sS  <nop>
xno  Ss  <nop>

" I think I often press `Uu` by accident.
" When that happens, Vim undo our edits, which I don't want.
nno  Uu  <nop>

" FREE {{{2

" A key can be used as a prefix iff one of these conditions is true:
"
"           • it's useless for you (ex: U)
"           • it's used as a prefix by default (ex: Z)
"
" This means that you can NOT use `!` as a good prefix.
" Not useless, and not a prefix by default, so it would lead to too many issues.
"
" Still, you may  occasionally use a key sequence `!{char}`.   But do NOT infer,
" that `!` can be  used as a prefix associated with a meaning,  to build a whole
" family of mappings.
" There would be  times when it wouldn't  work, and then you would  have to build
" mappings which do not  follow the same scheme (shell command  → !). It would
" bring inconsistencies.


" When you  find a  new prefix,  if it has  a default  meaning, disable  the key
" sequence pfx + esc, in normal mode, and visual mode.
" Pass it to the `s:cancel_prefix()` function.


"    • C-g could be used as a prefix in normal mode
"
"    • C-q is not used in insert mode (except for exiting a completion menu)
"      we could supercharge  it to do something  else when we aren't  in a completion
"      menu
"
"    • C-z has been disabled in visual mode
"
"      in insert mode, we use it as an “easier-to-type“ C-x C-p
"      in normal/command-line mode, we use it to cycle through a set of commands
"
"    • gh, gH, g C-h, gl, v_C-g
"
"    • @# has been mapped to g8, so g8 is free
"
"    • gy, gz
"
"    • PageUp PageDown
"
"    • S-Tab (not Tab, because it would also affect C-i used for moving
"      inside the jumplist)
"
"    • C-_
"
"    • search for 'not used' in the window opened by `:viu`

" LEADER {{{2

" If we install a  plugin which defines mappings using the  leader key, we don't
" want any clash with one of  our existing mapping. So, we assign to `mapleader`
" a garbage key. Why `S-F13`? See the configuration of UltiSnips.

" As an  example, this strategy is  useful to avoid the  `unicode.vim` plugin to
" introduce lag  when we hit  `<space>u`. Indeed this plugin installs  a mapping
" whose lhs is `<leader>un` (:h <plug>(UnicodeSwapCompleteName)).

" Other benefit:
"
"       :no <leader>    →    display all mappings installed by third-party plugins
"                            in normal / visual / operator-pending mode

let mapleader = "\<s-f13>"

" same thing for localleader
let maplocalleader = "\<s-f14>"

" COMMAND LINE {{{2
" C-r C-h       fuzzy search history {{{3

cno  <expr>  <c-r><c-h>  getcmdtype() =~ '[/?]' ? '<Esc>:FzHistory/<cr>' : 'FzHistory:<cr>'

" C-r C-l       insert current line {{{3

cno  <c-r><c-l>  <c-r>=substitute(getline('.'), '^\s*"\?\s*:\?', '', '')<cr>

" INSERT {{{2

" Most of these mappings take care of not breaking undo sequence (C-g U).
" It means we can repeat an edition with the dot command, even if we use them.
" If you add another mapping, try to not break undo sequence. Thanks.

" C-g             (prefix) {{{3
" C-h {{{4
"
" Sometimes, we want to do this:
"
"        ┌ exceeding amount of whitespace
" ┌──────┤
"         some text
"     ↓
" some text
"│
"└─ compacted whitespace

ino  <expr><silent>  <c-g><c-h>  <sid>compact_whitespace()

fu! s:compact_whitespace() abort
    if empty(&l:cms)
        return ''
    endif
    let cml = matchstr(split(&l:cms, '%s')[0], '\S*')
    call timer_start(0, {->
    \                      setline(line('.'),
    \                              substitute(getline('.'), '\s*'.cml.'\zs\s\+', ' ', ''))
    \                   })
    return ''
endfu

" C-m             more granular undo {{{3

" When we write a paragraph then hit `u` to undo, Vim removes the whole
" paragraph. I want it to remove only the last line. Then the one before, etc.
" To get a more granular undo, we need to hit `c-g u` every time we hit Enter.
" This will break the undo block into smaller blocks.
" Every time we hit `c-g u`, the current state of the buffer is accessible
" with `u`/`c-r`.
"
" :h i_ctrl-g_u

fu! s:c_m() abort
    " If the completion menu is active, we want `Enter` to validate the item
    " currently selected.
    if pumvisible()
        return "\<c-y>"
    endif

    " If we hit Enter on a commented line with nothing in it, we want to
    " delete everything.
    let cml = get(split(&l:cms, '%s'), 0, '')

    if empty(cml)
        return "\<c-g>u\<cr>"
    endif

    if getline('.') =~ '^\s*\V'.escape(cml, '\').'\v\s*$'
        " We can't invoke `setline()` immediately, because of `<expr>`.
        call timer_start(0, { -> setline(line('.'), '') })
        return ''

        " OLD:
        " Not reliable, because sometimes BS deletes more than one char.
        " Happens after a sequence of whitespace.
        "
        "         return "0\<c-d>".repeat("\<BS>", strchars(cml) + 1)
    endif

    return "\<c-g>u\<cr>"
endfu

ino  <expr>  <c-m>  <sid>c_m()

" C-p             fix sPelling error {{{3

ino  <expr><silent>  <c-p>  pumvisible() ? '<c-p>' : myfuncs#fix_spell()

" C-q             exit completion menu {{{3

" Because  of a  mapping in  `vim-readline`, we've  lost the  ability to  exit a
" completion menu. Restore it on `c-q`.

ino  <c-q>  <c-e>

" C-r  X          output of last eX command  {{{3

" insert output of last eX command
ino  <expr><silent>  <c-r>X  <sid>output_last_ex_command()

fu! s:output_last_ex_command() abort
    let paste_save = &paste
    " enable 'paste' so that Vim  doesn't automatically add indentation when the
    " output has multiple lines
    set paste
    call timer_start(0, {-> execute('set '.(paste_save ? '' : 'no').'paste')})
    try
        " We remove the first newline, so that we can insert the output of a command
        " inline, and not on the next line.
        return substitute(execute(histget(':')),'\n','','')
    catch
        " If the last command failed and produced an error, it will fail again.
        " But we still want something to be inserted: the error message(s).
        let messages = reverse(split(execute('messages'), '\n'))
        let idx = match(messages, '^E\d\+')
        call remove(messages, idx+1, -1)
        return join(reverse(messages), "\n")
    endtry
endfu

" C-s             save {{{3

" I often type C-s in insert mode to save, and miss/forget the escape
" to get back in normal mode first.
" Alternative:
"     imap  <c-s>  <esc><c-s>
ino  <silent>  <c-s>  <esc>:sil update<cr>

" C-x             completions {{{3
" C-]     tag {{{4

" When a tag  contains a colon (e.g. global variable  `g:netrw`), the completion
" function tries to complete only up until the colon (netrw).
"
" In  the  same  way  we  try  to  fix  the  problem  of  multi  words  synonyms
" ('thesaurus'), by temporarily adding the colon  character (58) to the value of
" 'iskeyword'  when  C-x C-]  is  hit,  and then  removing  it  as soon  as  the
" completion is done.
"
" We   also   add   the   hyphen    character   (useful   for   something   like
" `ins-completion-menu`).

ino  <c-x><c-]>  <c-r>=myfuncs#keyword_custom(':-')<cr><c-x><c-]>

" C-k     dictionary {{{4

ino  <c-x><c-k>  <c-r>=<sid>set_dict()<cr><c-x><c-k>

fu! s:set_dict() abort
    exe 'setl dict='.(&l:spelllang is# 'en' ? '/usr/share/dict/words' : '/usr/share/dict/french')
    return ''
endfu

" Previously, we used this code:
"
"     ino <c-x><c-k> <c-o>:exe 'setl dict=' .
"                       \ (&l:spelllang is# 'en' ?
"                       \ '/usr/share/dict/words' :
"                       \ '/usr/share/dict/french')<cr><c-x><c-k>
"
" But it caused a bug. Here's how to reproduce it.
" 1. Write a column of `0`'s in a buffer:
"     0
"     0
"
" 2. Hit `C-v j A`, to insert some text after the column.
" 3. Hit `a Tab`, to insert the character `a` then try to complete this text.
"
" The result is that the rhs of the `C-x C-k` mapping is inserted into the
" buffer. The reason for this seems to be that `i_C-o` doesn't work as usual
" when we entered insert mode from visual block mode. See our notes for more
" detail on the subject (look for: ’i_C-o’).
"
" Moral of the story:
" Don't use `i_C-o` in a mapping.
"
" Update:
" It should be fixed by patch `8.0.0282`:
"         https://github.com/vim/vim/commit/0b5c93a7f266cd8c90ea27bdaf9f7214a95d64d7

" C-s     function signature {{{4

" Usage:
"
"         1. call matchadd(
"         2. press `C-x C-s`
"         3. call matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])

ino  <expr><silent>  <c-x><c-s>  <sid>complete_signature()

fu! s:complete_signature() abort
    let func_name = matchstr(getline('.'), '\<\w\+\ze()\?\%'.col('.').'c')
    if empty(func_name)
        return ''
    endif

    let signature = get(filter(readfile($VIMRUNTIME.'/doc/eval.txt'),
    \                          {i,v -> v =~ '^'.func_name.'('}),
    \                   0, '')
    " needed, for example, for `deepcopy()`
    let signature = matchstr(signature, '.\{-})')
    if empty(signature)
        return ''
    endif

    let new_line = substitute(getline('.'), func_name.'\%[()]', signature, '')
    call timer_start(0, {-> setline(line('.'), new_line)})
    return ''
endfu

" C-t     synonym {{{4

" Pb:
" If a synonym contains several words (e.g. important → of vital importance),
" the completion function considers each of them as a distinct synonym.
" Thus, if a synonym contains 3 words, the function populates the popup
" menu with 3 entries.

" Solution:
"         http://stackoverflow.com/a/21132116
"
" Create a  wrapper around  C-x C-t  to temporarily include  the space  and dash
" characters in 'isk'. We'll  remove them as soon as the  completion is done (or
" cancelled).
" It doesn't seem to affect the completed text, only the synonyms.
" Even with a space in 'isk', the completion function only tries to complete
" the last word before the cursor.

ino  <silent>  <c-x><c-t>  <c-r>=myfuncs#keyword_custom(' -')<cr><c-x><c-t>

" C-z             easy C-x C-p {{{3

ino  <expr><silent>  <c-z>  <sid>easy_c_x_c_p()

fu! s:easy_c_x_c_p() abort
    let cot_save = &cot
    set cot-=noinsert
    call timer_start(0, {-> execute('let &cot = '.string(cot_save))})
    return "\<c-x>\<c-p>"
endfu

" Inspiration:
" https://www.reddit.com/r/vim/comments/78h4pr/plugins_andor_keybindings_you_couldnt_live_without/dou7z5n/

" M-a  M-e {{{3

ino  <silent>  <m-a>  <c-r>=<sid>move_by_sentence(0)<cr>
ino  <silent>  <m-e>  <c-r>=<sid>move_by_sentence(1)<cr>

fu! s:move_by_sentence(is_fwd) abort
    if a:is_fwd
        norm! (
    else
        norm! )
    endif
    return ''
endfu

" \ {{{3

ino  <silent>  <bslash>  <c-r>=<sid>indent_before_backslash()<cr>

fu! s:indent_before_backslash() abort
    let has_text_before_cursor = matchstr(getline('.'), '.*\%'.col('.').'c') =~# '\S'
    let prev_indent            = matchstr(getline(line('.')-1), '^\s*\\')
    let next_indent            = matchstr(getline(line('.')+1), '^\s*\\')

    if  has_text_before_cursor
    \|| empty(prev_indent) && empty(next_indent)
        return '\'
    endif

    let current_indent =   empty(next_indent)
    \                    ?     prev_indent
    \                    :     next_indent

    "             ┌ if the cursor is in the middle of the indentation,
    "             │ `0 C-d` removes all whitespace before the cursor AND after
    "       ┌─────┤
    return "0\<c-d>".current_indent
endfu

" NORMAL {{{2
" SPC                 (prefix) {{{3
" SPC                           za {{{4

nno  <space><space>  za
xno  <space><space>  za

" . {{{4

" `.` repeats the last edit.
" But if we want to repeat it on the same text which we've just changed (`@"`),
" we have to look for it manually.
"
" Solution:
" install a mapping which:
"
"         1. puts the last changed text in the search register
"         2. cuts its next occurrence
"         3. inserts the previously inserted text and stop insert

" After `<space>.`  has been pressed,  you can repeat  with `.`, <space>  is not
" needed anymore.
nno  <expr><silent>  <space>.  <sid>repeat_last_edit_on_last_text()

fu! s:repeat_last_edit_on_last_text() abort
    " put the last changed text inside the search register, so that we can refer
    " to it with the text-object `gn`

    "                                      ┌─ last changed text
    "                                      │
    let last_text = '\V'.substitute(escape(@", '\'), '\n', '\\n', 'g')
    " The last changed text may contain newlines, but if it ENDs with one, we
    " usually don't want it.
    let last_text = substitute(last_text, '\\n$', '', '')
    let @/ = last_text

    set hls
    "               ┌ insert the previously inserted text and stop insert
    "          ┌────┤
    return "cgn\<c-@>"
endfu

" aa    ac    ad    al    an    arglist {{{4

nno  <silent>  <space>aa  :<c-u>argedit %<cr>

" load Current argument
nno  <silent>  <space>ac  :<c-u>argument<cr>

" Delete current argument
nno  <silent>  <space>ad  :<c-u>.argdelete<cr>

" create Local arglist (by copying the global one)
nno  <silent>  <space>al  :<c-u>arglocal<cr>

" start New arglist
"
" Define a new argument list, which is local to the
" current window, and containing only the current buffer.
" This causes the buffer to be reloaded.
" Add a bang to `:arglocal` to discard unsaved changes in the current buffer.
nno  <silent>  <space>an  :<c-u>arglocal %<cr>

" ec                            edit vimrc {{{4

nno  <silent>  <space>ec  :<c-u>call <sid>vimrc_edit()<cr>

fu! s:vimrc_edit() abort
    if tabpagenr('$') ==# 1 && winnr('$') ==# 1 && line2byte(line('$')+1) <= 2
        e $MYVIMRC
    else
        tabnew $MYVIMRC
    endif
endfu

" et                            edit /tmp/vim.vim {{{4

nno  <silent>  <space>et  :<c-u>tabedit /tmp/vim.vim<cr>

" f                             fuzzy search {{{4

" Mnemonic:
" SPC fl  = l for :ls (listing)
" SPC fr  = most Recently used (files and buffers)
" SPC fgc = Git Changed files

" `:FzSnippets` only returns snippets whose tab trigger contains the text
" before the cursor.

fu! s:fuzzy_mappings() abort

    let fuzzy_mappings = {
                         \ 'a' : 'Ag',
                         \ 'bt': 'BTags',
                         \ 'f' : 'Files',
                         \ 'gf': 'GFiles',
                         \ 'gc': 'GFiles?',
                         \ 'ht': 'Helptags',
                         \ 'l' : 'Buffers',
                         \ 'm' : 'Maps',
                         \ 'M' : 'Marks',
                         \ 'r' : 'History',
                         \ 's' : 'Snippets',
                         \ 't' : 'Tags',
                         \ 'w' : 'Windows',
                         \ }

    for [l:char, cmd] in items(fuzzy_mappings)
        exe 'nno  <space>f'.l:char.'  :<c-u>Fz'.cmd.'<cr>'
    endfor

    nno  <silent>  <space>fF  :<c-u>FZF $HOME<cr>
endfu

call s:fuzzy_mappings()

" To use `:FzBCommits` and `:FzCommits`, we first need to be in the working
" tree of the repo:
"
"     - on which the current file belong
"
"     - in which we are interested;
"       let's say, again, the one where the current file belong

nno  <silent>  <space>fbc  :<c-u>lcd <c-r>=expand('%:p:h')<cr> <bar> FzBCommits<cr>
nno  <silent>  <space>fc   :<c-u>lcd <c-r>=expand('%:p:h')<cr> <bar> FzCommits<cr>

" Fuzzy search mappings from insert / visual / operator-pending mode.

" C-g is often used as a prefix to create mappings in insert mode.
" So, to maintain some consistency, we use it to create a fuzzy search mapping
" in insert mode.
"
" We can safely do it without overriding / shadowing and existing mapping,
" because it's not present in:
"
"     :h i_^g C-d
"     :echo map(taglist('^i_CTRL-G'), { i,v -> v.name })
"
" There is no default equivalent for visual mode, but we often use `m` for
" visual mode mappings. So, here again, we'll use `m` as a prefix.

imap  <c-g>m  <plug>(fzf-maps-i)
xmap  mm      <plug>(fzf-maps-x)
omap  m       <plug>(fzf-maps-o)

" OLD CODE:
"
" Les 2 raccourcis qui suivent permettent de chercher un buffer via le
" wildmenu. On peut donner un bout du nom du buffer qu'on cherche et
" développer via le wildcharm = <tab>.
" nno <space>b :<c-u>buffer *
"
" Ce mapping fait la même chose mais au lieu d'afficher le buffer trouvé dans
" la fenêtre active, il passe le focus à une fenêtre qui l'affiche déjà s'il
" y en a une, autrement il ouvre un viewport horizontal.
" Pour un viewport vertical:
" nno <space>B :vert sbuffer *
" nno <space>B :<c-u>sbuffer *

" p                             gqip {{{4

"                                              ┌─ don't write:
"                                              │
"                                              │      'sil norm <plug>(my_gq)ip'
"                                              │
"                                              │  because `:nno` doesn't translate `<plug>`.
"                                              │
nno  <silent>  <space>p  mz:<c-u>exe "sil norm \<plug>(my_gq)ip"
                         \<bar> sil update
                         \<bar> sil! norm! `z<cr>

" P  C-p                        split long paragraph {{{4

nmap           <space>P                         <plug>(split-paragraph-compact)
nno  <silent>  <plug>(split-paragraph-compact)  :<c-u>call <sid>split_paragraph(1, 'n')<cr>

nmap           <space><c-p>             <plug>(split-paragraph)
nno  <silent>  <plug>(split-paragraph)  :<c-u>call <sid>split_paragraph(0, 'n')<cr>

xmap <silent>  <space>P      :<c-u>call <sid>split_paragraph(1, 'x')<cr>
nmap <silent>  <space><c-p>  :<c-u>call <sid>split_paragraph(0, 'x')<cr>

fu! s:split_paragraph(compact, mode) abort
    let [firstline, lastline] = a:mode is# 'n'
    \ ?     [line("'{"), line("'}")]
    \ :     [line("'<"), line("'>")]

    " get the address of the last line of the paragraph/selection
    let lnum2 = lastline + (a:mode is# 'n' ? (lastline ==# line('$') ? 0 : -1) : 0)

    " The last character of the paragraph needs to be a valid punctuation ending
    " for a sentence. Otherwise, our function could wrongly delete some lines.
    if getline(lnum2) =~# '\s*[^.!?:]$'
        echo 'last char is not a valid punctuation ending for a sentence'
        return
    endif

    " get the address of the first line
    let lnum1 = firstline ==# 1 && getline(1) =~# '\S'
    \ ?             1
    \ :             firstline + 1

    " join all the lines in a single one
    exe 'keepj '.lnum1.','.lnum2.'j'

    " break the line down according to the punctuation
    let pat = '[.!?]\zs\%(\s\+\|$\)\|:\zs\s*$'
    let indent = matchstr(getline(lnum1), '^\s*')
    sil exe printf("keepj keepp s/%s/\\=%s/g", pat, string("\n\n".indent))

    " 2 empty lines have been added (one where we are right now, and the one above);
    " remove them
    -,d_

    " format with `$ par`
    sil exe printf('keepj keepp %d,%dg/\S/norm gqq', lnum1, line('.'))

    " remove empty lines
    if a:compact
        sil exe printf('keepj keepp %d,%dg/^$/d_', lnum1, line('.'))
    endif

    " make the mapping repeatable
    if a:mode is# 'n'
        sil! call repeat#set("\<plug>(split-paragraph".(a:compact ? '-compact)' : ')'))
    endif
endfu

" s                             saiw {{{4

nmap  <space>s  saiw

" t                             new tab page {{{4

" nno <space><tab>    :<c-u>tabnew<cr>
nno  <space>t  :<c-u>tabnew<cr>

" [    ]              (prefix) {{{3
" ]kj                           various alignments {{{4

"  [k [j align the beginning of the current line with the one of the
"  previous/next line
"
"  ]k ]j align the end of the current line with the one of the
"  previous/next line

nno  <silent>  [k  :<c-u>exe 'left ' . indent(line('.')-1)<cr>
nno  <silent>  [j  :<c-u>exe 'left ' . indent(line('.')+1)<cr>

nno  <silent>  ]k  :<c-u>call myfuncs#align_with_end(-1)<cr>
nno  <silent>  ]j  :<c-u>call myfuncs#align_with_end(1)<cr>

" ]\    ]- {{{4

" long object = dictionary or list

nmap            ]\                                 <plug>(myfuncs_long_object_split)
nno   <silent>  <plug>(myfuncs_long_object_split)  :<c-u>call myfuncs#long_object_split()<cr>

nmap            [\                                <plug>(myfuncs_long_object_join)
nno   <silent>  <plug>(myfuncs_long_object_join)  :<c-u>call myfuncs#long_object_join()<cr>

nmap            ]-                                  <plug>(myfuncs_long_listing_split)
nno   <silent>  <plug>(myfuncs_long_listing_split)  :<c-u>call myfuncs#long_listing_split()<cr>

" \                   (prefix) {{{3
" \b            select current box {{{4

" select the current box, so that we can move it quickly with `vim-schlepp`
nno  <silent>  \b  :<c-u>call myfuncs#block_select_box()<cr>

" \f            find digraph {{{4

" We've mapped `f` to a function of `vim-sneak`.
" But it doesn't work with a digraph, contrary to the default `f` command.
" Use `\f` when you need to look for a complex character (ex: →).

nno  \f  f

" \p            select paragraph in a block {{{4

" Select a box around the current paragraph.
" Useful to write some text FIRST, then hit `\p` and `mb` (draw-it plugin)
" to draw a box around it.

nno  <expr><silent>  \p  myfuncs#block_select_paragraph()

" g                   (prefix) {{{3
" g^ g$       first/last tabpage {{{4

nno  g^  :<c-u>1tabnext<cr>
nno  g$  :<c-u>$tabnext<cr>

" g c-v       select last edited text {{{4

"                ┌─ Visually select
" Mnemonic:    c-v
"              └─ the Changed text
nno  g<c-v>  `[v`]

" g SPC       break line {{{4

nmap            g<space>               <plug>(my_break_line)
nno   <silent>  <plug>(my_break_line)  :<c-u>call <sid>break_line()<cr>

fu! s:break_line() abort
    try
        " break the line
        exe "norm! i\r"

        " trim ending whitespace on both lines
        keepj keepp .-,.s/\s\+$//e

        if !empty(bufname('%')) && fnamemodify(bufname('%'), ':p') isnot# $MYVIMRC
            sil update
        endif
        sil call repeat#set("\<plug>(my_break_line)")
    catch
        return lg#catch_error()
    endtry
endfu

" ga          easy align {{{4

" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap  ga  <plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap  ga  <plug>(EasyAlign)

" go {{{4

nno  <silent>  gof  :<c-u>call myfuncs#gtfo_open_gui(expand('%:p:h', 1))<cr>
nno  <silent>  goF  :<c-u>call myfuncs#gtfo_open_gui(getcwd())<cr>

nno  <silent>  got  :<c-u>call myfuncs#gtfo_open_term(expand('%:p:h', 1))<cr>
nno  <silent>  goT  :<c-u>call myfuncs#gtfo_open_term(getcwd())<cr>

" gQ {{{4

" In Ex mode,  every time we press a  key which is expanded into the  value of a
" custom function,  if the latter contains  empty lines, it will  raise an error
" (E501, E749).
"
" So, we  install a wrapper around  `gQ` to temporarily disable  all mappings in
" command-line mode.

"                   ┌ make sure we have visited the command-line at least once since Vim's startup
"                   │ otherwise E501:
"                   │ probably because custom command-line mappings haven't been installed yet,
"                   │ so `ToggleEditingCommands 0` is useless / too soon
"               ┌───┤
nno  <expr>  gQ ":\e".execute('ToggleEditingCommands 0', 'silent!').'gQ'

" gq {{{4

" The default `gq` invokes `par` which doesn't recognize bullet lists.
" OTOH, `gw` recognizes them thanks to 'flp'.
" We create a wrapper around `gq`, which checks whether the 1st line of the text
" object  has a  list  header. If  it does,  the  wrapper  should execute  `gw`,
" otherwise `gq`.

" Why do we create `<plug>` mappings?{{{
"
" We have 3 mappings which currently invoke the default `gq`:
"
"         • gqic
"         • gqq
"         • <space>p
"
" We want them to invoke our custom wrapper, and `<plug>` mappings are easier to use.
"}}}
nmap            gq             <plug>(my_gq)
nno   <silent>  <plug>(my_gq)  :<c-u>set opfunc=<sid>my_gq<cr>g@

xmap            gq             <plug>(my_gq)
xno   <silent>  <plug>(my_gq)  :<c-u>call <sid>my_gq('vis')<cr>

fu! s:my_gq(type) abort
    let ai_save = &l:ai
    try
        " 'ai' needs to be set so that `gw` can properly indent the formatted lines.
        setl ai

        let [ lnum1, lnum2 ] = a:type is# 'vis'
                           \ ?     [ line("'<"), line("'>") ]
                           \ :     [ line("'["), line("']") ]

        let cml = get(split(&l:cms, '%s'), 0, '')
        let cml = '\%(\V'.escape(cml, '\').'\m\)\?'
        let has_a_list_header = getline(lnum1) =~# &l:flp
        let has_diagram = getline(lnum1) =~# '^'.cml.'\s*[\u2502\u250c]'

        if has_a_list_header
            sil exe 'norm! '.lnum1.'Ggw'.lnum2.'G'

        elseif has_diagram

            " replace │ with |, and ┌ with ||
            " Why?{{{
            "
            " We want to use the `par` utility to format a paragraph whose lines
            " begin with │ and ┌, in case it's a diagram.
            "
            " If  we  could  include  │  and   ┌  in  the  Q  option  of  `par`,
            " there  would be  no  need for  a  replacement. But including  them
            " doesn't work. Maybe because `par`  doesn't fully support multibyte
            " characters.
            "
            " As a  workaround, we  temporarily replace │  and ┌  with different
            " number of bars.
            "
            " Then, we format the diagram.
            "
            " Then, we restore the unicode characters.
            "}}}
            " Why does it work?{{{
            "
            " From the perspective of the `par`  utility, the bar character is a
            " quote character,  because we've included  it in its Q  option, via
            " `$PARINIT`:
            "
            "         export PARINIT='rTbgqR B=.,?_A_a Q=_s>|'
            "                                          │    │
            "                                          │    └ bar
            "                                          │
            "                                          └ quote characters
            "
            " It means that we can format a paragraph whose lines begin with bars.
            "
            " For more info,  on how `par` use the quote  characters, search for
            " “quote” in the `Details` section of our notes on `par`.
            "}}}
            sil exe printf("keepj keepp %d,%ds/^%s\\s*\\zs\\%%u250c/%s/e", lnum1, lnum2, cml, '||')
            sil exe printf("keepj keepp %d,%ds/^%s\\s*\\zs\\%%u2502/%s/e", lnum1, lnum2, cml, '|')

            " format the lines in the diagram
            sil exe 'norm! '.lnum1.'Ggq'.lnum2.'G'

            " Update the last line of the formatted text.
            " Why?{{{
            "
            " `gq` could have increased the number of lines, or reduced it.
            " There's no  guarantee that  `lnum2` still matches  the end  of the
            " original text.
            "}}}
            let lnum2 = line("']")

            " restore │ and ┌
            " Warning:{{{
            "
            " You must process the substitutions from the one replacing the most
            " bars, to the one replacing the least ones.
            "}}}
            sil exe printf("keepj keepp %d,%ds/^%s\\s*\\zs||/\u250c/e", lnum1, lnum2, cml)
            sil exe printf("keepj keepp %d,%ds/^%s\\s*\\zs|/\u2502 /e", lnum1, lnum2, cml)
            "                                                     │
            "                                                     └ leave it!

            " TODO:
            " Add support for └ (and maybe ┘ ┐).
            "
            " There should  be no  need to  replace all  of them  with different
            " number of bars. Because there can be only  1 corner at a time in a
            " diagram. We could temporarily replace any of them with two bars.

        else
            sil exe 'norm! '.lnum1.'Ggq'.lnum2.'G'
        endif
    catch
        return lg#catch_error()
    finally
        let &l:ai = ai_save
        " For some reason, if we're editing a help file, and use `gq`, Vim makes
        " the buffer noreadonly back.
        " MWE:
        "     :h
        "     coH
        "     :norm! gqq
        if &ft is# 'help' && &l:ro
            setl noro
        endif
    endtry
endfu

" gqs         remove excessive spaces  {{{4

nno  <silent>  gqs  :<c-u>s/\s\{2,}/ /gc<cr>

" gqic        format comment {{{4

nmap            gqic                       <plug>(my_format_comment)
nno   <silent>  <plug>(my_format_comment)  :<c-u>call <sid>format_comment()<cr>

fu! s:format_comment() abort
    let cur_line = line('.')
    norm! mz
    " select the current comment
    call comment#object(1, '\|[\u2518\u2514\u2510\u250c\u2502\u2500]\|^\s*"\s*\S\+:')
    "                         │                                       │
    "                         │                                       └─ and ignore a title (vimCommentTitle)
    "                         └─ but ignore lines in a diagram
    " TODO:
    " This is an ugly hack.
    " It's not needed anymore.
    "
    " Look  at how  we dealt  with lines  containing multibyte  characters (such
    " as│), in `s:my_gq()`.
    "
    " Hint: in  the configuration  of `$  par`, we (ab)use  the notion  of quote
    " characters.
    "
    " Once you've removed this hack.
    " Simplify  the  code in  `vim-comment`,  by  removing the  second  optional
    " argument passed to `comment#object()`.

    exe "norm! \e"
    "           │
    "           └─ the '< '> marks are not set until we get back to normal mode

    " format the comment
    if line("'<") ==# line("'>") || cur_line < line("'<") || cur_line > line("'>")
        return
    else
        exe "norm gv\<plug>(my_gq)"
    endif

    sil! norm! `z
    sil! call repeat#set("\<plug>(my_format_comment)", v:count1)
endfu

" gqq {{{4

" When we hit `gqq`  on a commented line, and `par` breaks the  line in 2 lines,
" the 2nd  line is not commented. We  want it to  be commented, and `par`  to be
" reinvoked on the 2 lines.

nmap           gqq              <plug>(my_gqq)
nno  <silent>  <plug>(my_gqq)  :<c-u>call <sid>gqq()<cr>

fu! s:gqq() abort
    norm! mz

    let was_commented = !empty(&l:cms)
    \                   ?    stridx(getline('.'), split(&l:cms, '%s')[0]) !=# -1
    \                   :    0
    let orig = line('.')

    " format current line
    exe "sil norm \<plug>(my_gq)_"

    " if the line was commented, and has been split into several new lines (i.e.
    " the current line address has changed)
    if was_commented && line('.') !=# orig
        let range = orig+1.','.line('.')
        " then comment the lines between the new lines
        exe range.'CommentToggle'
        " and format them
        exe "sil norm \<plug>(my_gq)".(line('.')-orig).'k'
    endif

    sil! norm! `z
    sil! call repeat#set("\<plug>(my_gqq)", v:count1)
endfu

" gt  gT      search todo/fixme (Tags) {{{4

nno  <silent>  gt  :<c-u>call myfuncs#search_todo('buffer')<cr>
nno  <silent>  gT  :<c-u>call myfuncs#search_todo('project')<cr>

" gx          open url {{{4

" The default `gx` command, installed by the netrw plugin, doesn't open a link
" correctly when it's inside a man page.
" Ex:  :Man zsh  →  http://sourceforge.net/projects/zsh/

" So, I implement my own solution.

nno  <silent>  gx  :<c-u>call myfuncs#open_gx(0)<cr>

" Also, install a `gX` mapping opening the url under the cursor in `w3m` inside
" a Tmux pane.
nno  <silent>  gX  :<c-u>call myfuncs#open_gx(1)<cr>

" m                   (prefix) {{{3
" m/  m?         put current location in loclist {{{4

" these mappings can be used to traverse an arbitrary set of locations in the
" current buffer, using `m/` and `m?` to populate/empty the loclist, and `[l`,
" `]l` to move from one location to the other

" If we use our breakdown plugin, it will make us lose the current loclist.
" But we could still recover it:    :lol[der]
"                                   :lhi[story]

" add current position in loclist
nno  <silent>  m/  :<c-u>call <sid>add_to_loclist(1)<cr>
" empty loclist
nno  <silent>  m?  :<c-u>call <sid>add_to_loclist(0)<cr>

fu! s:add_to_loclist(populate) abort
    let s:my_marks = a:populate
                 \ ?     get(s:, 'my_marks', []) + [ {'bufnr': bufnr('%'), 'lnum': line('.'), 'col': col('.')} ]
                 \ :     []
    "                               ┌─ without this, Vim would create a new
    "                               │  loclist every time we invoke the function
    "                               │
    call setloclist(0, s:my_marks, 'r')
    call setloclist(0, [], 'a', {'title': 'My marks'})
endfu

" m,  m;         move tab pages {{{4

nno  <silent>  m,  :tabmove -1<cr>
nno  <silent>  m;  :tabmove +1<cr>

" U                   (prefix) {{{3

" go to previous save
nno  <silent>  UU  :<c-u>call <sid>undo_until_prev_save()<cr>
" we use `M-u u` to upcase a visual selection, so don't worry about shadowing `U`
xno  UU  :<c-u>call <sid>undo_until_prev_save()<cr>

" go to next save
nno  <silent>  UY  :<c-u>later   1f<cr>

" go to most recent version of the file
nno  <silent>  UR  :<c-u>exe 'undo '.undotree().seq_last<cr>

fu! s:undo_until_prev_save() abort
    try
        for what in [ 'region', 'line' ]
            if exists('w:my_moved_'.what)
                call matchdelete(w:my_moved_{what})
                exe 'unlet! w:my_moved_'.what
                exe 'au! my_moved_'.what
                exe 'aug! my_moved_'.what
            endif
        endfor
        earlier 1f
    catch
        return lg#catch_error()
    endtry
endfu

" fugitive
nno  <silent>  Up  :<c-u>call <sid>try_fugitive_cmd('Gpush')<cr>
nno  <silent>  Us  :<c-u>call <sid>try_fugitive_cmd('Gstatus')<cr>

fu! s:try_fugitive_cmd(cmd) abort
    if exists(':'.a:cmd) !=# 2
        echo 'Not in a git repo'
        return
    endif

    exe a:cmd
    if a:cmd is# 'Gstatus'
        sil! keepj keepp 1;/^# \%(Changes\|Untracked files\)/
    endif
endfu

" z                   (prefix) {{{3
" z= {{{4

nmap  z=                            <plug>(my_z_equal)
nno   <silent>  <plug>(my_z_equal)  :<c-u>call <sid>my_z_equal()<cr>

fu! s:my_z_equal() abort
    let spell_save = &l:spell
    try
        call feedkeys(":setl spell\<cr>z=", 'in')
    catch
        return lg#catch_error()
    finally
        call timer_start(0, {-> execute('let &l:spell = '.spell_save, '')})
    endtry
    sil! call repeat#set("\<plug>(my_z_equal)")
endfu

" zd {{{4

" make `zd` repeatable
nno  <silent>  zd  zd:sil! call repeat#set('zd')<cr>

" zf {{{4

nno  <silent>  zf  :<c-u>set opfunc=<sid>my_zf<cr>g@
xno  <silent>  zf  :<c-u>call <sid>my_zf('vis')<cr>

fu! s:my_zf(type) abort
    let cml = !empty(&l:cms) ? split(&l:cms, '%')[0] : ''
    let pat = '^\s*'.cml.'.*\zs'.cml.'\ze\s*{'.'{{'
    if a:type is# 'vis'
        norm! '<V'>zf
        sil! exe 'keepj keepp ''<s/'.pat.'//'
    else
        norm! '[zf']
        sil! exe 'keepj keepp ''[s/'.pat.'//'
    endif
endfu

" zg (&friends) {{{4

" The default commands to add good / bad words in:
"
"     • a temporary list  use an uppercase character
"     • a persistent list use only lowercase characters
"
"     ┌────────────┬──────────────┬──────────────┐
"     │            │ mark         │ undo         │
"     ├────────────┼──────┬───────┼──────┬───────┤
"     │            │ good │ wrong │ good │ wrong │
"     ├────────────┼──────┼───────┼──────┼───────┤
"     │ persistent │ zg   │ zw    │ zug  │ zuw   │
"     ├────────────┼──────┼───────┼──────┼───────┤
"     │ temporary  │ zG   │ zW    │ zuG  │ zuW   │
"     └────────────┴──────┴───────┴──────┴───────┘
"
" For the moment, I  prefer to always add good / bad words  to a temporary list,
" so that  my choices don't persist  across sessions. Therefore, I swap  all the
" commands (easier to type lowercase characters):

" mark word under cursor as good

nno  <expr>  zg  <sid>repeatable_spell_commands('zG')
nno  <expr>  zG  <sid>repeatable_spell_commands('zg')

" mark word under cursor as wrong
nno  <expr>  zw  <sid>repeatable_spell_commands('zW')
nno  <expr>  zW  <sid>repeatable_spell_commands('zw')

" undo the marking of word under cursor as good
nno  <expr>  zug  <sid>repeatable_spell_commands('zuG')
nno  <expr>  zuG  <sid>repeatable_spell_commands('zug')

" undo the marking of word under cursor as wrong
nno  <expr>  zuw  <sid>repeatable_spell_commands('zuW')
nno  <expr>  zuW  <sid>repeatable_spell_commands('zuw')

fu! s:repeatable_spell_commands(cmd) abort
    let last_char = a:cmd[-1:-1]
    let last_char_is_uppercase = last_char is# toupper(a:cmd[-1:-1])
    let cmd_to_repeat = a:cmd[:-2].(last_char_is_uppercase
                    \ ?                 tolower(last_char)
                    \ :                 toupper(last_char))

    call repeat#set(cmd_to_repeat)
    return a:cmd
endfu

" zv  zV {{{4

nno  zv  zMzvzz
nno  zV  zv

" |                   (prefix) {{{3
" |C  |F     open html file in firefox/chrome {{{4

nno  <silent>  <bar>F  :<c-u>exe ':sil !firefox localhost/' .
                       \ substitute(expand('%'), $HOME . '/htdocs/', '', '') <bar>
                       \ redraw!<cr>

nno  <silent>  <bar>C  :<c-u>exe ':sil !google-chrome localhost/' .
                       \ substitute(expand('%'), $HOME . '/htdocs/', '', '') <bar>
                       \ redraw!<cr>

" |g         grep word under cursor / visual selection {{{4

" grep the word under the cursor, recursively in all the files of cwd
nno  <silent>  <bar>g  :<c-u>set operatorfunc=myfuncs#op_grep<cr>g@

" same thing for visual selection
xno  <silent>  <bar>g  :<c-u>call myfuncs#op_grep('vis')<cr>

" Why not `!g` for the `{lhs}` ?
" Because it would introduce some "lag" whenever we hit `!` to filter some
" visual selection. We would need to wait, or hit the second character of our
" command to see the bang on the command-line.

" |t         translate {{{4

"                                               ┌─ 1st invocation
"                                               │
nno  <silent>  <bar>t  :<c-u>call myfuncs#trans(1)<cr>
nno  <silent>  <bar>T  :<c-u>call myfuncs#trans_stop()<cr>
xno  <silent>  <bar>t  :<c-u>call myfuncs#trans(1, 1)<cr>
"              │                                   │
"              │                                   └─ visual mode
"              │
"              └─ do NOT use `!t`, it would prevent you from writing a visual selection
"                 on the standard input of a shell command whose name begins with a `t`
"
"                 do NOT use `!<c-t>`, it would introduce lag when we press `!` in visual mode
"
"                 do NOT use `<c-t>!`, it would be inconsistent with other similar mappings
"                 Ex:
"
"                         xno <silent>  <bar>x  "my:TxSend(@m)<cr>
"                                       │
"                                       └─ can't use `<c-x>!`, it would introduce lag when decreasing numbers

" cycle through several types of translations
nno  <silent>  coT  :<c-u>call myfuncs#trans_cycle()<cr>


" OLD CODE:
"
" nno <silent>  <bar>w  :<c-u> sil! call system('xdg-open http://www.wordreference.com/enfr/'
"                       \   .  expand('<cword>'))
"                       \<bar> redraw!<cr>

" |x  |X     Tmux run last / current command {{{4

nno  <nowait><silent>  <bar>x  :<c-u>call myfuncs#tmux_last_command()<cr>
nno  <nowait><silent>  <bar>X  :<c-u>call myfuncs#tmux_current_command()<cr>

" -                   (prefix) {{{3
" -a  -8           ascii / bytes info {{{4

" We remap `-a` to a function of the unicode.vim plugin which gives us more info
" about the  character under the  cursor. In particular, its unicode  name, html
" entity (&entity_name; OR &#entity_number;), and digraph inside parentheses (if
" there's one defined).
nmap  -a  <plug>(UnicodeGA)

" We remap `-8` to `g8` for consistency.
nno  -8  g8

" -c               TOC {{{4

" Source:
" https://github.com/neovim/neovim/pull/4449#issuecomment-237290098

" In Neovim, they use `gO`. Should we do the same?
nno  <silent>  -c  :<c-u>call myfuncs#tab_toc()<cr>
"               ^
"               Contents

" -f               show filetype {{{4

nno  -f  :<c-u>echohl Title <bar> echo '[filetype] '.(!empty(&ft) ? &ft : "\u2205") <bar> echohl NONE <cr>

" full path current file
"
" C-g does sth similar (:h ^g), but its output is:
"
"     • noisy
"     • not colored
"     • unable to expand `~`
"     • relative to the working directory

" -p  -P           show filePath / :pwd {{{4

nno  -p  :<c-u>echohl Title <bar> echo expand('%:p') <bar> echohl NONE <cr>
nno  -P  :<c-u>pwd<cr>

" -q               faq {{{4

" Purpose:{{{
"
" Open a split in which you can write answers to a faq in a wiki.
" The height of the split will stay the same, even when you focus the wiki,
" because we temporarily set its window option 'pvw'.
" Also, we temporarily enable the “auto open folds” mode.
"}}}
" Usage:{{{
"
"     :FAQ
"             begin answering a faq in a wiki
"
"     :FAQ!
"             stop answering the faq
"}}}

nno  <silent>  -q  :<c-u>exe <sid>faq()<cr>

fu! s:faq() abort
    if stridx(expand('%:p'), '/wiki/') ==# -1 && expand('%:p') isnot# $XDG_RUNTIME_DIR.'/faq'
        return 'echo "you''re not in a wiki"'
    endif

    let this_tab = tabpagenr()
    let win_in_this_tab = filter(getwininfo(), {i,v -> v.tabnr ==# this_tab})
    let faq_file = $XDG_RUNTIME_DIR.'/faq'

    for win in win_in_this_tab
        if bufname(get(win, 'bufnr', -1)) is# faq_file
            exe win.winnr.'close'
            exe "norm 1\<space>G"
            sil norm ]oz
            return ''
        endif
    endfor

    call map(deepcopy(win_in_this_tab), {i,v -> getwinvar(v.winnr, '&pvw', 0)})
    if index(win_in_this_tab , 1) !=# -1
        return 'E590: A preview window already exists: previewwindow'
    endif

    if index(map(deepcopy(win_in_this_tab), {i,v -> bufname(v.bufnr)}), faq_file) !=# -1
        echo 'a window displaying  '.faq_file.'  already exists'
        return ''
    endif

    exe "norm 1\<space>G"

    exe 'sp '.faq_file
    sil norm [oP
    sil norm [oz
    wincmd p
    return ''
endfu

" -r               edit README {{{4

" Works also for a CONTENTS file.
"
" Mnemonic:
" Root (main) file of the directory.

nno  <silent>  -r  :<c-u>call <sid>edit_readme()<cr>

fu! s:edit_readme() abort
    let files = glob(expand('%:p:h').'/*', 0, 1)
    let kwd = '\%(readme\|contents\)'
    let pat = '\c/'.kwd.'\%(\..\{-}\)\?$'
    let readmes = filter(files, {i,v -> v =~# pat})
    let readme = get(readmes, 0, '')
    if filereadable(readme)
        exe 'sp '.readme
        1
    endif
endfu

" -s -S            edit/show snippets {{{4

nno  <silent>  -s  :<c-u>UltiSnipsEdit<cr>
nno  <silent>  -S  :<c-u>call myfuncs#show_me_snippets()<cr>

" -U               show unicode table {{{4

" We define this mappping because  it's more convenient than the `:UnicodeTable`
" command, and  to install a buffer-local  mapping to close the  “unicode table“
" window with a single `q` (instead of `:q`).
nno  <silent>  -U  :<c-u>call <sid>unicode_table()<cr>

fu! s:unicode_table() abort
    UnicodeTable
    nno  <buffer><nowait><silent>  q  :<c-u>close<cr>
endfu

" -u               :UndotreeShow {{{4

" `D` toggles the diff window.
nno  <silent>  -u  :<c-u>UndotreeShow<cr>

" +                   (prefix) {{{3
" +t            trim whitespace {{{4

nno  <silent>  +t   :<c-u>set opfunc=myfuncs#op_trim_ws<cr>g@
xno  <silent>  +t   :<c-u>call myfuncs#op_trim_ws('vis')<cr>
nno  <silent>  +tt  :<c-u>set opfunc=myfuncs#op_trim_ws<bar>exe 'norm! '.v:count1.'g@_'<cr>

" +y  (+yc)     incremental yank (clear) {{{4

nno  <silent>  +y   :<c-u>set opfunc=myfuncs#op_incremental_yank<cr>g@
xno  <silent>  +y   :<c-u>call myfuncs#op_incremental_yank('vis')<cr>
nno  <silent>  +yy  :<c-u>set opfunc=myfuncs#op_incremental_yank<bar>exe 'norm! '.v:count1.'g@_'<cr>

nno  <silent>  +yc  :<c-u>call <sid>clear_z()<cr>

fu! s:clear_z() abort
    let [@z, @+] = ['', '']
    sil! put
    sil! undo
    echo 'z register: cleared'
endfu

" !                   (prefix) {{{3
" !e            wref (wordreference) {{{4

nno  <silent>  !e  :<c-u>call <sid>wref()<cr>

fu! s:wref() abort
    call feedkeys(':sil !sr wref ', 'int')
    augroup wref_translate_english
        au!
        au CmdlineLeave * call timer_start(0, {-> execute('redraw!')})
        \ |               exe 'au! wref_translate_english'
        \ |               aug! wref_translate_english
    augroup END
endfu

" CR / Tab / Shift / Control / Meta {{{3
" CR                  move cursor on 80/100 column {{{4

" If the buffer is special (`!empty(&buftype)`), we let `CR` unchanged.
" Special buffers include the ones displayed in the quickfix and the command-line windows.
" It's important to not alter the behavior of `CR` in those buffers, because
" usually it's already mapped to a very useful function such as executing
" a command or going to an entry in the quickfix list.
"
" Otherwise, if the buffer is a regular one, we remap `CR` to move on the 80th
" column. It can be overridden on a filetype-basis, by an arbitrary Ex command.
" Example:
"         let b:cr_command = 'echo "hello"'
"
" If we wrote the previous line in a python ftplugin, hitting CR would display
" 'hello'.

nno  <expr><silent>  <cr>  !empty(&buftype)
                       \ ?     '<cr>'
                       \ :     ':<c-u>'.getbufvar('%', 'cr_command', 'norm! 80<bar>').'<cr>'
"                                 │
"                                 └── important, otherwise, if we hit a nr
"                                 (e.g. 42) by accident before `CR`, it would do:    :42norm! 100|
"                                 which would move the cursor 42 lines below the
"                                 current one

" Tab    S-Tab {{{4

" command-line mode

" By default, when you search for a pattern, <c-g> and <c-t> allow you to cycle
" through all the matches, without leaving the command-line.
" We remap them to <tab> and <s-tab>.

cno  <expr>  <tab>    <sid>c_tab(1)
cno  <expr>  <s-tab>  <sid>c_tab(0)

fu! s:c_tab(is_fwd) abort
    if getcmdtype() =~# '[?/]'
        return empty(getcmdline())
           \ ?     "\<up>"
           \ :     a:is_fwd ? "\<c-g>" : "\<c-t>"
    else
        let l:key = a:is_fwd ? "\<tab>" : "\<s-tab>"
        let flags = 'in'.(!wildmenumode() && !a:is_fwd ? 't' : '')
        "                                                 │
        "                        handle key as if typed,  ┘
        "                        otherwise  it's handled  as if  coming from  a
        "                        mapping, which matters when we try to open the
        "                        wildmenu, or cycle through its entries

        " Why use `feedkeys()`?{{{
        "
        " If we used this mapping:
        "         cno <expr>  <s-tab>  getcmdtype() =~ '[?/]' ? '<c-t>' : '<s-tab>'
        "
        " When we would hit <s-tab> on the command-line (:) (outside the wildmenu),
        " it would insert the 7 characters '<s-tab>', literally.
        " That's not what `S-Tab` does by default. It should simply open the wildmenu
        " and select its last entry.
        " We need `S-Tab` to be treated as if it wasn't coming from a mapping.
        " We need to pass the `t` flag to `feedkeys()`.
        "}}}
        " Why not pass the `t` flag unconditionally?{{{
        "
        " It breaks the  replay of a macro during which  we've pressed `Tab`
        " or `S-Tab` on the command line.
        " MWE:
        "         qqq
        "         qq : Tab Tab CR    (should execute `:#`)
        "         q
        "
        "         :nunmap @
        "         @q
        "             → should print the current line; does not
        "}}}
        call feedkeys(l:key, flags)
        return ''
    endif
endfu

" S-→    C-↑ …        modified arrow keys {{{4

" A terminal emulator gives its name to the programs through the shell
" environment variable $TERM.

" When Vim runs inside a terminal whose name begins with 'xterm' (xterm,
" xterm-256color), it automatically sets up a few keys including the modified
" arrow keys (S-Left, S-Right, C-Up, C-Down …).
"
" However, if the name  of the terminal begins with 'screen'  or 'tmux', it does
" NOT set up those keys.
" For  tmux   to  function  properly,   we  have  configured  ~/.shrc   so  that
" $TERM=tmux-256color (in tmux only, not in basic terminal emulator).
" Because of this, Vim does NOT set up the modified arrow keys when we run it
" inside tmux. This means we can't map any action to a modified arrow key.
" For example, by default Vim moves the cursor by word in normal mode when we
" hit S-Left / Right.
"
" We need to set up the modified arrow keys ourselves.

" To understand the code, read:
"
"         http://superuser.com/q/401926
"
" See also: :h xterm-modifier-keys
"
" :h version7:
"
"         Not all modifiers were recognized for xterm function keys.  Added the
"         possibility in term codes to end in ";*X" or "O*X", where X is any
"         character and the * stands for the modifier code.
"         Added the <xUp>, <xDown>, <xLeft> and <xRight> keys, to be able to
"         recognize the two forms that xterm can send their codes in and still
"         handle all possible modifiers.
"
" The `*` in the next code stands for the modifier `C-`, `S-`, `M-`.
" While the `x` is there because it seems that `xterm` can send codes in
" 2 forms.

if &term =~# '^\%(screen\|tmux\)'
    sil! exe "set <xUp>=\e[1;*A"
    sil! exe "set <xDown>=\e[1;*B"
    sil! exe "set <xRight>=\e[1;*C"
    sil! exe "set <xLeft>=\e[1;*D"
endif

" C-g C-g             show info about current file {{{4

nno  <c-g><c-g>  <c-g>

" C-np                move across tab pages {{{4

nno  <silent>  <c-p>  :<c-u>tabprevious<cr>
nno  <silent>  <c-n>  :<c-u>tabnext<cr>

" C-z    {{{4

" Sometimes, when I  hit C-z by accident, it makes  Vim quit unproperly (crash?)
" and leaves swap files, which is annoying:
"
"         • maybe we wanted to put Vim in the background, to use the shell
"         • now we need to remove the swap files before reloading the session

" The purpose  of these mappings  is to decrease the  frequence of this  kind of
" accident.
nno  <c-z>            <nop>
nno  <c-z><c-z>       <nop>
nno  <c-z><c-z><c-z>  <c-z>

" M-m                 matchadd / matchdelete search pattern {{{4

fu! s:where_are_my_matches() abort
    if exists('w:my_matches')
        sil! call matchdelete(w:my_matches)
        unlet! w:my_matches
    else
        let w:my_matches = matchadd('WildMenu', '\c'.@/, 10)
    endif
endfu

nno  <silent>  <m-m>  :<c-u>noh <bar> call <sid>where_are_my_matches()<cr>

" M-n    M-p          navigate between marks {{{4

nno  <m-n>  ]'
nno  <m-p>  ['

" =A                  toggle alignment {{{3

nno  <silent>  =A  :<c-u>set opfunc=myfuncs#op_toggle_alignment<cr>g@
xno  <silent>  =A  :<c-u>call myfuncs#op_toggle_alignment('vis')<cr>

" >b  <b              create/destroy box {{{3

" Draw a box around the text inside the paragraph.
" The fields must be separated with `|`.
" The function will populate the `s` and `x` registers with 2 kind of
" separation lines. We can paste them to fine tune the box.
nmap           >b                          <plug>(myfuncs_box_create)
nno   <silent> <plug>(myfuncs_box_create)  :<c-u>call myfuncs#box_create()<cr>

" undo the box, make it come back to just bars between cells
nmap           <b                           <plug>(myfuncs_box_destroy)
nno  <silent>  <plug>(myfuncs_box_destroy)  :<c-u>call myfuncs#box_destroy()<cr>

" =d                  fix display {{{3

" In normal mode, we remapped `C-l` to give the focus to the right window.
" But by default, `C-l` redraws the screen by executing `:redraw!`.
"
" So, we need to bind `:redraw!` to another key, `=d` could be a good
" candidate.

nno  <silent>  =d  :<c-u>call <sid>fix_display()<cr>

fu! s:fix_display() abort
    " redraw screen
    redraw!
    " redraw all status lines
    redraws!
    " update differences between windows in diff mode
    diffupdate!
    " update folds
    norm! zx

    " Purpose:{{{
    "
    " Reset the min/max number of lines above the viewport from which Vim begins
    " parsing the buffer to apply syntax highlighting.
    "
    " Sometimes syntax highlighting is wrong, these commands should fix that.
    "
    " We could also be more radical, and execute:
    "
    "     :syntax sync fromstart
    "
    " But after we execute it in our `vimrc`, every time we source our vimrc, we
    " experience lag.
    "}}}
    syntax sync minlines=200
    syntax sync maxlines=400
endfu

" =m                  fix macro {{{3

" Usage:
"     =ma  →  edit macro a
"     …
"     =mz  →  edit macro z
nno  <expr><silent>  =m  <sid>fix_macro()

fu! s:fix_macro() abort
    let c = getchar()
    if c < 97 || c > 123
        call timer_start(0, {-> execute('redraw')})
        return ''
    endif
    let c = nr2char(c)
    return printf("q:ilet @%s = \<c-r>\<c-r>=string(@%s)\r\e0f'", c, c)
endfu

" ':                  NOTE: {{{3

nno  <silent> ':   o<cr>NOTE:<esc>
                  \:center <bar> call append(line('.') - 1, '')<cr>
                  \o<cr>0<c-d><tab><tab><tab>

" ""                  easier access to system register  {{{3

" We don't tweak 'cb' anymore, because it causes too many issues.

nno  ""  "+
xno  ""  "+

" { }                 move by paragraphs {{{3

nno  <silent>  {  :<c-u>call search('\v(^\s*$<bar>%^)\_s*\zs\S', 'bW')<cr>zv
nno  <silent>  }  :<c-u>call search('\v\S+.*\ze\n\s*$', 'W')<cr>zv

" c*                  change word under cursor {{{3

" What you need to know to understand these mappings:
"
"       cgn    change next occurrence of search register
"       cgN    change previous occurrence of search register
"
"       we've enabled 'ignorecase', because it's convenient for a broader search
"       we've enabled 'smartcase', to make Vim a bit smarter:
"
"               if the search register contains uppercase characters, we
"               probably want to take the case into account
"
"       `*` and `/` are resp. stupid and clever, because the former ignores
"       'smartcase' while the latter respects it
"
"       the `c*` mapping uses `*` to populate the search register
"       so, it will be stupid, and we need to make it clever:
"               /<up><cr>``
"               │
"               └─ fixes `*` stupidity


"        ┌─ populate search register with word under cursor
"        │
"        │┌─ get back where we were
"        ││
"        ││          ┌─ get back where we were
"        ││          │
"        ││          │   ┌ change next occurrence of pattern
"        ││          │ ┌─┤
nno  c*  *``/<up><cr>``cgn
"           └───────┤
"                   └ take 'smartcase' into account

nno  c#  #``/<up><cr>``cgN


" We also install `cg*` and `cg#` if we want to look for the word under the
" cursor WITHOUT the anchors `\<`, `\>`.
nno  cg*  g*``/<up><cr>``cgn
nno  cg#  g#``/<up><cr>``cgN

" crg                 coerce to glyph {{{3

" The behavior of this operator can be customized via
" g:Unicode_ConvertDigraphSubset.
" Have a look at: ~/.vim/after/plugin/abbrev.vim

nmap  crg   <plug>(MakeDigraph)
nmap  crgg  <plug>(MakeDigraph)_

" crs                 coerce to snake case (repeatable) {{{3

nno  <silent>  crs  :<c-u>call <sid>my_crs()<cr>

fu! s:my_crs() abort
    let view = winsaveview()
    " populate search register with original word
    norm! *``
    call winrestview(view)
    let pat = @/
    "                           ┌ snake case
    "                           │     ┌ matters for undo (?)
    "                           │     │┌ type the keys now
    "                           │     ││
    call feedkeys("\<plug>Coerces", 'itx')
    " save the coerced word
    let rep = expand('<cword>')

    " Why do we need to restore the search register?{{{
    "
    " Vim  automatically  restores  the  value  it  had  before  a  function  is
    " invoked. Here, we don't want that, because  it will interfere with the dot
    " command.
    "
    " We need to undo this automatic restoration.
    "}}}
    call timer_start(0, {-> execute('let @/ = '.string(pat))})

    " Make the  dot command repeat this  edition for the next  occurrence of the
    " pattern.
    sil! call repeat#set('cgn'.rep."\e")
endfu

" dr                  replace without yank {{{3

" We save the name of the register which was called just before `dr` inside
" a script-local variable (`s:replace_reg_name`) through the `myfuncs#set_reg()`
" function. Why?
" Because if we repeat the operation with `.`, we want the operator to look
" for the replacement text from the same register that we used the first time.
" The dot command doesn't save that information.
" So, we have to do it manually.

" TODO:
" maybe we could get rid of `myfuncs#set_reg()` and use `repeat#setreg()` instead.

nno  <silent>  dr  :<c-u>call myfuncs#set_reg(v:register)
                   \<bar>set opfunc=myfuncs#op_replace_without_yank<cr>g@

nno  <silent>  drr  :<c-u>call myfuncs#set_reg(v:register)
                    \<bar>set opfunc=myfuncs#op_replace_without_yank
                    \<bar>exe 'norm! '.v:count1.'g@_'<cr>

" j  k  ^  0  $       gj  gk  … {{{3

" By default, we can't move across several lines of a long wrapped line with
" `j` and `k`.
"
"                       ┌─ if we used a count, we probably don't care about wrapped lines
"                       │
nno  <expr><silent>  j  v:count ? (v:count >= 5 ? "m'".v:count : '').'j' : 'gj'
nno  <expr><silent>  k  v:count ? (v:count >= 5 ? "m'".v:count : '').'k' : 'gk'
"                                 └────────────────────────────────┤
"                                                                  └ if the count was bigger than 5,
"                                                                    we consider the motion as a jump
"                                                                    useful to come back with `c-o`

" If we're inside a long wrapped line, `^` and `0` should go the beginning
" of the line of the screen (not the beginning of the long line of the file).
nno  <silent>  ^  g^
nno  <silent>  0  g0

" To draw freely, sometimes we need to enable 'virtualedit'.
" And then, when we hit `$`, the cursor moves to the very end of the screen.
" We never want that. We want the cursor on the last non whitespace.
nno  <expr>  $  &virtualedit is# 'block' ? 'g$' : 'g_'

" FIXME:
" Consider the following buffer:
"     foo = a
"           ab
"           abc

" If I want to surround a, ab and abc with single quotes, I could do:
"         :set startofline
"         C-v G h A '
"         :nunmap $
"         $ .

" But if instead of hitting `$`, I hit `g$`, the ending quote is too far:
"       foo = 'a     '
"             'ab    '
"             'abc   '

" Why does the dot command changes its behavior when we hit `g$`.
" According to :h g$, `g$` differs from `$` when:
"
"         • preceded with a count
"         • on a wrapped line
"         • on a line longer than the screen
"         • if 'virtualedit' is enabled
"
" Here, none of these conditions is met. So what happens?
" Should I unmap `$` in normal mode?
"
" Hypothesis:
" Maybe it has something to do with :h visual-repeat:
"
"         If the "$" command was used as one of the last commands to extend
"         the highlighted text, the repeating will be applied up to the rightmost
"         column of the longest line.


" Same mappings for visual mode.
xno  <silent>  j  gj
xno  <silent>  k  gk
xno  <silent>  ^  g^
xno  <silent>  0  g0

" H  L                collapse/expand all folds {{{3

nno  H  zMzz
nno  L  zRzz

" J        gJ         join without moving {{{3

nno  <silent>  J  @="mzJ`z"<cr>

" gJ doesn't insert or remove any spaces
nno  <silent>  gJ  @="mzgJ`z"<cr>

" Q        q {{{3

" Par défaut, Q fait passer en mode Ex, un mode d'édition dans lequel:
" on n'interagit qu'avec des commandes Ex
" pas besoin de taper : au début de chaque nouvelle commande
" l'écran n'est pas mis à jour après chaque édition
"
" C'est un mode adapté lorsqu'on travaille sur une machine distante avec
" laquelle il y a beaucoup de lag.
"
" On entre souvent dans ce mode par erreur. Pour en sortir, il faut taper
" :vi[sual]
" Pour ne plus entrer dans ce mode par accident, on remap Q à q.
nno  Q  q

" Y        y$ {{{3

nno  Y  y$

" We can't separate a register name from the `y` command, with a motion.
" They  must be consecutive. Otherwise the  yanking fails to target  the desired
" register. MWE:
"
"         C-v 3j "+ $ y    ✘
"         C-v 3j $ "+ y    ✔
"
" As  soon as  we type  the `$`  motion, the  register name  is lost  (watch the
" command-line).
" So, we use an  expression, to make sure that they are consecutive.
xno  <expr>  Y  '$"'.v:register.'y'

" yc / yC    ym / yM      yank comments / Code  matching / non-matching lines {{{3

" comments
nno  <silent>  yc   :<c-u>call myfuncs#op_yank_matches_set_action(1, 1)
                    \<bar> set opfunc=myfuncs#op_yank_matches<cr>g@
xno  <silent>  myc  :<c-u>call myfuncs#op_yank_matches_set_action(1, 1)
                    \<bar> call myfuncs#op_yank_matches('vis')<cr>

" Code
"                      don't yank where a commented line is found ┐
"                                                                 │
nno  <silent>  yC   :<c-u>call myfuncs#op_yank_matches_set_action(0, 1)
                    \<bar> set opfunc=myfuncs#op_yank_matches<cr>g@
xno  <silent>  myC  :<c-u>call myfuncs#op_yank_matches_set_action(0, 1)
                    \<bar> call myfuncs#op_yank_matches('vis')<cr>

" lines matching last search
nno  <silent>  ym   :<c-u>call myfuncs#op_yank_matches_set_action(1, 0)
                    \<bar> set opfunc=myfuncs#op_yank_matches<cr>g@
xno  <silent>  mym  :<c-u>call myfuncs#op_yank_matches_set_action(1, 0)
                    \<bar> call myfuncs#op_yank_matches('vis')<cr>

" lines which do NOT match last search
nno  <silent>  yM   :<c-u>call myfuncs#op_yank_matches_set_action(0, 0)
                    \<bar> set opfunc=myfuncs#op_yank_matches<cr>g@
xno  <silent>  myM  :<c-u>call myfuncs#op_yank_matches_set_action(0, 0)
                    \<bar> call myfuncs#op_yank_matches('vis')<cr>

" OBJECTS {{{2
" i% {{{3

" OLD CODE:{{{
"
"                    ┌ move cursor to next surrounding symbols
"               ┌────┤
"               │    │          ┌ do NOT add a bang:
"               │    │          │ it would break the mapping for custom text-object like `i“`
"               │    │          │
" xno <silent> i% <esc>%:exe 'norm vi'.matchstr(getline('.'), '\%'.col('.').'c.')<cr>
"                                    │
"                                    └ surrounding symbol
"
"                                      We could also use:
"
"                                              getline('.')[col('.')-1]<cr>
"
"                                      … but it would not work for multibyte characters.
"}}}
" Why don't we use the old code anymore?{{{
"
" The new  one takes  into consideration  all pairs  stored in  the buffer-local
" value of 'mps'. Including “” and ‘’.
"}}}
" Could the new code be improved?{{{
"
" Yes, currently  it doesn't always  work on multiline text-object,  because the
" initial `%` finds an opening symbol, reliably, only when it's on the last line
" of the text-object.
"
" MWE:
"
"         (foo
"         b|ar
"         baz)
"
"         “foo
"         bar
"         b|az”
"
" Press `vi%`, while the cursor is on the bar.
"
"}}}
" Why no `v_a%`?{{{
"
" It would shadow `v_a%` from the `matchit` plugin:
"
"         xno <silent> a% <Esc>%v%
"         ono <silent> a% :norm va%<cr>
"}}}
xno  <silent>  i%  <esc>:call <sid>select_percent_object()<cr>
ono  <silent>  i%  :norm vi%<cr>

fu! s:select_percent_object() abort
    let pos = getpos('.')
    " search for a closing/opening symbol
    norm! %
    if getpos('.') ==# pos
        return
    endif
    " save closing/opening symbol
    let sym = matchstr(getline('.'), '\%'.col('.').'c.')
    " Maybe we could speed the process by storing the next 2 values in buffer-local
    " variables every time `FileType *` is fired. Not sure it's worth it.
    let opening_syms = map(split(&l:mps, ','), { i,v -> matchstr(v, '.')} )
    let closing_syms = map(split(&l:mps, ','), { i,v -> matchstr(v, '.$')} )
    " check it is indeed in 'mps'
    if index(opening_syms, sym) < 0 && index(closing_syms, sym) < 0
        return
    endif
    " check we're on a closing symbol
    if index(opening_syms, sym) >= 0
        norm! %
    endif
    " select object and quit to set the marks
    exe "norm! v%\e"
    " check there's at least one character inside the object
    if getline("'<") ==# getline("'>") && virtcol("'>") ==# virtcol("'<") + 1
        return
    endif
    norm! gvloh
endfu

" iE {{{3

" Entire buffer
" We don't use `ie` but `iE`, because `ie` is too easily typed.
" We could easily delete the whole buffer `cie`, `die` by mistake.

xno  <silent>  iE  G$ogg0
ono  <silent>  iE  :<c-u>norm ViE<cr>

" if {{{3

" Vim function

" FIXME:
" not reliable text objects (check out kana plugin)
" fix also `o_il` and `o_al` (i.e. add support for visual mode)
xno  <silent>  if  :<c-u>call <sid>textobj_func(1)<cr>
ono  <silent>  if  :<c-u>norm Vif<cr>

xno  <silent>  af  :<c-u>call <sid>textobj_func(0)<cr>
ono  <silent>  af  :<c-u>norm Vaf<cr>

fu! s:textobj_func(inside) abort
    if search('^\s*fu\%[nction]', 'bcW')
        k<
        call search('^\s*endf\%[unction]\s*$', 'eW')
        k>
        exe 'norm! gv$'.(a:inside ? 'koj' : '')
        exe 'norm! gv$'.(a:inside ? 'koj' : '')
        " we want a linewise selection no matter the original visual mode
        exe (mode() isnot# 'V' ? 'norm! V' : '')
    endif
endfu

" il {{{3

" `il` = in line (operate on the text between first and last non-whitespace on the line)
" Useful to copy a line and paste it characterwise (in the middle of another line)

ono  <silent>  il  :norm! _vg_<cr>
ono  <silent>  al  _

" We don't need to create `al` (around line) to operate on the whole line
" including newline, because `_` can be used instead.
" Example:
"
"     +y_
"     +y3_
"
" … add current line to plus register (`+y` = custom operator, incremental yanking).
" Besides, an operator should be able to operate on the current line when it's
" repeated (`cc`, `yy`, `dd`…).
" But still, it brings consistency/symmetry.

" SELECT {{{2

" DWIM:
" move to left/right in select mode (useful for UltiSnips)
snor  <c-b>  <esc>i<left>
snor  <c-f>  <esc>i<right>

" After expanding a snippet, I want to be able to delete the character after
" the cursor with C-d like in insert mode.
snor  <c-d>  <esc>i<del>

" TERMINAL {{{2

" In Vim, we can't use `esc` in the  lhs of a mapping, because any key producing
" a  sequence of  keycodes  containing Esc,  would be  subject  to an  undesired
" remapping (m-b, m-f, left, right, …).
"
" Example:  `M-b`  produce Escape  (go to  Terminal-Normal mode)  + b  (one word
" backward). We DO  want to go one  word backward, but  we also want to  stay in
" Terminal-Job mode.
"
" Neovim doesn't suffer from this issue.
" So, to  go from Terminal-Job mode  to Terminal-Normal mode, we  could use this
" mapping:
"
"         exe 'tno '.(has('nvim') ? '<esc>' : '<esc><esc>').' <c-\><c-n>'
"
" But  I prefer to  stay consistent. Double Escape in  Vim → double  escape in
" neovim.
" TODO:
" Find a  way to send  an Escape  key to the  foreground program running  in the
" terminal. Maybe something like this:
"
"         exe "set <m-[>=\e["
"         tno  <m-[>  <esc>
"
" It doesn't work, but you get the idea.
tno  <esc><esc>  <c-\><c-n>

" Do NOT add this mapping:  tno  <esc>:  <c-\><c-n>:{{{
"
" Why?
"
"     z<      open a terminal
"     Esc :   enter command line
"     Esc     get back to terminal normal mode
"     z>      close terminal
"
" The meta keysyms are disabled.
" }}}
"}}}
" VISUAL {{{2
" C-s {{{3

" Search inside visual selection
" What difference with :*ilist! foobar ?
" `:ilist`:
"
"     • searches in all included files. :g only in current buffer.
"     • can ignore comment if we don't put a bang
"     • automatically adds \<,\> around the pattern, if we don't surround it with slashes

xno  <c-s>  <esc>:keepj keepp *g/\%V/#<left><left>

" /           search only in visual selection {{{3

xno  /   <esc>/\%V

" restore original slash
xno  g/  /

" .    @ {{{3

" Repeat last edit on all the visually selected lines with dot
xno  <silent>  .  :norm .<cr>
" We don't put a bang at the end of :norm. Why ?
" Because it seems to prevent the repetition of a custom operator
" and object, such as `ysil`.

" Repeat last macro on all the visually selected lines with @{reg}
" The following mappings doesn't work, because the last carriage return which
" executes the command (norm @q^M) is moved before the register name (norm @^Mq)
"
"     xno <silent> @ :norm @<c-r>=nr2char(getchar(),1)<cr><cr>
"
" The reason is probably because input() consumes the remaining characters
" from the mapping. At the end of the mapping, there's a CR.
" When input() is called it consumes it, instead of just waiting for our
" input.
" The solution would be to use inputsave() / inputrestore(), but that would
" make the mapping uselessly complex.
xno  <silent>  @  :<c-u>exe "'<,'>norm @".nr2char(getchar(),1)<cr>
"                                    │
"                                    └─ do NOT add a bang:
"                                       we want the recursiveness, for one of our mapping to be used
"                                       it temporarily disables some keysyms which may break the replay
"                                       of a macro

" A  I  gI    niceblock {{{3

" https://github.com/kana/vim-niceblock/blob/master/doc/niceblock.txt
"
" v_b_I = Visual-block Insert
" v_b_A = Visual-block Append
"
"         • Make |v_b_I| and |v_b_A| available in all kinds of Visual mode.
"         • Adjust the selected area to be intuitive before doing blockwise insertion.

fu! s:niceblock(key) abort
    let niceblock_keys = {
    \   '$'    : {'v': 'g$h',      'V': '$',          "\<c-v>": '$'},
    \   'I'    : {'v': "\<c-v>I",  'V': "\<c-v>^o^I", "\<c-v>": 'I'},
    \   'A'    : {'v': "\<c-v>A",  'V': "\<c-v>0o$A", "\<c-v>": 'A'},
    \   'gI'   : {'v': "\<c-v>0I", 'V': "\<c-v>0o$I", "\<c-v>": '0I'},
    \   '>'    : {'v': "\<c-v>>",  'V': "0\<c-v>>",   "\<c-v>": '>'},
    \   '<'    : {'v': "\<c-v><",  'V': "0\<c-v><",   "\<c-v>": '<'},
    \
    \   'C-a'  : {'v': "\<c-v>".v:count1."\<c-a>",  'V': v:count1."\<c-a>",  "\<c-v>": v:count1."\<c-a>"},
    \   'C-x'  : {'v': "\<c-v>".v:count1."\<c-x>",  'V': v:count1."\<c-x>",  "\<c-v>": v:count1."\<c-x>"},
    \   'g C-a': {'v': "\<c-v>".v:count1."g\<c-a>", 'V': v:count1."g\<c-a>", "\<c-v>": v:count1."g\<c-a>"},
    \   'g C-x': {'v': "\<c-v>".v:count1."g\<c-x>", 'V': v:count1."g\<c-x>", "\<c-v>": v:count1."g\<c-x>"},
    \ }

    return niceblock_keys[a:key][mode()]
endfu


" The purpose of this mapping is to not include a newline when selecting
" a characterwise text until the end of the line.
xno  <expr>  $  <sid>niceblock('$')

xno  <expr>  I   <sid>niceblock('I')
xno  <expr>  gI  <sid>niceblock('gI')
xno  <expr>  A   <sid>niceblock('A')

" Why these assignments:
"
"         niceblock_keys['>']['V'] = "0\<c-v>>"
"         niceblock_keys['<']['V'] = "0\<c-v><"
"
" … and not simply:
"
"         niceblock_keys['>']['V'] = ">"
"         niceblock_keys['<']['V'] = "<"
"
" ? Because, without "\<c-v>", sometimes the alignment is lost.

xno  <expr>  >  <sid>niceblock('>')
xno  <expr>  <  <sid>niceblock('<')

xno  <expr>  <c-a>   <sid>niceblock('C-a')
xno  <expr>  <c-x>   <sid>niceblock('C-x')
xno  <expr>  g<c-a>  <sid>niceblock('g C-a')
xno  <expr>  g<c-x>  <sid>niceblock('g C-x')

" d y         preserve last deleted/yanked visual selected text through registers {{{3

" when we delete sth in visual mode to move it somewhere else, if we delete
" sth else before pasting it, we lose it (well technically it's still
" accessible from a numbered register, but if we delete several things, we
" have to execute `:reg` to see where it is now)

" with this mapping, we can always access the last text we deleted in visual
" mode, from the `v` register
xno  <expr><silent>  d  'd'.timer_start(0, {-> execute('let @v=@"')})[-1]

" same thing when we yank
xno  <expr><silent>  y  'y'.timer_start(0, {-> execute('let @v=@"')})[-1]

" h l         disable at the beginning/end of line in visual block mode {{{3

xno  <expr>  h  mode() is# '<c-v>' && virtcol('.') ==# 1            ? '' : 'h'
xno  <expr>  l  mode() is# '<c-v>' && virtcol('.') ==# &columns - 2 ? '' : 'l'

" ip          disable on empty line {{{3

" sometimes I hit `vip` by accident on an empty line
" annoying, because it can make me lose previous visual selection
" (you can cycle through the last 2 visual selections with `gv`)

nno  <expr><silent>  vip  getline('.') =~# '^\s*$' ? '' : 'vip'

" gJ  g C-j   join lines {{{3

" We use J to move the selection down. The J command needs to be restored.
xno  gJ       J
" Now `gJ` needs to be restored.
xno  g<c-j>  gJ

" mJ  m C-j   join blocks {{{3

" Difference compared to :JoinBlocks?:
"
"   • easier to use;  no need to position the cursor on
"                     the first line of the 2nd block
"                     no need to provide the nr of lines in a block
"                     as an argument
"
"   • not repeatable; each time we call it, we must first visually select
"                     the lines (or provide an arbitrary range)
"                     :JoinBlocks can be repeated simply by typing @:


" How does `join_blocks()` work?
" It mainly executes 3 commands:
"
"   • insert a literal ^A in front of all the lines in the 2nd block
"   • join the 2 blocks
"   • align the blocks using ^A as a delimiter

xno  <silent>  mJ      :<c-u>call myfuncs#join_blocks(0)<cr>
xno  <silent>  m<c-j>  :<c-u>call myfuncs#join_blocks(1)<cr>
"                                                     │
"                                                     └─ first, reverse the order of the blocks
"                                                        then, join them

" COMMANDS {{{1
" Warning:{{{
"
" Do NOT use `vimrc`  to create commands which are only  relevant for a specific
" type of buffer.  Those should be defined  in a plugin, or in a filetype plugin
" with the `-buffer` attribute.
"}}}
" CGrep / LGrep {{{2

" :Grep / :LGrep are custom commands which grep for a pattern across a set of
" files using the external shell program defined by the option 'grepprg'.
" At the moment, it's `$ ag`.
" Usage:
"         CGrep pattern
"
" Don't type:
"         CGrep pattern .
"                       │
"                       └─ ✘ current directory
"                            our command would include ` .` inside the pattern
"                            literally (because of `shellescape() which quotes
"                            the whole argument`)

com! -bar -complete=file -nargs=+  CGrep  call myfuncs#op_grep('Ex', <q-args>, 0)
com! -bar -complete=file -nargs=+  LGrep  call myfuncs#op_grep('Ex', <q-args>, 1)

" Doc    {{{2

" Usage:
"
"                          Look for:
"         ┌───────────────┬─────────────────────────────────────────────────┐
"         │ :Doc          │ word under cursor, scoped with current filetype │
"         ├───────────────┼─────────────────────────────────────────────────┤
"         │ :Doc div      │ keyword `div`,     scoped with current filetype │
"         ├───────────────┼─────────────────────────────────────────────────┤
"         │ :Doc html div │ keyword `div`,     scoped with html             │
"         └───────────────┴─────────────────────────────────────────────────┘

com! -bar -nargs=* Doc call s:doc(<f-args>)

fu! s:doc(...) abort
    let cmd = 'xdg-open'
    " For the syntax of the query, see this link:
    "         https://devdocs.io/help#search
    let url = 'http://devdocs.io/?q='

    let args = a:0 ==# 0
           \ ?     url.&ft.' '.expand('<cword>')
           \ : a:0 ==# 1
           \ ?     url.&ft.' '.a:1
           \ :     url.join(a:000)

    sil! call system(cmd.' '.string(args))
endfu

" DiffOrig {{{2

" See differences between current buffer and original file.
com! -bar DiffOrig echo s:diff_orig()

fu! s:diff_orig() abort
    sil call save#toggle_auto(0)
    let cole_save = &l:cole
    setl cole=0

    let tempfile = tempname().'/Original File'
    exe 'vnew '.tempfile
    setl bt=nofile nobl noswf nowrap

    sil 0r #
    $d_
    setl noma ro

    nno  <buffer><nowait><silent>  q  :<c-u>close<cr>

    diffthis
    nno  <buffer><nowait><silent>  q  :<c-u>close<cr>
    let &ft = getbufvar('#', '&ft')

    let s:tmp_partial = function('s:diff_orig_restore_settings', [cole_save])
    augroup diff_orig_restore_settings
        au! * <buffer>
        au BufWipeOut <buffer> sil call save#toggle_auto(1)
        \|                     call timer_start(0, s:tmp_partial)
    augroup END

    exe winnr('#').'windo diffthis'
    return ''
endfu

fu! s:diff_orig_restore_settings(cole,_) abort
    exe 'setl cole='.a:cole
    diffoff!
    norm! zvzz
    aug! diff_orig_restore_settings
    unlet s:tmp_partial
endfu

" DumpWiki {{{2
" Usage:
"         DumpWiki https://github.com/oniony/TMSU/

com! -bar -nargs=1 DumpWiki call myfuncs#dump_wiki(<q-args>)

" Hex2Dec {{{2

" This command converts numbers from hex to decimal (and the reverse with
" a bang). It uses the shell command 'bc'. For example, if we type:
"
"     :Hex2Dec 2026
"
"         … sends to the shell:
"
"     $ echo "ibase=16;obase=A;2026" | bc
"
" And thus displays 8230.

com! -bar -bang -nargs=1 Hex2Dec echo expand('`echo "ibase='.(<bang>0 ? 'A' : '16')
\                                                 .';obase='.(<bang>0 ? '16' : 'A')
\                                                 .';'.<q-args>.'" | bc`')

" InANotInB {{{2

" This command outputs the lines which are in buffer A but not in buffer B.

com! -bar -nargs=+ -complete=buffer InAButNotInB call myfuncs#in_A_not_in_B(<f-args>)

" IsPrime {{{2

com! -bar -nargs=1 IsPrime echo lg#math#is_prime(<args>)

" JoinBlocks {{{2

" The following command joins 2 blocks of lines.
" To use it, you must:
"
"     • remove possible empty lines between the blocks
"     • be on the 1st line of the 1st block
"     • provide the nr of lines of a block as an argument to the command
"
" After an initial join, you can repeat it with @:

" How it works?{{{
"
" If the blocks are 5 lines long, the command will execute:
"
"             ┌ for each line of the first block (.,.+4g/^/)
"     ┌───────┤
"     .,.+4g/^/''+5m.|-j
"              └────┤ └┤
"                   │  └─ then join the two lines
"                   │
"                   └ move the first line of the second block (''+5) under the current one (m.)


" We can notice that the address of the 1st line of the 1st block is expressed
" in 2 different ways, depending on the context.
" Inside the range passed to `:g` it's `.` (current line).
" Inside the command executed by `:g`, it can't be `.` anymore (because the
" current line changes constantly), so here we use `''` instead.
" Indeed, before jumping to the first line to process, `:g` adds an entry in the
" jumplist, whose mark is `''`. So:
"
"             we're on the 1st line of the 1st block
"         and ''    is a line specifier for the latter
"         and a block has 5 lines
"
"         ⇒
"
"         ''+5    is a line specifier for the 1st line of the second block
"
" This shows that the range passed to `:g` is entirely processed BEFORE
" the command (here `:m`) it executes.
" Remember:
" `.` doesn't stand for the same line inside a range passed to `:g`, and inside
" a range passed to a command executed by the same `:g`.


" `:g` will cycle through the lines of the 1st block, and always move + join
" the SAME line:
"
"         the 1st of the 2nd block
"
" But, the contents of this line will constantly change. It will be successively:
"
"     • the 1st of the 2nd block
"     • the 2nd one (after the 1st has been joined)
"     • the 3rd one ("         2nd ")
"     • the 4th one ("         3rd ")
"     • the 5th one ("         4rd ")
"
" Why `-j`, and not simply `j` ?
" Because, when `:m` moves a line, the cursor doesn't stay where it is; it jumps
" onto the moved line.
" So, before joining the lines, we have to get back on the original line above
" (`-` = `.-1`).
"}}}

" This command isn't really needed (we have `v_mj`), but I keep it for educational
" purpose.

com! -bar -bang -nargs=1 JoinBlocks
\|                                  let &l:fen = 0
\|                                  exe "keepp .,.+<args>-1g/^/''+<args>m.|-j<bang>"
\|                                  let &l:fen = 1

" OnlySelection {{{2

" This command deletes everything except the current visual selection (or any
" arbitrary range).
"
" Usage:
"
"     :'<,'>OnlySelection
"     :12,34OnlySelection

com! -bar -range=% OnlySelection call myfuncs#only_selection(<line1>,<line2>)

" PA    PQ    populate arglist / qfl with shell command {{{2
"
" Usage:
"         :PA find /etc -name '*.conf'
"         :PQ grep -IRn foobar ~/.vim | grep -v backup

" We already have `:Grep`, so why `:PQ`?{{{
"
" `:Grep` (and `|g`) relies on the value of 'grepprg'.
" `:PQ` gives us more control on the grep program.
" For example, it allows us to pass the argument `-w` to `$ ag`:
"
"        ┌────────────────┬──────────────────────────────────────┐
"        │ :Grep      foo │ search any `foo` using   'grepprg'   │
"        ├────────────────┼──────────────────────────────────────┤
"        │ :PQ ag     foo │ search any `foo` using   `ag`        │
"        ├────────────────┼──────────────────────────────────────┤
"        │ :PQ ag -w  foo │ search a whole word `foo` using `ag` │
"        └────────────────┴──────────────────────────────────────┘
"                 -w --word-regexp
"                        Only match whole words.
"}}}
com! -bar -nargs=1 PA exe myfuncs#populate_list('arglist',  <q-args>)
com! -bar -nargs=1 PQ exe myfuncs#populate_list('quickfix', <q-args>)

" PI    Plugin Install {{{2

com! -bar -nargs=1 PI call myfuncs#plugin_install(<q-args>)

" PluginGlobalVariables {{{2

" Usage:
"
" PluginGlobalVariables ulti
"
"         → display all global variables containing the keyword `ulti`

com! -bar -nargs=1 PluginGlobalVariables call myfuncs#plugin_global_variables(<q-args>)

" PU    update Vim plugins {{{2

com! -bar PU call s:plugins_update()

fu! s:plugins_update() abort
    " Install `wfrench` package. Useful for dictionary completion.
    if expand('`aptitude show wfrench | sed -n "2p"`') =~? 'state:\s*not\s\+installed'
        echom 'Need to install the wfrench package for the french dictionary.'
        let password = inputsecret('Enter sudo password:')."\n"
        echo system('sudo -S aptitude install wfrench', password)
    endif
    " TODO:
    " Look for `\<install\>` in our notes, and refactor this function so that
    " it installs any package which may enhance Vim (`gem install coderay` ?).

    if !isdirectory($HOME.'/.vim/tmp/snapshot')
        call mkdir($HOME.'/.vim/tmp/snapshot', 'p')
    endif
    exe 'PlugSnapshot! '.fnameescape($HOME.'/.vim/tmp/snapshot/'.strftime('%d-%m_%H-%M').'.vim')
    "                                                                              │
    "                                   don't put a colon, it could be problematic ┘
    " Why a colon is a bad idea in a filename?{{{
    "
    " 1. It's not inside  the default value of 'isf'. Which means  that Vim
    "    doesn't consider this character  to be a part  of a filename when
    "    using  `\f` in a pattern.
    "
    " 2. In most buffers, the local value of 'efm' probably uses the `%f` item
    "    to match a filename. Here's what `:h error-file-format` says about
    "    the latter:
    "
    "         The "%f" conversion may depend on the current 'isfname' setting.
    "
    "    So, if you  try to parse the output  of a shell command, or  to read an
    "    error file/buffer  to populate the  qfl, Vim  will fail to  recognize a
    "    filename containing a colon. You'll get non-valid entries.
    "
    " 3. It's interpreted as a separator  in $PATH, so it can be dangerous if
    "    used in a directory.  And if we avoid the colon in a directory name,
    "    to stay consistent we should do the same in a filename.
    "
    " 4. It has a special meaning in  Windows, so if the file is copied on
    "    a different OS, it can cause an issue.
    "}}}
    " Which character are safe to use in a filename?{{{
    "
    "     [a-z]
    "     [A-Z]
    "     [0-9]
    "     .
    "     -
    "     _
    "
    " https://stackoverflow.com/a/458001/8243465
"}}}

    " wipe the Vim buffer containing the snapshot
    if getline(1) is# '" Generated by vim-plug'
        bw
    endif
    PlugUpgrade
    PlugUpdate
endfu

" RemoveDuplicateLines {{{2

com! -bang -bar -range=% RemoveDuplicateLines exe myfuncs#remove_duplicate_lines(<line1>,<line2>, <bang>0)

" RemoveSwapFiles {{{2

com! -bar RemoveSwapFiles call s:remove_swapfiles()

fu! s:remove_swapfiles() abort
    for swapfile in glob($HOME.'/.vim/tmp/swap/*', 1, 1)
        call delete(swapfile)
    endfor
endfu

" RemoveTabs {{{2

" The purpose of this command is to replace all tab characters in the buffer
" with a nr of spaces which will occupy the same nr of cells.
"
" Before using it, set 'ts' (2,4,8) so that the text is aligned.
com! -bar -range=% RemoveTabs call myfuncs#remove_tabs(<line1>,<line2>)

" Retab {{{2

" The system :retab command substitutes all the tabs from a file to spaces.
" We don't want that. We want a command which substitutes only leading tabs.
"
" Besides, :retab automatically chooses which substitution to do based on the
" value of &expandtab:    &et ? spaces → tabs : tabs → spaces
" We prefer to manually decide the type of substitution.
"
" So, we define the custom command :Retab which accepts a bang.
" :Retab  = tabs   → spaces
" :Retab! = spaces → tabs
" Mnemonic: we use spaces as the default way to indent, so it makes sense to
" to use a bang only for the less useful conversion: spaces → tabs

com! -bar -bang -range=% Retab call s:retab(<line1>,<line2>, <bang>0)

fu! s:retab(line1, line2, bang) abort
    let view = winsaveview()
    if !a:bang
        exe 'sil keepj keepp '.a:line1.','.a:line2.'s:^\t\+:\=repeat(" ", &ts * len(submatch(0))):e'
    else
        exe 'sil keepj keepp '.a:line1.','.a:line2.'s:\v^( {'.&ts.'})+:\=repeat("\t", len(submatch(0))/&ts):e'
    endif
    call winrestview(view)
endfu

" ReverseEveryNLines {{{2

com! -bar -range=% -nargs=1 ReverseEveryNLines call s:reverse_every_n_lines(<args>, <line1>, <line2>)

fu! s:reverse_every_n_lines(n, line1, line2) abort
    let mods = 'keepj keepp'
    let range = a:line1.','.a:line2
    let l:Address = { -> ( line('.')- a:line1 + 1 ) % a:n ? ( line('.') - a:line1 + 1 ) % a:n : a:n }
    sil exe mods.' '.range.'g/^/exe "m .-".l:Address()'
endfu

" SearchInternalVariables {{{2

" The purpose of this command is to place the cursor on a line where it thinks
" we assigned a value to a variable whose name is the same as an internal
" variable.
" It could help us avoid conflicts.
" Whenever the command finds such variable (`key`, `char`, `lnum`, …), we
" should put it in an explicit scope (s:, l:, …).
"
" Update:
" In reality,  it seems that  Vim puts a variable  inside a function  (and whose
" scope is not explicit) inside `v:` only for a very narrow set of variables:
"
"     • count
"     • errmsg
"     • shell_error
"     • this_session
"     • version
"
" Source:
"     https://github.com/Kuniwak/vint/issues/245#issuecomment-337296606
"
" Maybe we could just memorize those 5 variable names, and eliminate the command.

com! -bar SearchInternalVariables call myfuncs#search_internal_variables()

" SetIndent {{{2

com! -bar -nargs=1 -range SetIndent <line1>,<line2>call myfuncs#set_indent(<args>)

" ShowLongLines {{{2

" This command highlights in red the character after a given column.
" Repeat the command toggles the highlighting.

com! -bar -nargs=? ShowLongLines echo s:shll(<args>)

fu! s:shll(...) abort
    if !exists('w:shll')
        let w:shll = matchadd('Error', '\v%'.((a:0 ? a:1 : 80)+1).'v', 20)
    else
        call matchdelete(w:shll)
        unlet w:shll
        if a:0
        " we've executed 2 `:ShowLongLines` commands, probably with different arguments
        " we've just get rid of the old match of the previous command,
        " now we need to create a new one for the 2nd command
            call s:shll(a:1)
        endif
    endif
    return ''
endfu

" SortLines {{{2

" Commented for the moment. Keep it for educational purpose.

" " We define the :SortLines command which moves lines containing foo or bar at
" " the bottom. Lines containing foo are put before the ones containing bar.
" com! -bar -range=% SortLines <line1>,<line2>call s:sort_lines()

" fu! s:compare_lines(l1, l2) abort
"     " The greater the score, the further to the right in the sorted list
"     let score1 = a:l1=~ 'bar' ? 2 : a:l1 =~ 'foo'
"     let score2 = a:l2=~ 'bar' ? 2 : a:l2 =~ 'foo'
"     return score1 - score2
" endfu

" fu! s:sort_lines() abort range
"     let sorted_lines = sort(getline(a:firstline, a:lastline), 's:compare_lines')
"     let c = 0
"     for line in sorted_lines
"         call setline(a:firstline + c, line)
"         let c+=1
"     endfor
" endfu

" SumColumn {{{2

com! -bar -range SumColumn sil! keepj keepp <line1>,<line2>g/=\s*$/ t. | s/// | exe '.!bc' | -j

" TW {{{2

com! -bar -range=% TW call s:trim_whitespace(<line1>,<line2>)
fu! s:trim_whitespace(line1,line2) abort
    let view = winsaveview()
    exe 'keepj keepp '.a:line1.','.a:line2.'s/\s\+$//e'
    call winrestview(view)
endfu

" UnicodeToggle {{{2

" This command  looks for  special characters  \u or \U  + code  points (\u1234)
" inside the range of lines it received.
" If it  finds one,  it tries  to translate  all similar  ones into  the literal
" characters they stand for.
" If it doesn't find any \u...., it tries to do the reverse.
" Translate all characters whose code point  is above 255 (anything which is not
" in the extended ascii table) into special characters + code points.

com! -bar -range=% UnicodeToggle call myfuncs#unicode_toggle(<line1>,<line2>)

" WebPageRead {{{2

" this command opens a new tab page, loads a temporary buffer, and dumps
" the contents of a webpage inside the latter
com! -bar -nargs=1 WebPageRead call myfuncs#webpage_read(<q-args>)

" WordFrequency {{{2

" Display words in the current buffer sorted by frequency

com! -bar
\    -nargs=?
\    -range=%
\    -complete=custom,myfuncs#wf_complete
\            WordFrequency
\            call myfuncs#word_frequency(<line1>,<line2>, <q-args>)

" XorLines {{{2

" :XorLines allows to see and cycle through the differences between 2 lines.
" Usage: :5,10XorLines    diff between lines 5 and 10
"        :XorLines        diff between current line and next one
"        :XorLines!       clear the match
" The differences are in the location list (hit [l, ]l, [L, ]L to navigate).

com! -bar -bang -range XorLines <line1>,<line2>call myfuncs#xor_lines(<bang>0)

" AUTOCOMDS {{{1
" Command Window {{{2

" Form more ideas:
" http://vim.wikia.com/wiki/Enhanced_command_window

augroup my_cmdline_window
    au!
    au CmdWinEnter * nno  <buffer><nowait><silent>  q      :q<cr>
    au CmdWinEnter * nno  <buffer><nowait><expr>    <c-c>  '<c-c>'.timer_start(0, {-> execute('redraw')})[-1]
    " By default,  C-c is useful to  quit the command-line window,  and populate
    " the command-line with the command which was being edited in the window.
    " But, it doesn't get rid of the display of the command-line window.
    " Our `C-c` mapping takes care of that.

    " These autocmds try to update the command-line history of the current
    " session, and to make it persist across sessions, by overwriting
    " `~/.viminfo` every time some lines were deleted in the command-line
    " window.
    au CmdWinEnter : let s:old_cmd_hist = getline(1, line('$')-1)
    au CmdWinLeave : call s:update_history()
    "              │
    "              └─ only Ex command-line window
augroup END

" If one day you want to add support for the search window (`q/`, `q?`), be
" aware that it's tricky.
" It seems Vim merges both search history (/ + ?) in the window.
" Also, in `~/.viminfo`, an entry corresponding to a:
"
"         • forward  search,  begins with  `?/`
"         • backward search,  begins with  `? `  (note the space)

fu! s:update_history() abort
    " update history of current session
    "                               remove any command 5 characters long or shorter ┐
    "                                                                ┌──────────────┤
    let new_hist = filter(getline(1, '$'), { i,v -> v !~# '^\s*$' && v !~# '^.\{,5}$' })
    call histdel(':')
    for line in new_hist
        call histadd(':', line)
    endfor

    " no need to try and update `~/.viminfo` if the latter isn't readable
    let viminfo = expand($HOME.'/.viminfo')
    if !filereadable(viminfo)
        return
    endif
    let info = readfile(viminfo)

    " FIXME:
    " One of the next 2 lines should probably be improved, because it seems to
    " fail to delete an entry containing a literal CR.
    "
    "                                               ┌ take the old history
    "                            ┌──────────────────┤
    let deleted_entries = filter(copy(s:old_cmd_hist), { i,v -> index(new_hist, v) ==# -1 })
    "                                                           └───────────────────────┤
    "               … and keep only the entries which aren't in the new history anymore ┘
    "
    " convert the text entries to delete, into their numeric indexes inside
    " the list `info`
    call map(deleted_entries, { i,v -> index(info, ':'.v) })

    " sort them, and check they were all found (no -1)
    call sort(filter(deleted_entries, { i,v -> v >= 0 }))
    if empty(deleted_entries)
        return
    endif

    " every time we delete a line, the addresses of the next ones decrease by
    " one; to not have to update the addresses after each removal, delete the
    " lines in reverse order
    for entry in reverse(deleted_entries)
        call remove(info, entry, entry + 1)
    endfor
    call writefile(info, viminfo, 'b')
endfu

" Create Missing Directory {{{2

fu! s:make_missing_dir(file, buf) abort
    " Before creating a directory, make sure that the current buffer:
    "
    "     • is not a special one    :h special-buffers
    "     • is not a remote file    ftp://…
    "
    " Found here:    http://stackoverflow.com/a/4294176

    if empty(getbufvar(a:buf, '&buftype')) && a:file!~#'\v^\w+\:\/'
        let dir = fnamemodify(a:file, ':h')
        if !isdirectory(dir)
            call mkdir(dir, 'p')
        endif
    endif
endfu

augroup make_missing_dir
    au!
    au BufWritePre * call s:make_missing_dir(expand('<afile>'), expand('<abuf>'))
augroup END

" Default Extension {{{2

" Temporarily commented, because I find it annoying now with `.vim`.
" Keep it, because it could still be useful for other extensions.

" augroup DefaultExtension
"     au!
"     au BufNewFile * nested call s:default_extension(expand('<afile>:p'))
" augroup END

" fu! s:default_extension(buffer) abort
"
"     " If the buffer name ends with a dot, it's probably a mistake.
"     " We don't want to add a default extension.
"     " We would end up with a buffer whose name contains a sequence of
"     " consecutive dots.
"     " Besides, if this is a mistake, we need to let the buffer name unchanged
"     " so that our autocmd `didyoumean` has a chance of fixing it, by
"     " suggesting alternatives.
"
"     if a:buffer[-1:-1] is# '.'
"         return
"     endif
"
"     " If the buffer is created inside /tmp and has no extension
"     if strpart(fnamemodify(a:buffer, ':p:h'),0,4) is# '/tmp' && empty(fnamemodify(a:buffer, ':e'))
"
"         " make sure it will be wiped when it's hidden
"         " which will happen after the next command
"         setlocal bufhidden=wipe
"
"         " edit a new buffer with the same name + the .vim extension
"         exe 'keepalt edit ' . fnameescape(a:buffer) . '.vim'
"
"         " Why fnameescape()? Suppose we type :e foo\ bar to open a buffer
"         " whose name is 'foo bar'.
"         " The function will receive as an argument 'foo bar' (the backslash
"         " has been removed once Vim processed the :edit command).
"         " Then, the previous instruction will result in: :edit foo bar.vim
"         " and Vim will complain with: E172: Only one file name allowed
"         " We have to reprotect the space with fnameescape().
"         "
"         " Security_measure:
"         " if the previous command fails without  giving an error, and we stay in
"         " our current buffer  whose 'bufhidden' option's local  value is 'wipe',
"         " we want to  remove the latter (so  that the global value  is used like
"         " before). If it fails with an error,  the rest of the function won't be
"         " executed though.
"         set bufhidden<
"
"     endif
" endfu

" Delete Noname Buffers {{{2

" We want to automatically delete buffers which are empty and don't have a name.
" So we install an autocmd listening to `BufHidden`.

augroup delete_noname_buffers
    au!
    " Why delay `s:dnb_clean()`?{{{
    "
    " It seems the BufHidden event occurs just before a buffer becomes hidden.
    " Because of this, calling `s:dnb_clean()` immediately would delete all noname
    " buffers, except the most recent one we're creating by closing its last window.
    "
    " We have to wait a little bit, to be sure that the last noname buffer we've
    " closed is really hidden.
    "
    " An alternative would be to call an intermediary function which would install
    " a fire-once autocmd listening to BufEnter (this event happens right after
    " BufHidden). At that moment, we could be sure the last hidden noname buffer
    " is really hidden. And the autocmd would just have to call `s:dnb_clean()`.
"}}}
    au BufHidden * call timer_start(0, {-> s:dnb_clean()})
augroup END

fu! s:dnb_clean() abort
    " do NOT wipe any buffer while a session is loading
    "
    " When we save a session, Vim writes some commands towards the beginning of
    " the session file, to check if the current buffer is a noname-empty buffer.
    " And towards the end, it wipes it.
    " If we load a session from a noname-empty buffer, it will become hidden,
    " our autocmd will kick in, this function will be invoked, and it will
    " wipe the buffer before the end of the restoration of the session.
    " This will cause an error, because Vim will try to wipe the buffer a 2nd
    " time while it doesn't exist anymore.

    if exists('g:SessionLoad')
        return
    endif

    " Source: http://stackoverflow.com/a/6561076
    let to_wipe = filter(range(1, bufnr('$')), { i,v ->    buflisted(v)
    \                                                   && empty(bufname(v))
    \                                                   && empty(win_findbuf(v)) })
    "                                                      │
    "                                                      └─ make sure the buffer is NOT displayed in any window

    if !empty(to_wipe)
        sil! exe 'bw! '.join(to_wipe, ' ')
    endif
endfu

" Didyoumean {{{2
" Description {{{3

" Source:
"         https://github.com/EinfachToll/DidYouMean/pull/6

" This function and the associated autocmd handles the case where we're
" trying to edit a new non existing file (`BufNewFile` event).
" If there're other existing files whose name begin in the same way,
" the function will give us the opportunity to choose one of them instead.
"
" Example:
" We're in /tmp.
" There are 2 files:    foo.md           and    foo.txt
" We want to edit       foo.md
" We type:              vim foo Tab
"
" We forget the existence of `foo.txt`, so we validate the command, thinking
" that the shell has completed `foo.md`.
" Unfortunately, the shell only completed the dot because there's an
" ambiguity.
"
" This handler will give us the opportunity to choose between `foo.md` and
" `foo.txt` instead of editing `foo.`.

" Code {{{3

fu! s:didyoumean() abort
    " We use the variable `b:didyoumean` as a way to register the fact that
    " the buffer has already been handled.
    " We need this info, because we don't want to rehandle the buffer every time
    " we enter it, only the 1st time.

    if get(b:, 'didyoumean_done', 0)
        return
    endif
    let b:didyoumean_done = 1

    let fname = expand('%')

    " There's nothing to handle if:
    "
    "         • the filename is empty
    "
    "         • it matches some existing entry in the filesystem
    "           (file, directory, special…) AND it's not a directory
    "
    "         • it ends with an explicit slash (and therefore is a directory)
    "           In this case, it means we really want to display the contents
    "           of a directory.
    "           A buffer  whose name  ends with a  slash should be  a directory
    "           no matter what. So, the `isdirectory(fname)` check is probably
    "           redundant, but better be safe than sorry.

    if empty(fname)
      \ || (!empty(glob(fname)) && !isdirectory(fname))
      \ || (isdirectory(fname) && fname[-1:] is# '/')
        return
    endif

    " Look for files whose name begins like the name of the current buffer.
    let matching_entries = glob(fname.'*', 0, 1)

    " If there's nothing, be more permissive during the expansion:
    " don't respect the 'suffixes' and 'wildignore' options.
    if empty(matching_entries)
        let matching_entries = glob(fname.'*', 1, 1)
    endif

    " Filter out the swapfile, if there's one.
    let swapfile = fnamemodify(execute('swapname')[1:], ':p')
    if swapfile isnot? 'no swap file'
        call filter(matching_entries, { i,v -> fnamemodify(v, ':p') isnot# swapfile })
    endif

    " We don't need to be suggested to load the current buffer.
    " It's already loaded. It would make no sense.
    " We're going to remove it from `matching_entries`.
    "
    " But if the current buffer is listing the contents of a directory,
    " its path could end with a slash.
    " OTOH, the entries in `matching_entries` could contain directories which
    " don't end with a slash.
    " So, we make sure `current_entry` doesn't end with a slash, to normalize
    " its name before using it for filtering the matching entries.

    let current_entry = substitute(expand('%'), '/$', '', '')
    call filter(matching_entries, { i,v -> v isnot# current_entry })

    if empty(matching_entries)
        return
    endif

    let candidates = ['Did you mean:']
    for i in range(1, len(matching_entries))
        call add(candidates, i . '. ' . matching_entries[i-1])
    endfor

    " ┌─ necessary because of `set shm+=F`
    " │  without it, the input query is bypassed
    " │
    unsilent let choice = inputlist(candidates)

    if choice >= 1 && choice <= len(matching_entries)
        let empty_buffer_nr = bufnr('%')
        "    ┌─ don't make the current empty buffer the alternate buffer
        "    │  for the current window, once we load the new chosen buffer
        "    │
        exe 'keepalt edit '.matching_entries[choice - 1]
        exe 'sil bw '      .empty_buffer_nr
    endif
endfu

" This autocmd needs to be nested.
" The detection of a filetype seems to occur when the `BufNewFile` event
" is triggered.
" If `s:didyoumean()` changes the buffer we're going to edit, then the
" filetype detection needs to re-occur, and thus the `BufNewFile` event too.
"
" Also, `s:didyoumean()` should be called when the `BufEnter` event occurs,
" to handle the following particular case:
"
"         We're in /tmp
"         There's the following hierarchy:
"
"                 autoload/
"                 ├── gutentags/           $ mkdir -p autoload/gutentags
"                 └── gutentags.vim        $ touch    autoload/gutentags.vim
"
"         We want to edit `autoload/gutentags.vim`, so we type:
"
"                 $ vim autoload/gut Tab
"
"         We hit Enter thinking that Vim has completed `autoload/gutentags.vim`.
"         Unfortunately, it has only completed `autoload/gutentags`.

"         So we end up editing a special buffer (netrw, dirvish,…) listing
"         the contents of a directory. There's no `BufNewFile` event in this
"         case.
"
"         We want the handler to give us the opportunity to choose between
"         `autoload/gutentags` and `autoload/gutentags.vim`.

augroup didyoumean
    au!
    au BufNewFile,BufEnter * nested call s:didyoumean()
augroup END

" Jump Last Position {{{2

augroup jump_last_position
" Jump to last position when reopening a file
" taken from :h line()

    au!
    " FIXME:
    "
    " Why isn't the mark `"` always correctly updated?
    "
    " It's updated when we quit the last buffer of a Vim session.
    " It's updated when we quit a buffer whose window is not the last of a tab page.
    " It's NOT updated when we quit a buffer whose window is the last in a tab page.
    "
    " Because of this, the following autocmd often doesn't work.
    " Taken from `:h last-position-jump`:
    "
    "         au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
    "
    " The following could be a workaround:

    au BufReadPost * sil! norm! g`.zvzz

    " We use  g`.  to jump to the last edit, so that no entry is added in the jumplist.
    "
    " Although it doesn't make the same thing.
    " The old automcd was supposed to position the cursor where it was the
    " last time we quit the last window displaying a buffer.
    " The new one positions the cursor on the last edit.
augroup END

" Man pages {{{2

" We want to use Vim as a pager to read man pages in bash.
" To do so, we need to set the filetype when the buffer is a man page,
" so that ~/.vim/after/ftplugin/man.vim is loaded.
" When we open a man page, $MAN_PN is set with the name of the page (ex:
" man(1)).
" We can test its value to know if Vim has been launched to read a man page.
if !empty($MAN_PN)
    augroup man_pages
        au!
        " Why do we use an autocmd, instead of just writing the command:
        " setl ft=man | file $MAN_PN directly ?
        " Because it would be too soon, the buffer wouldn't be loaded yet.
        " We have to wait for the standard input to have been read completely.
        "
        " Why an augroup? Probably not necessary, but don't like an autocmd
        " outside an augroup.
        au StdinReadPost * setl ft=man
    augroup END
endif

" Read special files {{{2

" The following autocmd  allows us to read  special files like a pdf  or an odt.
" They use a few shell utilities as filter:
"
"       • antiword
"       • odt2txt
"       • pandoc
"       • pdftotext
"       • unrtf

augroup filter_special_file
    au!
    " Why not use `BufReadPost`?{{{
    "
    " It would indeed be more appropriate than `BufWinEnter`.
    " But  for some  reason,  Vim doesn't  fire `BufReadPost`  when  it reads  a
    " `.docx` or `.epub` file.
    "
    "     au BufReadPost *.docx sil exe '%!pandoc -f docx -t markdown '.shellescape(expand('%:p'), 1)
    "        ^
    "        ✘
    "
    " We could use `FileType tar`:
    "
    "     au FileType tar sil exe '%!pandoc -f docx -t markdown '.shellescape(expand('%:p'), 1)
    "
    " …  but  $VIMRUNTIME/plugin/tarPlugin.vim   would leave some undesired
    " messages inside the buffer; it's noise.
    " Maybe it's because the event is fired too early, and the built-in tar plugin
    " processes the buffer after the event.
    "}}}
    au BufWinEnter  *.{doc,docx,epub,odp,odt,pdf,rtf}  call s:filter_special_file()
augroup END

fu! s:filter_special_file() abort
    if get(b:, 'did_filter_special_file', 0)
        return
    endif

    let fname = shellescape(expand('%:p'), 1)
    let ext = expand('%:e')
    let ext2cmd = {
    \               'doc' : '%!antiword '.fname,
    \               'docx': '%!pandoc -f docx -t markdown '.fname,
    \               'epub': '%!pandoc -f epub -t markdown '.fname,
    \               'odp' : '%!odt2txt '.fname,
    \               'odt' : '%!odt2txt '.fname,
    \               'pdf' : '%!pdftotext -nopgbrk -layout -q -eol unix '.fname.' -',
    \               'rtf' : '%!unrtf --text',
    \             }

    if has_key(ext2cmd, ext)
        let filter = matchstr(ext2cmd[ext], '%!\zs\S*')
        if !executable(filter)
            echom 'cannot filter '.expand('%:p').'; please install '.filter
            return
        endif

        setl ma noro
        " About: '%!pdftotext -nopgbrk -layout -q -eol unix '.fname.' -'{{{
        "                                                             │
        "                                                             └ write output on STDOUT, which is piped to `par`
        "}}}
        " FIXME: Initially, we used the shell utility `fmt`:{{{
        "
        "     '%!pdftotext -nopgbrk -layout -q -eol unix '.fname.' - | fmt -w78'
        "
        " The formatting was awful (too much random spacing everywhere).
        " `par` gives a more readable text:
        "
        "     '%!pdftotext -nopgbrk -layout -q -eol unix '.fname.' - | par -w80rjeq'
        "
        " However, there are still errors.
        " Look at the bottom  of a `pdf` file, filtered by  `par`, to find error
        " messages. It's often  due to  a too long  “word” (more  precisely what
        " `par` considers a word). Because of this, a pdf is often truncated.
        " So, I don't use it atm.
        "
        " Try to  fix these errors  by learning  how to better  configure `par`,
        " through  command-line  options,  and/or through  `$PARINIT`. Then  use
        " `par` to format a pdf.
        "}}}
        sil exe ext2cmd[ext]
        let b:did_filter_special_file = 1
        setl noma ro nomod
    endif
endfu

" Reload config {{{2

" FIXME:
" For some reason, the following line doesn't work:
"
"         au BufWritePost …,$HOME/.vim/autoload/myfuncs.vim …
"
" It seems the reason is `$HOME/.vim/autoload/` is a symlink.
" Maybe, when we write the file and `BufWritePost` is triggered, the autocmd
" checks for a match against the path as it was typed, not resolved.
"
" It's weird, because according to `:h autocmd-patterns`, Vim should also check
" for a match against the full path and after resolving symbolic links:

"     2. When there is a '/' in the pattern, Vim checks for a match against both the
"        short file name (as you typed it) and the full file name (after expanding
"        it to a full path and resolving symbolic links).
"
" Maybe it doesn't work because it's not the file itself which is the target
" of a symlink, but one of the component of its path, namely `autoload/`.
"
" Indeed, atm:
"
"         autoload -> /home/user/Dropbox/conf/vim/autoload
"
" Solutions:
" 1 - write the resolved filename; atm it's:
"
"         au BufWritePost …,$HOME/Dropbox/conf/vim/autoload/myfuncs.vim …
"
" I don't want that. Why?
" Because I could change the location of the file.
" The only thing that will probably never move is the symlink itself.
"
" 2 - Force Vim to resolve the path, using `resolve()`.
" This way, I can change the location of the `autoload/` directory and the target
" of the symlink whenever I want, without breaking the autocmd.

augroup source_files
    au!
    " Why no `-merge`?{{{
    "
    " If you pass the `-merge` option to `xrdb`, the background color you choose
    " for urxvt won't be applied in xterm, because of this existing resource:
    "
    "         *customization: -color
    "
    " See `xrdb -query` to get a list of all existing resources.
    "}}}
    au BufWritePost ~/.Xresources call system('xrdb ~/.Xresources')
    exe 'au BufWritePost $MYVIMRC,'.resolve($HOME.'/.vim/autoload/myfuncs.vim')
    \.  ' nested exe "source ".expand("<afile>")'
augroup END

" Standard Input {{{2

augroup my_stdin
    au!
    au StdInReadPost * if line2byte(line('$')+1)<=2 | cquit | endif
augroup END

" Spell files {{{2

" It's not technically an autocmd, but it's the only section where it fits.
" It generates binary files on certain conditions, so it could be assimilated
" as an autocmd.
"
" When spell checking is enabled, and we mark a word as good or bad,
" we make an addition into `~/.vim/spell/fr.utf-8.`.
" But, for Vim to take this addition into account, it has to perform
" a successful check on the corresponding binary file `fr.utf-8.add.spl`.
"
" Versioning those binary files with git could cause pb (conflicts between
" different versions).

" When we switch to another machine, we should regenerates them with the
" `:mkspell!` command.
" The bang asks to overwrite an old binary if there's already one.
" So we do it here, for every spell binary file, but only if
" the binary (.add.spl) is older than the original addition file (.add).

for spell_file in glob('~/.vim/spell/*.add', 1, 1)
    if filereadable(spell_file) && !filereadable(spell_file.'.spl')
  \ || (getftime(spell_file) > getftime(spell_file.'.spl'))
        exe 'mkspell! '.fnameescape(spell_file)
    endif
endfor

" Why the for loop?
" Because there can be several spell files (one per language), in which we
" made additions.
"
" http://vi.stackexchange.com/a/5052/6960

" Terminal {{{2

augroup my_terminal
    if has('nvim')
        au TermOpen * call s:setup_neovim_terminal()
    else
        au BufWinEnter * if &bt is# 'terminal'
                      \|     call s:setup_vim_terminal()
                      \| endif
    endif
augroup END

fu! s:setup_vim_terminal() abort
    " Neovim automatically disables 'wrap' in a terminal buffer.
    " Not Vim. We do it in this function.
    setl nowrap
    call s:setup_neovim_terminal()
    exe 'nno  <buffer><nowait><silent>  p  i<c-e>'.&termkey.'""'
endfu

fu! s:setup_neovim_terminal() abort
    nno  <buffer><nowait><silent>  I   I<c-a>
    nno  <buffer><nowait><silent>  A   A<c-e>
    nno  <buffer><nowait><silent>  C   i<c-k>
    nno  <buffer><nowait><silent>  D   i<c-k><c-\><c-n>
    nno  <buffer><nowait><silent>  cc  i<c-e><c-u>
    nno  <buffer><nowait><silent>  dd  i<c-e><c-u><c-\><c-n>

    xno  <buffer><nowait><silent>  c  <nop>
    xno  <buffer><nowait><silent>  d  <nop>
    xno  <buffer><nowait><silent>  p  <nop>
    xno  <buffer><nowait><silent>  x  <nop>
endfu

" By default, a terminal buffer is not modifiable. We could change this with
" an autocmd. Useful to copy some text, and then paste it to execute it as a command.
" However, if we delete one or 2 lines, neovim may crash.
" So, for the moment, we don't want a terminal buffer to be modifiable.
" It may change in the future though:
"
"     https://github.com/neovim/neovim/issues/5431
"     https://github.com/neovim/neovim/pull/6142
"
" We can still paste text on the command line though.
" No matter what we copy, no matter where we are, it will be put on the command
" line, without our cursor to move.

" if has('nvim')
"     augroup my_neovim_terminal
"         au!
"         DANGEROUS
"         au TermOpen * setlocal modifiable
"         DOESN'T WORK (why?)
"         au TermOpen * setlocal bufhidden=hide
"     augroup END
" endif

" Trailing whitespace {{{2

" Trailing whitespace in red but not in insert mode, and not if the filetype
" is in the list:
let s:NO_TRAILING_WHITESPACE_FT = ['' , 'git', 'help', 'qf']

augroup trailing_whitespace
    au!
    au BufWinEnter,InsertLeave * call s:trailing_whitespace(1)
    au InsertEnter             * call s:trailing_whitespace(0)
augroup END

fu! s:trailing_whitespace(create_match) abort
    if !a:create_match && exists('w:my_trailing_whitespace')
        call matchdelete(w:my_trailing_whitespace)
        unlet w:my_trailing_whitespace

    elseif a:create_match
       \&& !exists('w:my_trailing_whitespace')
       \&& index(s:NO_TRAILING_WHITESPACE_FT, &ft) ==# -1
        "                                                            ┌ non breaking space (C-k NS)
        "                                                        ┌───┤
        let w:my_trailing_whitespace = matchadd('Error', '\%(\s\|\%ua0\)\+$', -1)
    endif
endfu

" TO_DO {{{1

" *s/^\v%V"\s*\zs\d+\ze\s*-/\=submatch(0)-1/c
"
" 1 -
" We should never create special buffers:
"
"         vim /sil file/gj ~/.vim/**/*.vim ~/.vim/vimrc
"
" We should always use the qfl. The latter gives us more commands to interact.
" Exception:
" If you need some  kind of interactivity that a qf  window can't provide (think
" :PlugUpdate).
"
" 2 - solve the following pbs:
"
"         • join
"         • delete
"         • sort
"
" … every N lines.
" Write a command implementing each solution.
" Group the interface of the commands, with `:ReverseEveryNLines`.
" Try to infer some general principles underlying the solutions of this family
" of problems. For example:
"
"         when you perform an operation which changes the addresses of the lines
"         below, do it in reverse order
"
" 3 - move the cursor some lines down (cd) or up (cu).
" The motion bypasses all the lines which have an indentation level greater or
" equal than our current cursor position.
" Useful to move by logical blocks of code of the same level.
"
"        http://vi.stackexchange.com/a/213/6960
"        nno cd /\%<c-r>=virtcol('.')<cr>v\S<cr>
"        nno cu ?\%<c-r>=virtcol('.')<cr>v\S<cr>
"
" 4 - Vimcast, Episode 50, An introduction to vspec
"
"     https://github.com/junegunn/vader.vim (927 sloc)
"
"     http://whileimautomaton.net/2013/02/13211500
"     https://github.com/kana/vim-vspec
"     https://github.com/kana/vim-flavor
"     http://www.relishapp.com/kana/vim-flavor/docs
"
" 5 - Implement the concept of "narrowing region".
"
" A mapping, or command which would copy a range of lines in a temporary buffer.
" We could edit this temp buffer, and after writing it, the original selection
" would be replaced by it.
" There's a plugin for that:
"     https://github.com/chrisbra/NrrwRgn
" … but the source code is too long (1500 sloc) for what it does.
" Take inspiration from it.
"
" 6 - Implement ]n, ]s, ]u, ]x, ]y from unimpaired.vim
"
" 7 - Tmux navigation
" La navigation entre les panes de Tmux et les viewports de Vim n'est pas
" cohérente. Pour aller dans un pane Tmux depuis Vim, on peut taper C-{hjkl}.
" Mais en sens inverse (Tmux → Vim), il faut passer par le préfixe Tmux, pfx
" + hjkl.
" On a fait ça pour ne pas perdre les raccourcis readline dans le shell.
" On devrait peut être associer un keycode modificateur (Hyper?) sur la touche
" Super (ou la touche ctrl gauche?), et se servir de cette dernière pour naviguer
" entre Tmux et Vim: Super + {hjkl}.
"
" Plus généralement, revoir tout le code tmuxnavigator et repenser la
" navigation. Trop d'incohérences. Navigation entre onglets Vim, viewports
" Vim, panes Tmux, fenêtres Tmux, Tmux <-> Vim … C'est un gros bordel:
" AltGr-hl, C-hjkl, pfx-hjkl, M-hl
" Autre Idée:
"
"     C-hjkl             pour naviguer entre viewports et onglets  Vim.  (facile?)
"     Left Right Down Up "                   panes     et fenêtres Tmux. (difficile?)
"
" For the Tmux part, we would need to define conditional mappings.
" Maybe draw inspiration from here:
" http://stackoverflow.com/a/12380693
"
" Autre lien intéressant:
" https://silly-bytes.blogspot.fr/2016/06/seamlessly-vim-tmux-windowmanager_24.html
" Même raccourcis pour window manager, Tmux, vim
"
" 8 - Mieux comprendre l'ordre dans lequel les fichiers de coloration
" syntaxique, d'indentation, de couleurs, les ftplugins … sont sourcés.
" Pour ce faire, on pourrait pex choisir un type de fichier exotique et créer
" différentes versions du fichier:
"
"         haml.haml
"         OU
"         cmusrc.cmusrc
"
" Et les placer dans des endroits où le fichier peut être sourcé:
"
"         $VIM/syntax/
"         $VIMRUNTIME/syntax/
"         ~/.vim/syntax
"         ~/.vim/after/syntax
"         ~/.vim/plugged/…
"         …
"
" Puis lancer Vim et exécuter :Scriptnames.
"
" 9 -
"
" Créer des commandes pour fuzzy search la changeslist, et d'autres listes (via fzf).
"
" 10 -
"
"     https://github.com/hunspell/mythes
"     https://hunspell.github.io/
"     http://icon.shef.ac.uk/Moby/mthes.html
"
" Lire le code de:
"
"     https://github.com/beloglazov/vim-online-thesaurus/
"
" Ajoute ça dans le vimrc:
"
"     Plug 'beloglazov/vim-online-thesaurus'
"     let g:online_thesaurus_map_keys = 0
"
" Très court (144 sloc).
" Comme le plugin est court, on pourrait peut-être l'adapter pour le support
" du français.
" Chercher un site équivalent à thesaurus.com pour le français.
" Ou chercher une bdd de synonymes, et écrire un algo qui l'analyse:
"
"         http://www.dicollecte.org/download.php?prj=fr
"
" On pourrait aussi s'inspirer de la méthode du plugin pour ouvrir un split de
" taille dynamique, adapté à la taille des données à afficher.
"
" Jeter un oeil aux liens suivants :
"
"         https://hyperdic.net/en/doc/antonyms (trouvé en cherchant "where can
"         i download antonym file" page 3)
"         https://github.com/emugel/VIM-thesaurus-files
"
"         character-wise visual mode word lookup
"         https://github.com/beloglazov/vim-online-thesaurus/pull/31
"
" Créer une méthode mucomplete qui s'en sert.
"
" 11 -
" https://github.com/zeis/kokoi
"
" 12 -
" In `mycompletion`, we have to choose between 2 problems.
" Either we add `noselect` inside 'cot' and we break undo sequence.
" Or we don't, but then, when we complete a word, if there're several
" candidates and we insert a character to reduce their nr, the popup menu closes.
" Not sure there's a solution. Make a choice. Simplify `act_on_pumvisible()`.
" Don't need to cover several cases, we only use one configuration of 'cot'.
"
" And btw, which value should we choose for 'cot' when we invoke standard
" completion methods manually?
"
" 13 -
" Why `:FzAg!` + `foobar` (in interactive mode) gives much more results than
" `:FzAg! foobar`?
" More generally, I don't know how `:Ag` and `$ ag` interpret metacharacters.
" Make some tests, read doc.
" Example: compare `:FzAg! foo.*bar` and `:FzAg!` + `foo.*bar`
"
" I think `FzAg! pattern` does NOT fuzzy search pattern, it performs
" a standard search (not fuzzy).
" OTOH, `FzAg!` + `pattern` performs a live fuzzy search.
"
" 14 -
" Use fzf (and/or fzf.vim) to create a mapping which would fuzzy search inside
" our abbreviations (including their {rhs}).
" It would be useful in a case such as this:
"
"     What's the abbreviation which expands into a command to search a character
"     in the unicode table?
"
"     {fzf mapping} → type keyword `unicode` → look for the right abbreviation
"                                            → `:ucs`
"
" 15 -
" Extract big chunks of code from `myfuncs.vim` into separate plugins.
"
" 16 -
" Read/bookmark/follow this:
"     https://github.com/neovim/neovim/wiki/Following-HEAD
"
" And read this:
"     https://neovim.io/doc/user/vim_diff.html#vim-differences
"     :h vim-differences
"
" 17 -
" read and integrate `:h slow-start` in our notes
"
" 18 -
"
"     :h /\@>
"
" … called “match without retry“ in `:h perl-patterns`, and “possessive matching“
" in perldoc.perl.org.
" It can be used to optimize a regex, or it can be necessary to describe the
" text we're interested in.
"
" For more info, see:
"     http://www.regular-expressions.info/possessive.html
"
" AND :
"
"     http://perldoc.perl.org/perlre.html#Extended-Patterns
"
" This section is very long.
" To find what the excerpt dedicated to `(?>pattern)`, look right before the
" next section:
" http://perldoc.perl.org/perlre.html#Special-Backtracking-Control-Verbs
"
" Basically, it's a type of quantifier.
" There are greedy quantifiers (`*`, `+`, …), non-greedy or lazy (`{-}`), and
" possessive (`@>`).
" The (non-)greedy ones control how to repeat a token, the possessive one
" prevents backtracking (`>` = move forward no matter what).
"
" 19 -
" Suivre les flux rss des commits Vim et Neovim:
"
"     https://github.com/vim/vim/commits/master.atom
"     https://github.com/neovim/neovim/commits/master.atom
"
" … via newsbeuter.
"
" 20 -
" Implement a command which would show us the last keys typed.
"
" Also, implement a mechanism which would analyze the log:
"
"     http://www.drbunsen.org/vim-croquet/
"     https://github.com/nelstrom/vimprint
"     http://vimcasts.org/blog/2013/05/vimprint---a-vim-keystroke-parser/
"
" 21 -
" https://github.com/lifepillar/vim-mucomplete/issues/59#issuecomment-293920115
"
" 22 -
" Syntaxe à documenter (dans nos notes Vim et Awk):
"
" let myvar = other_var ==# 2    ⇔    let myvar = other_var ==# 2 ? 1 : 0
"                                                                 -------
"                                                                    |
"                                                                 inutile
"
" En VimL, comme en awk, une comparaison est une expression dont la valeur est
" 1 si elle est vraie, 0 autrement.
"
" 23 -
" When replicating plugin cheat40, automatically set last motion with:
"
"     sil! call lg#motion#repeatable#make#set_last_used(']S', {'bwd': ',', 'fwd': ';'})
"
" This way, we can move along long lines with ; and ,
"
" 24 -
" integrate ~/Dropbox/wiki/diff into ~/Dropbox/wiki/vim
" or into ~/Dropbox/wiki/admin
" yeah... maybe everything which is related to diff or vimdiff, put it inside
" admin
"
" 25 -
" http://blog.owen.cymru/fzf-ripgrep-navigate-with-bash-faster-than-ever-before/
"
" 26 -
" write a command which would scan all our plugin repos, and automatically
" commit changes (letting us write a comment for each)
"
" 27 -
" Read:
" https://github.com/neovim/neovim/blob/master/runtime/doc/vim_diff.txt
" in particular to improve our options
"
" 28 -
" In a temporary directory, execute these shell commands:
"     touch file{1..3}; mkdir -p foo/{bar,baz}/{qux,norf}
"     tree -a | vipe
"
" Look at the diagram. Implement a mapping / command which would expand an
" abbreviation into this kind of diagram.
" For the abbreviation, we could take inspiration from the shell commands
" themselves. Or sth else?
"
" A simple way of doing this would be to call just the `tree` command:
"     r !touch file{1..3}; mkdir -p foo/{bar,baz/qux}/{norf,abc}; tree -a
"
"     during the shell expansion `bar` and `baz/qux` are appended to `foo`
"     and `norf` and `abc` are appended to `foo/bar` and `foo/baz/qux`
"     so we end up with 4 (2*2) leaf directories + 4 intermediate directories
"     (foo, bar, baz, qux)
"
" But we would have to create a temporary directory, and temporarily `cd` to it
" to avoid polluting the current working directory.
" Besides, we would have to protect all kind of special characters which could
" be present in the text we want to insert in the diagram.
"
" However, mkdir seems limited to produce a complex hierarchy.
" A better way would be to look at the syntax used by emmet to expand html
" tags. Our mapping/command would parse a similar command to produce
" a hierarchy of items of an arbitrary complexity.
"
" Also, have a look at the DIAGRAM in `:h syntax-loading`. VERY INTERESTING.
" Without this diagram, the explanations would be much more verbose, and less
" readable. Implement a visual mapping, which would automatically draw the
" right diagram in front of the lines inside the selection (drawing `+`, `-`, `|`).
" ~/Desktop/diagram
"
" Also, install mappings to draw vertical diagrams instead of horizontal ones.
" Have a look at our notes about the try conditional for an example where it
" would be useful.
"
" Try this:
"
"         % api cpanminus
"         % sudo cpanm Graph::Easy
"
"         to uninstall later
"         % sudo cpanm --uninstall Graph::Easy
"
" Write this in a file:
"
"         digraph {
"             start -> adsuck;
"             adsuck -> block;
"             block -> noop[label="yes"];
"             block -> unbound[label="no"];
"             noop -> serve_noop[label="yes"];
"             noop -> serve_empty[label="no"];
"         }
"
" Visually select it, and type:
"
"         :'<,'>!graph-easy --as ascii
"                                      ^
"                                      don't add `%`
"                                      it would work, but if you have several digraph codes
"                                      in the current file, they will ALL be expanded, even
"                                      if you only select one in particular
"
" Interesting links:
"         https://vi.stackexchange.com/a/541/13370
"         http://melp.nl/2013/08/flow-charts-in-code-enter-graphviz-and-the-dot-language/
"         https://github.com/wannesm/wmgraphviz.vim
"         man graph-easy
"
" Update:
" This is really useful with vim-schlepp, and vim-draw.
" You create  the skeleton of  the diagram with  graph-easy, then tweak  it with
" vim-schlepp + vim-draw.
"
" Also, remember we've  created the `:BoxPrettify` command. Useful  to convert a
" raw ascii diagram, in a more polished one.
"
" 29 -
" Look for mappings which would benefit from being made
" dot/semicolon/comma repeatable.
"
" 30 -
" :! (bang) and system() are not interactive / show ANSI codes (besides try `!cat`)
"
"     if has('nvim')
"       cno  <expr>  !  getcmdtype() is# ':' && getcmdline() is# ''
"                   \ ?     '!tmux split-window -c '.getcwd().' '
"                   \ :     '!'
"     endif
"
" https://github.com/neovim/neovim/issues/1496
"
" 31 -
" When we try to paste a Tmux buffer, the indentation is increasingly wrong.
" The cause seems to be 'autoindent'/'ai' which should be temporarily
" disabled (and maybe temporarily enable 'paste'?).
" Anyway, the best solution is the `tbone` plugin which provides the commands
" `:Tput` and `:Tyank`, and gives a direct access to the Tmux buffers.
"
" Edit:
" I've  removed   'autoindent'  from   vimrc. It  shouldn't   be  necessary. The
" indentation  should be  completely handled  by an  indent plugin.   If there's
" none, find an indent plugin. If it's wrong, find a better one.
"
" Edit2:
" Every popular vimrc which I'm watching sets 'ai', except justinmk's.
" Should we reconsider 'ai'?
"
" Edit3:
" I've restore 'ai'; let's see what happens.
"
" 32 -
"
" Pb:
" Do you really understand what happens when we load a buffer?
"     from filetype detection down to syntax highlighting
"
" Read `:h ftdetect` to be sure you understand ft detection.
" Also, note somewhere that for filetype detection to work, the name of your
" buffer must be set BEFORE the `BufReadPost` or `BufNew` event:
"
"     :new some_file    ✔
"
"     :new
"     :file some_file    ✘
"
" Edit:
" Our section `FTPLUGINS + SYNTAX` has become too long.
" Re-read. Summarize. Extract in markdown notes.
"
" 33 -
" Protect all temporary change of option with `try|catch|endtry`.
" Look for the pattern:
"
"         \v_save|save_|old_|_old
"
" Do it in vimrc, myfuncs, plugins.
"
" For the replacement, use this construct:
"
"         preparations (like saving options)
"         try
"             do sth which can fail
"
"         catch
"             do sth if it fails
"             typically show error:
"
"                     echohl ErrorMsg
"                     echo v:exception.' | '.v:throwpoint
"                     echohl NONE
"
"         finally
"             mandatory conclusion (like restoring options)
"         endtry
"
" 34 -
"
" Re-read our snippet `op`, and refactor this section in our notes:
"
"         # MAPPINGS / ABRÉVIATIONS
"       → ## Opérateurs
"
" Also:
" refactor all operators so that they remove  'unnamed' and 'unnamedplus'
" from 'cb', and set 'inclusive'
"
"         vim /\v%(opfunc|operatorfunc)\=\zs.*g\@/gj ~/.vim/**/*.vim ~/.vim/**/vim.snippets ~/.vim/vimrc
"         :Cfilter! -other_plugins
"
" Also:
"         catch
"             return lg#catch_error()
"
" Also:
" What happens if you do:
"
"       op + v + motion
"
" I've just checked with `!gvj` (grep text from current position until next
" line, characterwise). And inside `op_grep()`, `a:type` is `char`, which is
" good. If it had been visual, we could have a problem, because our function
" would think we are operating from visual mode, instead of normal mode.
"
" To document.
"
" Update:
" Should we save/restore the visual marks, in all our plugins?
" Should we yank with noautocmd to prevent our visual ring from saving
" a possible selection?
"
" 35 -
" Create a mapping to populate command-line with `:ltag /`, then open the
" location window. Ex:
"
        nno  <expr>  <c-g>t  <sid>ltag(1)
        fu! s:ltag(step) abort
            if a:step ==# 1
                augroup my_ltag
                    au!
                    " Why the timer?{{{
                    "
                    " If we cancel, or the search fails to find anything,
                    " the fire-once autocmd will still be, wrongly, active.
                    " We should make sure to remove it with a timer, after
                    " a very short period of time.
                    "}}}
                    " Still, syntax highlighting would work better.
                    " Less hack, no timer.
                    au CmdlineLeave : call timer_start(5, {-> execute("exe 'au! my_ltag ' | aug! my_ltag", 'silent!')})
                    au FileType qf call s:ltag(2) | exe 'au! my_ltag ' | aug! my_ltag
                augroup END
                return ':ltag / | lw'.repeat("\<left>", 5)
            elseif a:step ==# 2
                let pat = '|.\{-}|'
                " FIXME:
                " It works if we press `gt`, which invokes this function.
                " But  if we  execute `:ltag`  manually, the  function won't  be
                " invoked, and the conceal won't be applied.
                " This brings an inconsistent user experience.
                " Try to use a syntax highlighting file (inspiration: man plugin
                " in neovim).
                call qf#set_matches('vimrc:ltag', 'Conceal', pat)
                call qf#create_matches()
            endif
        endfu
"
" Also:
" Play with `:tj / C-d`.
"
" It seems that `<space>ft` (fzf.vim) is identical to `:tj /`.
"
" 36 -
" In our notes we wrote that the best way to reload ftplugins was:
"
"         doautoall filetypeplugin FileType
"
" And in our session plugin, we use that:
"
"         doautoall filetypedetect BufReadPost
"
" What's the difference? Which is best?
" Compare the 2 with `:2Verbose …`.
"
" 37 -
" shell function to grep a pattern and populate the qfl
" this one doesn't send the results to a Vim server, and allows to pass
" arbitrary flags to grep
" https://www.reddit.com/r/vim/comments/6oj6gg/what_are_some_lesser_know_tips_and_tricks_in_vim/dki09wt/
" https://www.reddit.com/r/vim/comments/6oj6gg/what_are_some_lesser_know_tips_and_tricks_in_vim/dkiw87v/
"
" Difference compared to our `nv()` shell function?
"
" 38 -
" read :h cscope (useful to list tags in qfl?)
" https://www.reddit.com/r/vim/comments/6p6uch/how_to_refactor_by_tags/dkn30bd/
"
" 39 -
" If we search a too complex pattern, `n` takes a long time to compute the nr
" of matches (total & current).
" The pb comes from this line:
"
"         let output = execute(a:range.'s///gen')
"
" It shows us a fondamental pb. How to prevent a command from taking too much
" time? Here, we have a few solutions:
"
"         • try and guess by computing the nr of matches on a small range if it
"           goes beyond a certain threshold, we could report to the user that
"           there are too many matches
"
"           pb: most of the matches could be outside this small range
"
"         • refactor the code to use a while loop, and monitor the total time
"           taken after each iteration
"
"           pb: the while loop seems 6 times slower overall, compared to `s///gen`
"
" Solution proposed by Ingo:
"         :help catch-interrupt
"
" Tweak the function so that we can interrupt it with C-c.
" Don't use `echoerr` in the catch clause. It would raise an error (again).
" Use `echo` (+ echohl if needed).
" PS: I've tried this solution but the message gets erased.
" To continue…
"
" 40 -
" use `:[c|l]bottom` in your jobs plugins (if they populate a qfl asynchronously)
"
" 41 -
" In our syntax plugins (awk, markdown, sh, snippets, vim, …), apply a style
" (bold, italics, …) to texts between backticks, and conceal the backticks
" (less noise).
"
" 42 -
" Replace all occurrences of `norm ga` with appropriate code.
" Do the same for other `norm` (ex: `norm gs`).
"
"         vim /\C\%(^\s*".*\|\<ono\>.*\)\@<!norm!\@!\>/gj ~/.vim/**/*.vim ~/.vim/vimrc
"         :Cfilter! -other_plugins
"
" 43 -
" implement a global `:FoldToggle` command
"
" 44 -
" Refactor all our functions which populate the qfl to offload work to a single
" function in `vim-qf`?
"
"         vim /set\%(qf\|loc\)list/gj ~/.vim/**/*.vim ~/.vim/vimrc
"
" 45 -
" move the setting of 'flp' in markdown ftplugin into vimrc
" consistent with 'fo' which is in vimrc now
" set 'flp' from an autocmd listening to FileType (filter *), to set it
" in the same way for all filetypes
"
" question:
" does it cause an issue, if an option is set for all filetypes in vimrc?
" there's no teardown anymore (b:undo_ftplugin)
"
" 46 -
" read `:h  'indk`; if  you are  in a buffer  where a  line is  reindented while
" typing in  insert mode,  consider removing the  character which  triggered the
" reindentation from 'indk' (in an indent plugin)
"
" or look  for a  global variable  used by the  indentation plugin,  which could
" disable it
"
" 47 -
" Restore  buffer-local  mappings, J  and  K,  if  they existed,  after  preview
" mappings teardown?
"
" 48 -
" The double invocation of `scroll_preview_mappings()` is neat.
" We don't create 2 functions, only 1.
" Find where we should have done that. Look for functions containing the keyword
" `maybe` or `later`.
"
" 49 -
" Are there places where we should have used:
"         sil! call repeat#setreg(…, v:register)
" … ?
" I don't think so:
"         vim /repeat#set(/ ~/.vim/**/*.vim
"
" But still, document in which environment `repeat#setreg()` might be useful,
" and when to use it (hint: at the very beginning of the function).
"
" 50 -
" experiment about the idea that it's  forbidden to call or simply DEFINE public
" function inside plugin/ because it would cause autoload/ to be loaded
"
" use potion plugin to experiment
" note what you learn
"
" 51 -
" https://github.com/chrisbra/vim_faq
"
" 52 -
" no need to check `if &bt  is# 'quickfix'` before applying conceal
" abort and/or try conditional are enough
" sure?
"
"         vim /if\s\+&bt\s\+is#\s\+'quickfix'/gj ~/.vim/**/*.vim ~/.vim/**/vim.snippets ~/.vim/vimrc
"
" 53 -
" https://github.com/justinmk/vim-dirvish/issues/62
" https://github.com/bounceme/remote-viewer/
" Alternative:
" FUSE/sshfs provides an abstraction at the filesystem layer (as opposed to some
" other "middleware"),  so that  any dumb local  navigator (like  dirvish) works
" without adding special-case support for scp, FTP, webdav, …, netrw does.
"
" 54 -
" Do we really need a timer to display a message?
"
"         vim /execute(.*echo/gj ~/.vim/**
"
" We haven't seriously taken into account `:redraw`.
"
" https://github.com/google/vim-searchindex/blob/28c509b9a6704620320ef74b902c064df61b731f/plugin/searchindex.vim#L187-L189
"
" Make  more   tests,  take  into   account  all  relevant   parameters  (8*2=16
" environments), in Vim and Neovim:
"
"         • 'lz'
"         • :redraw
"         • <expr>
"         • timer
"
" 55 -
"
" create mapping to send current line to terminal, and execute it
" use `g>` for the lhs?
"
"     g> + text object
"     g> on visual selection
"     g>> for line
"
" 56 -
" finish reviewing vim-math
" What insight can we gain from it?
"
" Also:
" look at this:
"
"         https://github.com/sk1418/HowMuch
"
" Is there any functionality we could steal?
"
" 57 -
" finish reviewing ~/Dropbox/vim_plugins/pair_complete.vim
"
" 58 -
" We use `cml`, `cms`, in vimrc, myfuncs and in some of our plugins:
"
"         • iabbrev
"         • pair-complete
"         • titlecase
"
" It's  reliable  for programming  languages  where  the  cml must  be  repeated
" identically on every line of a  multi-line comment. What about the others (ex:
" c)?
"
" Update:
" We should distinguish 2 problems.
" (Un)commenting a line vs detecting whether a line is commented.
" We solved the 1st problem in `vim-comment`.
" For the 2nd one, try this expression:
"
"         synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')  isnot#  'Comment'
"
" 59 -
" Save/restore qfl/ll when we restart Vim?
" Not sure I want that. But it would be convenient to have a command which saves
" a particular qfl/ll in `~/.viminfo`, and which could restore it when needed.
" Our session plugin would test the existence of the variable storing a possible
" list and restore it if possible.
"
" Also, if we automatically restore a qfl, maybe we should stop clearing the arglist.
" Instead, we could create a mapping/command to remove it. Or just do it manually:
"
"         %argd
"
" 60 -
" finish reviewing  the section in our  notes which deals with  string functions
" (match(), matchstr(),…); also talk about `matchstrpos()`
"
" finish reviewing indexage de chaîne
"
" 61 -
" study vim-sandwich
" implement surrounding with → ← (for easier conceal)
"
" Also, document this:
"
"     saio(
"     surround column text-object with parentheses
"     (works even if the lines have different lengths)
"
" Also, read this (taken from vim-surround note), and try to reimplement it:
"
"     Au moment d'encadrer un text-object, on peut également interroger
"     l'utilisateur via un prompt pour lui permettre d'insérer une chaîne de
"     caractères arbitraire:
"
"             let g:surround_108 = "\1Enter sth: \1 \r \1\1"
"
"     `\r` permet de se référer au texte à remplacer (un peu comme & dans une
"     substitution).
"     Le prompt sera peuplé avec ’Enter sth: ’, et la chaîne saisie sera insérée
"     entre chaque paire consécutive de `\1 … \1`.
"     On ne peut pas se référer plusieurs fois au texte d'origine.
"     IOW, on ne peut pas utiliser plusieurs fois `\r`.
"     Le 1er sera bien remplacé par le text-object d'origine. Mais les autres
"     seront traduits en CR littéraux.
"     Il est nécessaire d'utiliser des doubles quotes.
"     On peut utiliser jusqu'à 7 input différents:
"
"             let g:surround_108 = "\1Enter sth: \1 \r \2And sth else: \2"
"
"     Ajouter des exemples …
"     https://stackoverflow.com/a/47401509/8243465
"
"
"
"     Furthermore, one can specify a regular expression substitution to apply.
"
"           let g:surround_108 = "\\begin{\1environment: \1}\r\\end{\1\r}.*\r\1}"
"           let g:surround_108 = "\1Enter sth: \1 \r \1\r}.*\r\1"
"
"     This will remove anything after the first } in the input when the text is
"     placed within the \end{} slot.  The first \r marks where the pattern begins,
"     and the second where the replacement text begins.
"
"     Les 2 derniers `\r` sont équivalents à `\zs` et `\ze`.
"     Tout ce qui se situe entre eux est supprimé.
"
"     Here's a second  example for creating an HTML <div>.  The substitution prompts
"     for an id, but only adds id="" if it is non-blank.
"
"           let g:surround_{char2nr("d")} = "<div\1id: \r..*\r id=\"&\"\1>\r</div>"
"
" 62 -
" debug vim-sandwich (:profile, source everything)
" also, try to configure the plugin so that `sdb` can delete a pair of backticks
"
" 63 -
" Create a command in vim-debug, to automatically profile a plugin.
" It would create a temporary script with the commands:
"
"         profile start $XDG_RUNTIME_DIR/vim_profile_plugin.log
"         prof! file ~/.vim/plugged/{plugin-name}/**/*.vim
"         unlet! g:loaded_{guard-name}
"         so file1.vim
"         so file2.vim
"         …
"
" We would put `file1`, `file2`, … with:
"         put =map(filter(glob($HOME.'/.vim/plugged/{plugin-name}/**/*.vim', 0, 1),
"         \               { i,v -> v !~# '/t\%[est]/' }),
"         \        { i,v -> 'so '.v })
"
" 64 -
" Check whether some commands would be better suited as mappings.
" And check whether some mappings would be better suited as commands.
"
" 65 -
"                                ┌ 3rd character of all `]o?` mappings
"         ┌──────────────────────┤
"         BCILNSWacdfhilmnopqstvwz
"         echo map(range(65,90)+range(97,122), {i,v -> nr2char(v)})
"         echo filter(map(range(65,90)+range(97,122), {i,v -> nr2char(v)}), {i,v -> })
"              ^^^^^^^                                                    ^^^^^^^^^^^^
"              create a transformation to automatically add this
"              make it cycle between `filter()` and `map()`
"
" ~/.vim/plugged/vim-cmdline/autoload/cmdline.vim
" cmdline#transform() (bound to C-s)
"
" 66 -
" install autocmd listening to `BufReadPost */after/ftplugin/*.vim`
" which would install a buffer-local autocmd listening to `BufWritePost`
" which would give us a warning when we forget to undo a:
"
"         mapping/abbreviation/command/autocmd/variable
"
" or when we undo a non-existing …
"
" 67 -
" normalize underscore/dash in plug mappings, and function names in shell init files
"
" 68 -
" update the position of the mark in `vim-readline`
"
" MWE:
"
"     $ echo 'h|ello'
"              ^
"              cursor
"
"     press C-SPC  (sets the mark right after the `h`)
"
"     $ |echo 'jjjjjjjjjjjjjjjjjjjhello'
"       ^      └─────────────────┤
"       │                        └ insert all of these
"       │
"       new cursor position
"
"     press C-x C-x  (exchange cursor and mark position)
"
" Result:
" In bash:
"
"     $ echo 'j|jjjjjjjjjjjjjjjjjjhello'
"              ^
"              ✘
"
" In zsh:
"
"     $ echo 'j|jjjjjjjjjjjjjjjjjj|hello'
"                                 ^
"                                 ✔
"
" Emulate `zsh` behavior.
"
" Look for other mappings to implement, add them to a todo.
"
" 69 -
" Should we add `:noa` every time we use `:wincmd`?
"
"
"     :vim /wincmd p\|call win_gotoid/gj ~/.vim/**/*.vim ~/.vim/vimrc
"     :Cfilter! -not_my_plugins
"     :Cfilter! -not_relevant
"     :Cfilter! \<noa\>
"
" Same question for `:[cl]open`, `:[cl]window`?
" Why this 2nd question?
" `noa` was  useful in  `vim-interactive-lists` to  prevent the  original window
" from being  minimized when  it's a  middle horizontal viewport  (2nd of  3 for
" example).
" The issue, if there's one, may be with l[open|window] only.
"
" Edit:
" I think  we should use  `:noa` whenever we TEMPORARILY  change the focus  to a
" window.
"
" 70 -
" In `vim-stacktrace`, in the function `main()`, we've discovered a new kind of issue.
" A function implementing some abstract logic can be wrongly affected by the current
" buffer settings ('isk' for example). Should we track this issue everywhere in our code?
" Is this issue an argument in favor of delegating logic to external process / lua?
"
" 71 -
" Check that whenever we use `wincmd p` we get to the right window.
" Maybe we should use this instead:
"
"     let id = win_getid()
"     …
"     call win_gotoid(id)
"
" 72 -
" Read all of this:
"     https://neovim.io/news/archive/
"
" 73 -
" Read this:
" https://dev.to/idanarye/omnipytent-5g5l
" https://www.reddit.com/r/vim/comments/7kwlxc/omnipytent_plugin_explained/
" https://github.com/idanarye/vim-omnipytent
"
" 74 -
" Read this (OOP in VimL):
" https://github.com/LucHermitte/lh-vim-lib/blob/master/doc/OO.md
"
" 75 -
" Replace `:silent!` with `:silent` whenever possible.
" There may be errors to fix which we are missing because they are silent.
" Also, if you wonder whether a plugin/(auto)command/function is working
" as expected, and has no silent errors, use `:Verbose` to increase
" the verbosity level.
"
" 76 -
" use syntax hl in `vim-qf` instead of complex mechanism using matches
" also, in `vim-qf`, fix the fixme in the autocmd `my_qf`
"
" 77 -
" add syntax hl in TOC menu, and make content more relevant in help TOC
"
" 78 -
" The TOC  window may currently  be a little  too wide (see:  vim-qf, autoload/,
" qf#open()). We could  compute the longest line,  and set the width  of the TOC
" window dynamically.
"
" 79 -
" Move every function called from several scripts inside `vim-lg-lib`:
"
"     cmdline#reset_did_transform(
"     comment#object(
"     fold#md#stacked(
"     fold#md#toggle_fde(
"     fold#text(
"     qf#create_matches(
"     qf#open(
"     qf#set_matches(
"     repeat#set(            yes, even this one (we want as few dependencies as possible for all our plugins)
"     repeat#setreg(
"
" Also, make  sure they  are self-contained. They must  not call  functions from
" one of our other plugins. If they do, move the latter inside `vim-lg-lib` too.
"
" 80 -
" implement a search ring, and install mappings to cycle through it
" useful to search for an old pattern without having to do `/ Up …`
" (; and ,  would be more comfy)
"
" 81 -
" When you create a loclist, replace the  old one if its title is `Breakdown` or
" `FIX_ME & TO_DO`.
" Also, maybe create a mapping to show  the stack of location lists, and another
" to remove the current one.
"
" Also,  if you  execute  `:WTF` several  times consecutively,  `vim-stacktrace`
" keeps recreating and adding the  same qfl. It shouldn't. It should replace the
" old one, or better leave it alone.
" To do so, it should remember the last qfl it produced, or the last `:messages`
" it parsed, or any information sufficient to know that there's no need to
" recreate a qfl.
"
" 82 -
"     SPC fr    (:FzHistory)
"     Escape
"     :tabnew
"
" A new tab page is correctly opened, but the focus stay in the same window,
" and the fzf buffer is replaced with the last visited buffer.
"
" 83 -
" Create a submode to insert numbers more easily.
" Ex:
"
"         ┌ enter “easy-number” submode
"     ┌───┤
"     C-g n u  →  1
"           i  →  2
"           o  →  3
"           j  →  4
"           k  →  5
"           l  →  6
"           ,  →  7
"           ;  →  8
"           :  →  9
"           !  →  0
"
" Edit:
" Maybe a submode is not the right concept, because of the timeout.
" Maybe you should take inspiration from `vim-capslock`.
" Create a mapping, which would toggle temporary mappings.
"
"     ino <expr><silent> <c-g>n  <sid>easy_number()
"
"     fu! s:easy_number() abort
"         if !empty(maparg('!', 'i'))
"             for l:key in ['!', 'u', 'i', 'o', 'j', 'k', 'l', ',', ';', ':']
"                 exe 'iunmap  <buffer>  '.l:key
"             endfor
"         else
"             let i = 0
"             for l:key in ['!', 'u', 'i', 'o', 'j', 'k', 'l', ',', ';', ':']
"                 exe 'ino  <buffer>  '.l:key.'  '.i
"                 let i += 1
"             endfor
"             augroup reset_easy_number
"                 au! * <buffer>
"                 au InsertLeave <buffer> call s:easy_number()
"                 \|                      au! reset_easy_number * <buffer>
"             augroup END
"         endif
"         return ''
"     endfu
"
" 84 -
" Create a mapping to dump in the buffer information printed by a mapping
" prefixed with `-`. Example: `-a`, `-p`
"
" Maybe we should supercharge `C-r X` in insert mode?
"
" We should probably install some sort of wrapper around all `-X` mappings.
" Like what we did to repeat motions.
" The wrapper would save the last `-X` mapping used, and `C-r X` would
" check this info to know what to dump.
"
" After dumping the info, it would delete it, the next time we execute
" an Ex command to let us dump the output of the latter (via a fire-once
" autocmd listening to `CmdlineLeave :`).
"
"  -8
"  -a
"  -f
"  -p
"
" 85 -
"
"     $ vim
"     :e /tmp/file
"     $ vim (a 2nd instance)
"     :try | e /tmp/file | catch | call lg#catch_error() | endtry
"
" If the file is already loaded in another instance, it will raise the error:
"         :h E325
"
" But the error won't be catched because Vim prompts us with a question to know
" what we want to do (edit, quit, …).
" Worse, the question is not visible.
"
" Solution: for the moment, press `e` to choose to edit the file.
"
" But this begs the question. How to deal with an error prompting us
" with a question? How to catch it properly?
"
" 86 -
" Write your own colorscheme.
" Take inspiration from seoul.
" There should be a dark and light version, with different level of lightness.
" Also, there should be a command/mapping to toggle between a minimum of HGs
" defined (title, comment, string, to_do/fix_me,…), and all HGs.
" Also, Vim should remember whether all HGs were defined.
"
" Use this to write a reliable / correct colorscheme:
"
"     https://github.com/lifepillar/vim-colortemplate
"
" Also read this:
"
" https://speakerdeck.com/cocopon/creating-your-lovely-color-scheme
"
" 87 -
"
" Add sth like this  for Neovim; it could make neovim  faster (especially if you
" use UltiSnips):
"
"     let g:loaded_python_provider = 1
"     let g:python_host_skip_check=1
"     let g:python_host_prog = '/usr/bin/python'
"     let g:python3_host_skip_check=1
"     let g:python3_host_prog = '/usr/bin/python3'
"
" Also, disable automatic expansion of snippets with this:
"
"     augroup ultisnips_no_auto_expansion
"         au!
"         au VimEnter * au! UltiSnips_AutoTrigger
"     augroup END
"
" It has a significant impact in Neovim.
" MWE:
"
"     1000i some text
"         → several seconds with the autocmd
"           1 or 2 without
"
" Also, read this:
" https://github.com/neovim/neovim/issues/5702
" https://github.com/neovim/neovim/issues/7063
"
" 88 -
" :h quickref
"
" 89 -
" Play with (or document):
"
"        • $HOME/.vim/tools/colors/check_colors.vim
"        • 'user_data' entry in completion item
"        • CmdlineChanged
"        • DirChanged
"        • ExitPre
"        • TextChangedP
"        • `getcompletion('*', 'arglist')`   +   com! -complete=arglist ...
"        • `getcwd(-1)` return the global directory
"        • `term_setansicolors()`, `term_getansicolors()`, `g:term_ansi_colors`
"        • `term_setsize()`
"        • `trim()`
"
" 90 -
" In `vim-window`, don't do this:
"
"     let changelist = split(execute('changes'), '\n')
"     let b:my_change_position = index(changelist, matchstr(changelist, '^>'))
"
" Instead do this:
"
"     let changelist = get(getchangelist('%'), 0, [])
"     let b:my_change_position = get(getchangelist('%'), 1, -1)
"
" Requires the  new `getchangelist()` function,  which atm is not  implemented in
" Neovim. Wait for Neovim to catch up.
"
" 91 -
" `vim-save`  is  really   small. Move  it  in  vimrc,  or   in  another  plugin
" (vim-toggle-settings).
"
" Also, should we enable 'ttyfast'? Should be useless with current terminal, but
" could  be useful  in  a future  one. Useless in  Neovim,  because it's  always
" enabled there.
"
" 92 -
" Sometimes, some text which should be displayed in italics is not.
" Reloading the buffer solves the issue.
" But where does it come from?
"
" 93 -
" Prevent vim-session from checking swap files.
" Annoying when a session crashed, and we can't restore a session.
"
" 94 -
" In  Neovim there's  a plugin  to open  a file  from a  terminal buffer  in the
" current Neovim instance. But what about Vim?
"
"     https://www.reddit.com/r/vim/comments/83ve6g/how_to_open_file_in_current_vim_instance_from/
"
" 95 -
" Load an awk buffer, and press `1zs` on a comment:
"
"     awkComment     xxx match /#.*/  contains=@Spell,awkTodo
"                        matchgroup=Comment start=/^\s*\zs#@\@!\s\?/ end=/$/  concealends contains=@Spell,awkTodo
"
" Two syntax items are displayed.
" I think the first one is the original one ($VIMRUNTIME).
" The second one is my custom version to conceal the comment leader.
" Shouldn't we remove the first one, before installing the second one?
"
"         syn clear awkComment
"
" Try to  answer this question once  we've a better understanding  of the syntax
" mechanism.
" Once you do, if you remove the original syntax item, do the same in all plugins.
"
"         :vim /syn.*concealends/gj ~/.vim/**/*.vim ~/.vim/**/vim.snippets ~/.vim/vimrc
"
" 96 -
" We have an issue with mappings which contain C-j (and C-m?) and which are made
" repeatable. For an example, look at `Z C-j`.
" It doesn't work the first time it's invoked. But it works fine when you repeat
" it, with z, and z;.
" The issue is in the mapping:
"
"         n  Z<NL>       * <SNR>109_move('Z<NL>')
"
" The newline probably breaks prematurely the invocation of the function.
" We could tweak the code to protect such a special character with `<lt>`.
" But then we would need to translate `<c-j>` manually.
"
" 97 -
" All our mappings dealing with formatting (gq, gqq, gqic, SPC p, SPC P)
" are becoming too complex for this vimrc.
" We would benefit from moving all of them in a separate plugin.
"
" 98 -
" Read:
"
"     :h channel.txt
"     :h syntax.txt     (not that big once you remove part 4: :h syn-file-remarks
"                        you're not supposed to read entirely anyway, only the ones
"                        matching the types of files you use frequently;
"                        to get a list:    :h ft-*-syn C-d)
"     :h tagsrch.txt
"     :h terminal.txt
"
"     :h if_lua.txt
"
"     :h diff.txt
"     :h recover.txt
"     :h tips.txt
"
" 99 -
" Try to implement a `:Trr` (TRash Restore) command to restore the trash.
"
" 100 -
" Document the fact that when a backtick  expansion causes an issue, you can see
" which shell command was executed by increasing the verbosity level to 4:
"
"     :set verbose=4 | cmd
"     OR
"     :4verb cmd
"
" 101 -
" study ~/Dropbox/vim_plugins/fastfold.vim
"
" 102 -
"
"     :vim /setl.*bt=nofile/gj ~/.vim/**/*.vim ~/.vim/**/vim.snippets ~/.vim/vimrc
"
" Visit all matches. Bring consistency in the  way we create a temporary buffer,
" including how we set the geometry of the window.
" Also look at our snippet.
"
" Also, finish reviewing this:
"
"     :vim /setl.*\%(noma\|nomodifiable\)/gj ~/.vim/**/*.vim ~/.vim/**/vim.snippets ~/.vim/vimrc
"
" 103 -
" https://www.reddit.com/r/vim/comments/8asgjj/topnotch_vim_markdown_live_previews_with_no/
" https://github.com/joeyespo/grip (unfortunately, requires an internet connection)
"
" 104 -
" Look at ~/Dropbox/wiki/vim/plugin.md and search for the `vim-sandwich` section.
" I wrote  some custom  exercises where  the answer  is concealed,  and visually
" indicated by `↔`.
" But after  pressing `coc` twice to  see/hide an answer, the  visual indicators
" are concealed too.
" In a markdown buffer, `coc` should make 'cole' toggle between `0` and `2`, not
" `0` and `3`.
"
" Also, this concept of concealing answers is neat; try to use it more often.
" It could be useful when the problem for  which you need to write a question is
" difficult to summarize in one line.
" In this case, you could write a generic question followed by a ↔ character.
" The latter would mean:
"
"         “you can safely open the fold,
"          you won't be immediately spoiled,
"          there will be an exercise which will make the question clearer,
"          and the answer is concealed”
"
" 105 -
" `vim-plug`, `vim-lg...` (:ListRepeatableMotions -vv), `vim-unix` (:Tree),
" they should all use the same keys to cycle between entries.
" C-n/C-p, or J/K, or sth else.
"
" Currently, we use J/K everywhere, except in `vim-plug` (C-j/C-k).
"
" If we  choose C-n/C-p, it conflicts  with tabpage navigation (choose  sth else
" for tabpage navigation?).
"
" If we choose J/K, it conflicts with scrolling in preview window.
"
" 106 -
" Implement `:FoldSortBySize`
" Make it local to a markdown buffer.

com! -range=%  FoldSortBySize  exe s:fold_sort_by_size(<line1>,<line2>)

fu! s:fold_sort_by_size(lnum1,lnum2) abort
    let lvl = strlen(matchstr(getline(a:lnum1), '^#*'))
    if lvl ==# 0
        return 'echoerr "the first line is not a fold title"'
    endif

    let &l:fen = 0
    norm! $
    let pat = '\n\%(#\{1,'.lvl.'}\%(#\)\@!\)'
    let lnum = search(pat, 'W', a:lnum2)
    let folds = [{'foldstart': a:lnum1, 'foldend': lnum, 'size': lnum - a:lnum1 + 1}]
    while lnum > 0
        let pos = getcurpos()

        if len(folds) > 1
            let size = folds[-1].size
            let foldstart = folds[-1].foldstart
            let foldend = folds[-1].foldend

            let i = 0
            for f in folds
                if f.size > size
                    exe foldstart.','.foldend.'m ' . f.foldstart
                    let cur_fold = remove(folds, -1)
                    call insert(folds, cur_fold, i)
                    break
                endif
                let i += 1
            endfor
            call setpos('.', pos)
        endif

        let lnum = search(pat, 'W', a:lnum2)
        let folds += [{'foldstart': pos[1]+1, 'foldend': lnum, 'size': lnum - pos[1]}]
    endwhile
    let &l:fen = 1
    return ''
endfu


" sessions:
"
"         1. try
"         2. async
"         3. unix
"         4. tree
"         5. breakdown
"         6. package
"         7. config
"         8. tag
"         9. cwd
"         10. unix
"         11. keyboard
"
" Once finished, get back to studying the terminal and latex.



" augroup test_sth
"     au!
"     " FIXME:
"     " Why does this autocmd fails to print 'hello' when we write the vimrc?
"     " Why does it work if I rename the augroup, then `:w` again?
"     " Why does it work in another file?
"     " Does `:unsilent` have any effect on `:echom`?
"     au  BufWritePost * call Func_to_test()
" augroup END
"
" fu! Func_to_test()
"      echom 'hello'
" endfu



augroup quick_and_dirty_settings
    au!
    au BufReadPost * call s:quick_and_dirty_settings()
augroup END

fu! s:quick_and_dirty_settings() abort
    if getline(1) isnot# 'QnD'
        return
    endif

    call cursor(1,1)
    let end = search('^QnD_END$')
    if !end
        norm! g`.
    endif

    let settings = getline(2, end - 1)
    let b:quick_and_dirty_settings = tempname()
    call writefile(settings, b:quick_and_dirty_settings)
    augroup apply_quick_and_dirty_settings
        au! * <buffer>
        au BufWinEnter <buffer> exe 'so '.b:quick_and_dirty_settings
    augroup END

    norm! g`.
endfu



" inorea  <expr>  aa  <sid>painful_chars('angle')
" cnorea  <expr>  aa  <sid>painful_chars('angle')

" inorea  <expr>  cc  <sid>painful_chars('curly')
" cnorea  <expr>  cc  <sid>painful_chars('curly')

" inorea  <expr>  rr  <sid>painful_chars('round')
" cnorea  <expr>  rr  <sid>painful_chars('round')

" inorea  <expr>  ss  <sid>painful_chars('square')
" cnorea  <expr>  ss  <sid>painful_chars('square')

" inorea  <expr>  tt  <sid>painful_chars('tick')
" cnorea  <expr>  tt  <sid>painful_chars('tick')

" fu! s:painful_chars(char) abort
"     let seq = {
"     \           'angle':  '<>',
"     \           'curly':  '{}',
"     \           'round':  '()',
"     \           'square': '[]',
"     \           'tick':   '``',
"     \}
"     if !has_key(seq, a:char)
"         return ''
"     endif
"     call feedkeys(seq[a:char]."\<left>", 'in')
"     call timer_start(0, {-> feedkeys("\<bs>", 'in')})
"     return ''
" endfu



augroup save_last_qfl
    au!
    au VimLeavePre * call s:save_last_qfl()
    au VimEnter    * call s:restore_last_qfl()
augroup END

fu! s:save_last_qfl() abort
    let qfl = getqflist()
    if empty(qfl)
        if exists('g:MY_LAST_QFL')
            unlet g:MY_LAST_QFL
        endif
        return
    endif
    call map(qfl, {i,v -> extend(v, {'filename': bufname(v.bufnr)})})
    call map(qfl, {i,v -> remove(v, 'bufnr') ? v : v})
    let g:MY_LAST_QFL = {'qfl': qfl, 'title': get(getqflist({'title': 1}), 'title', ':setqflist()')}
endfu

fu! s:restore_last_qfl() abort
    " Why check the value of 'errorfile'?{{{
    "
    " Suppose we start Vim like this:
    "
    "     $ vim -q <(!!)
    "
    " To populate the qfl with the output of the last shell command.
    " When we'll execute `:copen`, I want to see the result IMMEDIATELY.
    " I don't want to have to execute `:colder`.
    "
    " Otherwise, we may lose time wondering why we're seeing an irrelevant qfl.
    "}}}
    " Which values could it have?{{{
    "
    " By default, &errorfile = 'errors.err'.
    " Except when we start Vim with the `-q` option.
    " In this case, it's:
    "
    "         • '/dev/stdin'    if we read a file
    "
    "                 cmd       | vim -q /dev/stdin
    "                 cmd >file | vim -q file
    "
    "         • '/proc/self/fd/123'    if we read the output of a process substitution
    "
    "                 vim -q <(shell cmd)
    "
    " So,  inspecting the  value of  this option  is a  good way  of determining
    " whether we can restore an old qfl.
    "}}}
    if  &errorfile isnot# 'errors.err'
    \|| empty(get(get(g:, 'MY_LAST_QFL', {}), 'qfl', []))
        return
    endif

    if has_key(g:MY_LAST_QFL, 'qfl')
        call setqflist(g:MY_LAST_QFL.qfl)
    endif
    if has_key(g:MY_LAST_QFL, 'title')
        call setqflist([], 'a', {'title': g:MY_LAST_QFL.title})
    endif
endfu



" nno cd :<c-u>call <sid>append_error_sign()<cr>
" fu! s:append_error_sign() abort
"     let cml = matchstr(get(split(&l:cms, '%s'), 0, ''), '\S*')
"     call append(line('.'), cml.repeat(' ', virtcol('.')-1-strchars(cml, 1))."^\u2718")
" endfu



"  pair_complete.vim
"  undotreeshow       4929 (before big refactoring)
"  undotreeshow       5247 (after  ")



" We need to remove this item from `g:sandwich#default_recipes`:
"
"         { 'noremap':     0,
"         \ 'expr_filter': ['operator#sandwich#kind() is# "replace"'],
"         \ 'kind':        ['replace', 'textobj'],
"         \ 'external':    ["\<plug>(textobj-sandwich-tagname-i)", "\<plug>(textobj-sandwich-tagname-a)"],
"         \ 'input':       ['t'],
"         \ 'synchro':     1 }
"
" Otherwise, we have the bug `srb`, `v_sr`.
"
"         <plug>(textobj-sandwich-tagname-a)
"
"         sandwich#magicchar#t#a()
"         ~/.vim/plugged/vim-sandwich/autoload/sandwich/magicchar/t.vim
"
"         call s:prototype('a')
"                 execute printf('normal! v%dat', v:count1)
"
"                 ⇔ v1at → E65: Illegal back reference
"                          E65: Illegal back reference
"
" Sometimes,  when the  plugin must  find  what are  the surrounding  characters
" itself, it WRONGLY finds a tag.
"
" Removing this item may make us lose the tag object.
" We could:
"
"         • submit a bug report:
"
"                 the plugin detection of surrounding characters should be improved
"                 if it can't, when `E65` occurs, the plugin should stop and show it to us
"                 why doesn't that happen?
"
"         • try and tweak the definition of this recipe
"
"         • let the recipe in, and disable the problematic operators:
"
"                 nno srb <nop>
"                 xno sr  <nop>

if has('vim_starting')
    let g:sandwich#default_recipes = [
    \       {'buns': ['\s\+', '\s\+'], 'regex': 1, 'kind': ['delete', 'replace', 'query'], 'input': [' ']},
    \       {'buns': ['', ''], 'action': ['add'], 'motionwise': ['line'], 'linewise': 1, 'input': ["\<CR>"]},
    \       {'buns': ['^$', '^$'], 'regex': 1, 'linewise': 1, 'input': ["\<CR>"]},
    \       {'buns': ['<', '>'], 'expand_range': 0, 'match_syntax': 1},
    \       {'buns': ['"', '"'], 'quoteescape': 1, 'expand_range': 0, 'nesting': 0, 'linewise': 0, 'match_syntax': 1},
    \       {'buns': ["'", "'"], 'quoteescape': 1, 'expand_range': 0, 'nesting': 0, 'linewise': 0, 'match_syntax': 1},
    \       {'buns': ['{', '}'], 'nesting': 1, 'match_syntax': 1, 'skip_break': 1},
    \       {'buns': ['[', ']'], 'nesting': 1, 'match_syntax': 1},
    \       {'buns': ['(', ')'], 'nesting': 1, 'match_syntax': 1},
    \       {'buns': 'sandwich#magicchar#t#tag()', 'listexpr': 1, 'kind': ['add'], 'action': ['add'], 'input': ['t']},
    \       {'buns': 'sandwich#magicchar#t#tag()', 'listexpr': 1, 'kind': ['replace'], 'action': ['add'], 'input': ['T']},
    \       {'buns': 'sandwich#magicchar#t#tagname()', 'listexpr': 1, 'kind': ['replace'], 'action': ['add'], 'input': ['t']},
    \       {'external': ["\<Plug>(textobj-sandwich-tag-i)", "\<Plug>(textobj-sandwich-tag-a)"], 'noremap' : 0, 'kind' : ['delete', 'textobj'], 'expr_filter': ['operator#sandwich#kind() isnot# "replace"'], 'synchro': 1, 'linewise': 1, 'input': ['t', 'T']},
    \       {'external': ["\<Plug>(textobj-sandwich-tag-i)", "\<Plug>(textobj-sandwich-tag-a)"], 'noremap' : 0, 'kind' : ['replace', 'query'], 'expr_filter': ['operator#sandwich#kind() is# "replace"'], 'synchro': 1, 'input': ['T']},
    \       {'buns': ['sandwich#magicchar#f#fname()', '")"'], 'kind': ['add', 'replace'], 'action': ['add'], 'expr': 1, 'input': ['f']},
    \       {'external': ["\<Plug>(textobj-sandwich-function-ip)", "\<Plug>(textobj-sandwich-function-i)"], 'noremap': 0, 'kind': ['delete', 'replace', 'query'], 'input': ['f']},
    \       {'external': ["\<Plug>(textobj-sandwich-function-ap)", "\<Plug>(textobj-sandwich-function-a)"], 'noremap': 0, 'kind': ['delete', 'replace', 'query'], 'input': ['F']},
    \       {'buns': 'sandwich#magicchar#i#input("operator")', 'kind': ['add', 'replace'], 'action': ['add'], 'listexpr': 1, 'input': ['i']},
    \       {'buns': 'sandwich#magicchar#i#input("textobj", 1)', 'kind': ['delete', 'replace', 'query'], 'listexpr': 1, 'regex': 1, 'synchro': 1, 'input': ['i']},
    \       {'buns': 'sandwich#magicchar#i#lastinput("operator", 1)', 'kind': ['add', 'replace'], 'action': ['add'], 'listexpr': 1, 'input': ['I']},
    \       {'buns': 'sandwich#magicchar#i#lastinput("textobj")', 'kind': ['delete', 'replace', 'query'], 'listexpr': 1, 'regex': 1, 'synchro': 1, 'input': ['I']},
    \     ]
endif

com! -bar -nargs=+ ProfilePlugin call s:profile_plugin(<f-args>)

fu! s:profile_plugin(...) abort
    " TODO:
    " Eliminate the need for providing the guard.
    " We should unlet it automatically.
    " Study vim-scriptease.
    if a:0 !=# 2
        return 'echoerr "Provide the names of the plugin, and of its guard"'
    endif

    try
        profile start $XDG_RUNTIME_DIR/plugin_profiling_report
        let [ plugin_name, guard_name ] = a:000
        exe 'prof! file ~/.vim/plugged/'.plugin_name.'/**/*.vim'
        exe 'unlet! '.guard_name
        call writefile(map(filter(glob($HOME.'/.vim/plugged/'.plugin_name.'/**/*.vim', 0, 1),
        \                         { i,v -> v !~# '/t\%[est]/' }),
        \                  { i,v -> 'so '.v }),
        \              $XDG_RUNTIME_DIR.'/plugin_profiling_report')
        sil! so $XDG_RUNTIME_DIR/plugin_profiling_report

    catch
        return lg#catch_error()
    endtry
    echo 'Recreate the issue, restart Vim, and have a look at '.$XDG_RUNTIME_DIR.'/plugin_profiling_report'
endfu



nmap  Q  gq



" ino <c-c> <c-r>=string(eval(input('Calculate: ')))<cr>
" ino <c-c> <c-r>=eval(input('Calculate: '))<cr>


" don't use `<space>g`, I press it by accident too often
nno  <silent>  <space>G  :<c-u>let g:my_goyo_without_syntax_hl = 1
                         \<bar> exe 'Goyo'.(!exists('#goyo') ? ' 110' : '!')
                         \<bar> norm coz<cr>

nno  <silent>  <space><c-g>  :<c-u>let g:my_goyo_without_syntax_hl = 0
                             \<bar> exe 'Goyo'.(!exists('#goyo') ? ' 110' : '!')<cr>

fu! s:goyo_enter() abort
    sil !tmux set status off
    " FIXME:
    " If we have 2 panes in the same window, and Vim is one of them, when we
    " start goyo mode, we only see half of the screen. We probably need to
    " resize the Tmux pane from the plugin, earlier.
    sil !tmux list-panes -F '\#F' | grep -q Z || tmux resize-pane -Z
    let s:cul_save = &l:cul
    norm ]oL
    set scrolloff=999
    set noshowcmd

    let  s:goyo_cocu_save = &l:cocu
    let  s:goyo_cole_save = &l:cole
    setl concealcursor=nc conceallevel=3

    " FIXME:
    " need to find another way to change the shape of the cursor in Neovim
    if !has('nvim')
        let &t_EI = "\e[4 q"
        exe "norm! r\e"
    endif

    let pos = getcurpos()
    " The new window created by `:tab sp` inherits the window-local options of
    " the original window. But `:tab sp` doesn't fire `BufWinEnter` so we lose
    " our position in the changelist.
    "
    " FIXME: We should  use the function `s:restore_change_position()`  but it's
    " local to `vim-window`.
    sil! exe 'norm! '.(exists('b:my_change_position') ? '99g;' : '99g,')
    \                .(b:my_change_position - 1) .'g,'
    call setpos('.', pos)

    if get(g:, 'my_goyo_without_syntax_hl', 1)
        let syntax_groups = [
        \                     'Conditional',
        \                     'Delimiter',
        \                     'Function',
        \                     'Identifier',
        \                     'MatchParen',
        \                     'Number',
        \                     'Operator',
        \                     'PreProc',
        \                     'Special',
        \                     'Statement',
        \                     'String',
        \                     'Type',
        \                     'snipSnippet',
        \                   ]

        for group in syntax_groups
            exe 'hi '.group.' term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE'
        endfor
    endif
    Limelight
endfu

fu! s:goyo_leave() abort
    sil !tmux set status on
    sil !tmux list-panes -F '\#F' | grep -q Z && tmux resize-pane -Z
    set  showcmd
    exe 'norm '.(s:cul_save ? '[' : ']').'oL'
    set  scrolloff=3

    let &l:concealcursor = s:goyo_cocu_save
    let &l:conceallevel = s:goyo_cole_save
    unlet! s:goyo_cocu_save s:goyo_cole_save

    let &t_EI = "\e[2 q"

    exe "norm! r\e"

    exe 'colo '.g:colors_name
    Limelight!
endfu

augroup my_goyo
    au!
    " FIXME:
    " If we use `nested`, `:NoMatchParen` doesn't work.
    " It doesn't work, even if we type the command later, while in goyo mode.
    " Why?
    " Should we get rid of `nested` in the 2nd autocmd (GoyoLeave)?
    " Why do we need `nested` anyway?

    au User GoyoEnter        call s:goyo_enter()
    au User GoyoLeave nested call s:goyo_leave()
augroup END



" MISC {{{1

" :FzLocate
" $ lrv



" let g:nums = split(": one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen")
" let g:tens = split(": ten twenty thirty fourty fifty sixty seventy eighty ninety")

" fu! Read_number(n) abort
"     let n = a:n
"
" "                        ┌── quotient
" "                        │                                              ┌── remainder
" "                        │                                              │
"     " n/1000             how many thousands in n                  ; the remain is n%1000
"     " (n%1000)/100       how many hundreds in the previous remain ; the new remain is (n%1000)%100
"     " (n%1000)%100/10    how many tens     in what remains        ; the new remain is ((n%1000)%100)%10
"     if n >= 1000
"         return  g:nums[n/1000].' thousand '
"             \ . g:nums[(n%1000)/100].' hundred '
"             \ . g:tens[(n%1000)%100/10].' '
"             \ . g:nums[((n%1000)%100)%10]
"
"     " n/100              how many hundreds in n               ; the remain is n%100
"     " (n%100)/10         how many tens in the previous remain ; the new remain is (n%100)%10
"     elseif n >= 100
"         return g:nums[n/100].' hundred '
"             \ . g:tens[(n%100)/10].' '
"             \ . g:nums[(n%100)%10]
"
"     " n/10               how many tens in n                   ; the remain is n%10
"     elseif n >= 20
"         return g:tens[n/10].' '.
"              \ g:nums[n%10]
"
"     else
"         return g:nums[n]
"     endif
" endfu



" we can't be locked inside an infinite loop, because after first iteration,
" we go from `n` to `n%1000` (which is < 1000). Then to `n%100` (< 100), then
" to `n%10` (<9), at which point the function doesn't call itself anymore.
" This proves that, provided the nr is < 20000, the function can't be called more
" than 4 times.
" The code breaks at 20000, because `20000/1000 = 20`, and g:nums[20] doesn't
" exist: "twenty" is not in g:nums.

" fu! Read_number(n) abort
"     let n = a:n
"
"     " if n >= 1000000
"     "     return g:nums[n/1000000].' million '.Read_number(n%1000000)
"     " elseif n >= 1000
"     if n >= 1000
"         return g:nums[n/1000].' thousand '.Read_number(n%1000)
"         " return (n/1000 <= 9 ? g:nums[n/1000] : Read_number(n/1000)).' thousand '.Read_number(n%1000)
"     elseif n >= 100
"         return g:nums[n/100].' hundred '.Read_number(n%100)
"     elseif n >= 20
"         return g:tens[n/10].' '.Read_number(n%10)
"     else
"         return (n !=# 0 ? g:nums[n] : '')
"     endif
" endfu



" call fzf#run({'source': map(range(1, bufnr('$')), { i,v -> bufname(v) }),
"             \ 'sink': 'e', 'down': '30%'})



" ino <c-g>d <c-r>=<sid>diagram_complete()<cr>
"
" fu! s:diagram_complete() abort
"     let previous_line = getline(line('.')-1)
"     let new_line      = substitute(previous_line, '\v%(└|┌).*', '', '')
"     if stridx(previous_line, '┌') !=# -1
"         let new_line .= '│'
"     endif
"     let new_line = substitute(new_line, '[^└┌│'.split(&l:cms, '%s')[0].']', ' ', 'g')
"     call setline('.', new_line)
"     return repeat("\<Right>", col('$') - col('.'))
" endfu
