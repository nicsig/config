" OPTIONS_1 {{{1
" Why this setting?{{{
"
" When we use gVim, we don't want `$VIMRUNTIME/menu.vim` to be sourced.
" We won't use the menu. It makes Vim start around 50ms slower.
" https://www.reddit.com/r/vim/comments/5l939k/recommendation_deinvim_as_a_plugin_manager/dbu74zd/
"
" The default value is 'aegimrLtT'.
" We could also let 'go' unchanged, and write this instead:
"
"         let did_install_default_menus = 1
"         let did_install_syntax_menu = 1
"
" In this case, we would keep the menu bar but avoid loading the default menus.
" For more info, see :h menu.vim
"}}}
" Why here, before the plugins, and not after, with the other options?{{{
"
" From `:h 'go-M`:
"
" Note that  this flag  must be added  in the .vimrc  file, before  switching on
" syntax  or filetype  recognition (…;  the  `:syntax on`  and `:filetype  on`
" commands load the menu too). `:filetype on` and `:syntax on` source menu.vim.
"}}}
set go=M

" PLUGINS {{{1
" Disable plugins {{{2

" Could I disable `netrw`?{{{
"
" Yes:
"
"     " no interface
"     let g:loaded_netrwPlugin = 1
"
"     "no autoload/
"     let g:loaded_netrw = 1
"
" See `:h netrw-noload`.
"}}}
" Why don't you do it?{{{
"
" It would break the `:Gbrowse` command provided by `vim-fugitive` and `vim-rhubarb`.
" If the file you're working on is hosted on GitHub, `:Gbrowse` lets you read it
" in your webbrowser.
"
" Although, you could disable `netrw` and still use `:Gbrowse`:
"
"     com! -bar -nargs=* Browse call system('xdg-open '.shellescape(<q-args>))
"
" `:Browse` is an undocumented feature of `vim-fugitive`.
" See: https://github.com/tpope/vim-fugitive/blob/2564c37d0a2ade327d6381fef42d84d9fad1d057/autoload/fugitive.vim#L3446-L3447
"
" I still prefer to enable `netrw`, because  other plugins may rely on it, and I
" don't want to lose time debugging them.
"}}}

" I don't  want to  see `GLVS`  nor `GetLatestVimScripts`  when I  press Tab/C-d
" after the beginning of the name of a command.
let g:loaded_getscriptPlugin = 1

" Disable the Vimball plugin.
" Alternative:{{{
" These commands remove the interface of the Vimball plugin:
"
"     sil! delc MkVimball
"     sil! delc RmVimball
"     sil! delc UseVimball
"     sil! delc VimballList
"     sil! delc Vimuntar
"}}}
" interface
let g:loaded_vimballPlugin= 1
" autoload
let g:loaded_vimball      = 1

" vim-plug:  installation {{{2

" We install vim-plug if it's not already.
"
" To know whether vim-plug is installed or not, we check whether the file:
"
"        ~/.vim/autoload/plug.vim
"
" … exists.

if empty(glob('~/.vim/autoload/plug.vim'))
    sil !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
                \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    au VimEnter * PlugInstall | source $MYVIMRC
endif

" Disable shallow cloning.
"
" We want the full copy of a repo, to see all the commit history.
" Can be explored later with `:[Fz][B]Commits`.
" Useful to understand why a particular change was introduced in a plugin
" without having to go to github.    Cost more bandwidth though.

let g:plug_shallow = 0

" vim-plug:  usage  {{{2

" Why this check?{{{
"
" We shouldn't reload  the interface of all our plugins  every time we re-source
" the vimrc.
" If a plugin is missing a guard, this could have unexpected effects.
"}}}
" Is there a drawback?{{{
"
" Yes.
"
" If you remove  the `Plug` line of  a plugin, `:PlugClean` will  not remove its
" files, because `vim-plug` won't be informed.
" You need to restart Vim.
"}}}
if has('vim_starting')

" Plugins must be declared after this line.
" They will be downloaded inside `~/.vim/plugged/`.
call plug#begin('~/.vim/plugged')

" To Assimilate:
Plug 'lacygoill/vim-abolish', {'branch': 'assimil'}
Plug 'lacygoill/asyncmake', {'branch': 'assimil'}
Plug 'lacygoill/vim-cwd'
Plug 'lacygoill/vim-debug'
Plug 'junegunn/vim-easy-align'
Plug 'lacygoill/vim-exchange'
Plug 'lacygoill/vim-fex'
Plug 'tpope/vim-fugitive'
" You can pass more arguments to the fzf installer:
"     $ ~/.fzf/install --help
Plug 'junegunn/fzf', {'dir': '~/.fzf', 'do': './install --all --no-bash'}
Plug 'junegunn/fzf.vim'
Plug 'lacygoill/goyo.vim', {'branch': 'assimil'}
Plug 'lacygoill/vim-graph'
" TODO: remove `vim-gutentags`{{{
"
" Use git hooks instead.
" Less code, more control, occasion to better understand git.
"
"     https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration
"     https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks
"     https://git-scm.com/docs/githooks
"
"     https://tbaggery.com/2011/08/08/effortless-ctags-with-git.html
"     https://github.com/tpope/tpope/tree/master/.git_template
"     https://github.com/tpope/tpope/blob/master/.gitconfig
"
" Update:
" A file watcher (like entr) may be even better.
" http://eradman.com/entrproject/
" See:
"     ~/bin/entr-reload-browser
"     ~/bin/entr-watch
"
" Try:
"     % ( ls ~/Dropbox/wiki/web/practice/htdocs/*.html | entr entr-reload-browser Firefox &! )
"     % vim ~/Dropbox/wiki/web/practice/htdocs/index.html
"     open the file in firefox too, then edit the file in Vim, then watch the page in firefox
"
" Issue:
" Your tags will be generated only in git projects.
" Not in projects using other VCS systems (`.hg/`, `.bzr/`, ...).
"}}}
Plug 'ludovicchabant/vim-gutentags'
Plug 'lacygoill/limelight.vim', {'branch': 'assimil'}
Plug 'foxik/vim-makejob'
" the neovim `man` plugin is better
" TODO: although it doesn't support our custom motions such as `]r`
if !has('nvim')
    Plug 'lacygoill/vim-man'
endif
Plug 'lacygoill/vim-markdown'
Plug 'lacygoill/vim-matchit'
Plug 'kana/vim-operator-user/', {'frozen': 1}
Plug 'lacygoill/potion'
Plug 'lacygoill/vim-quickhl', {'branch': 'assimil'}
Plug 'lacygoill/vim-repeat', {'branch': 'assimil'}
Plug 'tpope/vim-rhubarb'
" Alternative: https://github.com/t9md/vim-textmanip
Plug 'lacygoill/vim-schlepp'
Plug 'junegunn/seoul256.vim'
Plug 'justinmk/vim-sneak'
Plug 'tpope/vim-speeddating'
Plug 'lacygoill/vim-submode', {'branch': 'assimil'}
Plug 'lacygoill/vim-tmuxify', {'branch': 'assimil'}
Plug 'lacygoill/vim-unix'

" Done:
Plug 'lacygoill/vim-awk'
Plug 'lacygoill/vim-brackets'
Plug 'lacygoill/vim-breakdown'
Plug 'lacygoill/vim-bullet-list'
Plug 'lacygoill/vim-capslock'
Plug 'lacygoill/vim-cmdline'
Plug 'lacygoill/vim-column-object'
Plug 'lacygoill/vim-comment'
Plug 'lacygoill/vim-completion'
Plug 'lacygoill/vim-conf'
Plug 'lacygoill/vim-draw'
Plug 'lacygoill/vim-fold'
Plug 'lacygoill/vim-freekeys'
Plug 'lacygoill/vim-gitcommit'
Plug 'lacygoill/vim-gitconfig'
Plug 'lacygoill/vim-gx'
Plug 'lacygoill/vim-help'
Plug 'lacygoill/vim-hydra'
Plug 'lacygoill/vim-iabbrev'
Plug 'lacygoill/vim-interactive-lists'
Plug 'lacygoill/vim-latex'
Plug 'lacygoill/vim-lg-lib'
Plug 'lacygoill/vim-logevents'
Plug 'lacygoill/vim-lua'
Plug 'lacygoill/vim-math'
Plug 'lacygoill/vim-par'
Plug 'lacygoill/vim-python'
Plug 'lacygoill/vim-qf'
Plug 'lacygoill/vim-readline'
Plug 'lacygoill/vim-reorder'
Plug 'lacygoill/vim-save'
Plug 'lacygoill/vim-search'
Plug 'lacygoill/vim-selection-ring'
Plug 'lacygoill/vim-session'
Plug 'lacygoill/vim-sh'
Plug 'lacygoill/vim-snippets'
Plug 'lacygoill/vim-source'
Plug 'lacygoill/vim-stacktrace'
Plug 'lacygoill/vim-statusline'
Plug 'lacygoill/vim-term'
Plug 'lacygoill/vim-titlecase'
Plug 'lacygoill/vim-toggle-settings'
Plug 'lacygoill/vim-vim'
Plug 'lacygoill/vim-window'
Plug 'lacygoill/vim-xkb'

" Read Doc:
Plug 'justinmk/vim-dirvish'
Plug 'mattn/emmet-vim'
Plug 'machakann/vim-sandwich'
Plug 'SirVer/ultisnips'
Plug 'lervag/vimtex'

" Other:
Plug 'mbbill/undotree'
Plug 'chrisbra/unicode.vim'
Plug 'keith/tmux.vim'

" Some functions installing an interface are  too slow to be called during Vim's
" startup. We delay them.
fu! s:delay_slow_call() abort
    runtime autoload/toggle_settings.vim
    runtime! autoload/slow_call/*.vim
    au! delay_slow_call
    aug! delay_slow_call
endfu

augroup delay_slow_call
    au!
    " Do NOT use a simple timer:{{{
    "
    "     au VimEnter * call timer_start(1000, {->
    "         \       execute('runtime  autoload/toggle_settings.vim
    "         \ |              runtime! autoload/slow_call/*.vim', '')
    "         \ })
    "
    " It could cause issues, for example, if you enter insert mode quickly (i.e.
    " before  the  callback),  and  some  custom  code  of  yours  rely  on  the
    " lazy-loaded interface.
    "
    " If you  still have issues because  you execute some normal  command before
    " the lazy-loaded  interface has  been installed, maybe  try to  add another
    " event to the autocmd.
    "}}}
    au CursorHold,InsertEnter  *  call s:delay_slow_call()
    " Do NOT call the function when we enter debug mode (>).
    " It could raise spurious errors when we debug Vim (`$ vim -D`).
    au CmdlineEnter  :,/,\?,@  call s:delay_slow_call()
augroup END

call plug#end()
endif

" }}}1
" OPTIONS_2 {{{1
" ENCODING {{{2
" Why should you leave this section at the top of our options configurations.{{{
"
" If for some reason (shell environment), 'encoding' = 'latin1', and we use an
" exotic character in our vimrc, it will raise an error. As an example, see
" the value we give to 'listchars'.
" We need to make sure that Vim will use 'utf-8' as an encoding as soon as
" possible. Note that the real important option to avoid an error during
" startup, isn't 'termencoding', but 'encoding'.
"}}}

" Sets the character encoding used inside Vim.
" It applies  to text in  the buffers,  registers, Strings in  expressions, text
" stored in the viminfo file, etc.
" It sets the kind of characters which Vim can work with.
" It  also   automatically  enables   saner  encoding  detection   settings  for
" 'fileencodings':
"
"         https://vi.stackexchange.com/a/17326/17449
set encoding=utf-8

" To avoid errors, we could also write:
"         scriptencoding utf-8
"
" This would tell Vim to convert the following lines in `vimrc` to utf-8.
" But setting `encoding` seems to have a broader scope, and hence be better,
" as I want every file sourced after `vimrc` to be read using the `utf-8`
" encoding (ex: filetype plugins).

" Encoding used for the terminal.  This specifies what character
" encoding the keyboard produces and the display will understand.
set termencoding=utf-8

" FTPLUGINS + SYNTAX {{{2

" Commented because we don't need this anymore.{{{
"
" `vim-plug` already does it for us.
" I keep this section in case it might be necessary if one day we change our plugin
" manager.
"
" From: https://github.com/junegunn/vim-plug/wiki/faq
"
"         vim-plug does not require any extra statement other than plug#begin()
"         and plug#end(). You can remove filetype off, filetype plugin indent on
"         and syntax on from your .vimrc as they are automatically handled by
"         plug#begin() and plug#end().
"
" See also:
"         https://github.com/junegunn/vim-plug/issues/83
"}}}
" filetype plugin indent on

" Why do you comment this?{{{
"
" `vim-plug` already does it.
"}}}
" Why the guard?{{{
"
" To avoid syntax plugins to be reloaded every time we source our vimrc.
"}}}
" Why not `if !exists('g:syntax_on')`?{{{
"
" A global variable seems more brittle.
" It could be wrongly deleted.
"}}}
"     if has('vim_starting')
"         syntax enable
"     endif

" GUI {{{2

if has('gui_running')
    set guifont=DejaVu\ Sans\ Mono\ 20
endif

" ENVIRONMENT "{{{2

" TODO: We should probably remove this assignment.{{{
"
" To create RELIABLE links inside a wiki, we should use tags:
"
"     https://stackoverflow.com/q/25742396
"
" Indeed, with  regular links (filepaths),  if we rename  a file, or  change its
" location, we need to refactor all links towards the latter.
" With tags,  we would just  need to re-generate the  tags file with  an autocmd
" listening to `BufWritePost` or sth like that.
"
" The goal  would be to  have tags, like  in help files,  on which we  can press
" `C-]` to automatically jump to an arbitrary location inside the wiki.
" This would also allow us to leverage all built-in commands/functions dedicated
" to tags.
"
" See also:
"     https://maximewack.com/post/tagbar/
"     https://github.com/vimwiki/utils/blob/master/vwtags.py
"     https://gist.github.com/MaximeWack/cdbdcd373d68d1fe5b3aca22e3dcfe46
"     https://gist.github.com/MaximeWack/388c393b7db290dd732f0a2d403118c5
"
"     https://github.com/majutsushi/tagbar
"     https://github.com/majutsushi/tagbar/wiki#markdown
"     https://github.com/jszakmeister/markdown2ctags
"     https://github.com/lvht/tagbar-markdown
"}}}
" Used in our notes when we create links between files, in a wiki on a topic.
let $MY_WIKI = $HOME.'/Dropbox/wiki'

" Why?{{{
"
" For some reason, when you start `(n)vim` with `$ man`, the value of `$MANSECT`
" is truncated.
" Only the first section number before the first colon is kept.
" The rest is lost.
"
" Because of this:
"     $ man man
"     :Man mount
"       → ✘
"         man.vim: command error (11) man -w mount: No manual entry for mount
"         See 'man 7 undocumented' for help when manual pages are not available.
"
" So,  in `~/.zshenv`,  I've created  a duplicate  variable, `MYMANSECT`,  which
" serves as a backup.
" And here, I make sure to reset the value of `MANSECT` to `$MYMANSECT`.
"}}}
let $MANSECT = $MYMANSECT

if !isdirectory($XDG_RUNTIME_DIR.'/vim')
    call mkdir($XDG_RUNTIME_DIR.'/vim', 'p', '0700')
endif
let $XDG_RUNTIME_VIM = $XDG_RUNTIME_DIR.'/vim'
" For more info about `$XDG_RUNTIME_DIR`:
"
"     https://standards.freedesktop.org/basedir-spec/latest/ar01s03.html
" }}}2

" backspace {{{2

" Allow BS, Del, C-w, C-u to delete:
"
"             ┌─ whitespace (autoindent)
"             │      ┌─ end of line (join line)
"             │      │   ┌─ text which was before the cursor when we went
"             │      │   │  into insert mode
"             │      │   │
set backspace=indent,eol,start

" clipboard {{{2
" Do NOT tweak this option!
"         Why could you be tempted to change the value of this option?{{{
"
" When you use a pasting command,  and you don't specify from which register you
" want the text to be pulled, Vim uses the `"` register.
" So, if you want to copy some text from a Vim buffer to Firefox, you'll need to
" explicitly mention the name of the `+` register:
"
"         "+yy
"
" Same thing if you want to paste  in a Vim buffer, some text you've just copied
" in Firefox:
"
"         "+p
"
" It would be convenient to just press `yy` and `p`, and Vim would automatically
" use the system register, instead of the unnamed one.
" That's what 'cb' is for.
"}}}
"         How should you change it?{{{
"
"         set clipboard^=unnamedplus
"
" 'cb' contains a comma-separated list of values. Each stands for a register.
" The previous command PREpends `unnamedplus` to this list.
" `unnamedplus` stands for the system register.
"
" Do NOT execute this:
"
"         set clipboard+=unnamedplus
"
" It would APpend the value to the list.
"}}}
"         Technically, what happens if you do it?{{{
"
" The system  register register will  now have  a similar (although  not exactly
" identical) behavior than the one of the unnamed:
"
"     • it will contain the text of the last changed register (like `"`)
"
"     •  … except  if  the  last changed  register  was  changed by  a  command
"       containing its explicit name:
"
"               "ayy
"
"       This  is different from `"`,  which always copy  the text of the  last changed
"       register.
"
" If you copy some text in Firefox,  it goes into `+` (regardless of 'cb').  But
" because  of the  new value  of 'cb',  `p` will  automatically paste  `+` (last
" copied text in Firefox).
"
" If you copy  some text in a  Vim buffer, it goes into  `0`. The latter becomes
" the last modified register, and thus  `+` will duplicate its contents (because
" of 'cb').
"
" `"` will still  copy the text of the last changed register:
"
"     set cb^=unnamedplus | let [@+, @"] = ['foo', 'bar'] | norm! p
"           → foo
"
"     set cb&             | let [@+, @"] = ['foo', 'bar'] | norm! p
"           → bar
"}}}
"         Are there pitfalls?{{{
"
" Yes a shitload.
"
" 1. It pollutes the system clipboard after every yank, delete, change.
" 2. It may break a plugin which forgets to temporarily reset 'cb' to its default value.
" 3. It may break a plugin, even if it temporarily resets 'cb'.
"
" Example:
" Consider a buffer, with just the text `pat`.
" Execute this command on the line where `pat` is:
"
"         norm ysiw'
"
" vim-surround should surround `pat` with single quotes.
" Undo, and execute:
"
"         g/pat/norm ysiw'
"
" Nothing happens. The issue:
"
"         • does NOT come the fact that vim-surround forgets to temporarily resets 'cb';
"           vim-surround does NOT forget it
"
"         • is fixed if you don't tweak 'cb' (set cb&vim)
"}}}
" colorscheme {{{2

augroup my_colorscheme
    au!
    au ColorScheme * call colorscheme#customize()

    " What's the issue fixed by this autocommand?{{{
    "
    "     $ cat <<'EOF' >/tmp/md.md
    "     word in *italic*
    "     EOF
    "
    "     $ vim /tmp/md.md
    "     ]ol (change lightness)
    "
    " `italic` is not in italic anymore (✘).
    "}}}
    " Where does the issue come from?{{{
    "
    " The `htmlItalic` HG is sometimes cleared, because of `:hi clear`:
    "
    "     ~/.vim/plugged/seoul256.vim/colors/seoul256.vim:201
    "
    " More generally, any HG whose attributes  are defined in a syntax plugin is
    " cleared.
    " The issue doesn't affect linked HGs:
    "
    "     " ✔
    "     hi [def] link SomeGroup OtherGroup
    "
    "     " ✘
    "     hi [def] link SomeGroup term=... ctermfg=...
    "}}}
    au ColorScheme * call s:reinstall_cleared_hg()

    " Why changing `CursorLine`?{{{
    "
    " The  attributes set  by our  colorscheme make  the cursorline  not visible
    " enough.
    "}}}
    " Why `ctermbg=NONE` and `guibg=NONE`?{{{
    "
    " To make `CursorLine` transparent in case of a conflict between two HGs.
    " It happens  when `'cursorline'` is set,  and the *background* of  the text
    " under the cursor is highlighted by a syntax item.
    "}}}
    " It's not visible enough!{{{
    "
    " Add the bold value:
    "
    "     hi CursorLine term=bold,underline cterm=bold,underline gui=bold,underline ctermbg=NONE guibg=NONE
    "                        ^^^^                 ^^^^_              ^^^^
    "}}}
    au Colorscheme * hi CursorLine term=underline cterm=underline gui=underline ctermbg=NONE guibg=NONE
augroup END

fu! s:reinstall_cleared_hg() abort
    " Why don't you simply run `:do Syntax`?{{{
    "
    " Suppose you have two windows, one with a python buffer, and the other with
    " a markdown buffer.
    " You change the colorscheme while in the python buffer.
    " The HGs whose attributes are defined in `$VIMRUNTIME/syntax/html.vim` will
    " be cleared, which may have an effect  on the rendering of some text in the
    " markdown buffer.
    " But since you're  in a python buffer, `:do Syntax`  will reload the python
    " syntax plugin, while you need to reload the html syntax plugin.
    "}}}
    " Why don't you manually re-install every cleared HG?{{{
    "
    " It would create duplication.
    " Some HGs would be installed from a syntax plugin, and from this file.
    " If one day their definition is updated  in the syntax plugin, we would have an
    " inconsistency.
    "
    " Besides, we would be constantly chasing new cleared HGs, and even then, we
    " could miss some of them.
    " It's not reliable.
    "}}}
    " Is there an alternative?{{{
    "
    " Yes:
    "
    "     :doautoall syntax
    "
    " But it's too slow when we have a lot of buffers.
    "}}}

    " What does this code do?{{{
    "
    " It iterates over all the windows in all the tabpages.
    " For each  of them,  if it  has never  seen the  filetype of  the displayed
    " buffer, it reloads its syntax plugin.
    "}}}
    let orig_winid = win_getid()
    let seen = {}
    for info in getwininfo()
        let ft = getbufvar(info.bufnr, '&ft')
        if !has_key(seen, ft)
            let seen[ft] = 1
            if ft isnot# ''
                call win_gotoid(info.winid)
                do Syntax
            endif
        endif
    endfor
    call win_gotoid(orig_winid)
endfu

" Why the guard?{{{
"
"     • there's no point reloading the colorscheme every time we source our
"       vimrc
"
"     • without a guard, every time we write the vimrc, the colorscheme would
"       be reloaded, which would make us lose syntax highlighting in
"       a `freekeys` buffer, because of `:hi clear`:
"
"               ~/.vim/plugged/seoul256.vim/colors/seoul256.vim:201
"}}}
if has('vim_starting')
    " In a console, we want a readable colorscheme.
    if $DISPLAY is# ''
        colo morning
    else
        " What's the purpose of this call?{{{
        "
        " We want to memorize somewhere the  last version of the colorscheme we used
        " (atm it's expressed by an ANSI code: 233 … 239, 252 … 256).
        "}}}
        " Is there an alternative?{{{
        "
        " Yes.
        " We could use viminfo.
        "
        " Note that  when the vimrc  is read, the viminfo  hasn't been read  yet (:h
        " startup),  so if  you decide  to  use viminfo,  you'll have  to delay  the
        " loading of the colorscheme until VimEnter:
        "
        "      au VimEnter * nested call s:set_colorscheme()
        "                  │
        "                  └─ the autocmds need to nest, so that when we set the colorscheme,
        "                     `ColorScheme` is fired, and our customizations are sourced
        "
        " Also, you'll need to use a variable name in uppercase.
        "}}}
        " Why don't you use the alternative?{{{
        "
        " The  alternative requires that  we delay  the sourcing of  the colorscheme
        " until VimEnter. Besides, the colorscheme executes `:hi clear` which removes
        " any custom HG we may have defined.
        "
        " So, if we delay the colorscheme, we must redefine all our custom HGs.
        "
        " But, I can't know in advance all the custom HGs currently defined.
        " It depends on the files which have been read during Vim startup.
        "
        " For example, if  we start Vim to  read a markdown file,  the htmlItalic HG
        " will have been installed to apply the italic style on the text between two
        " asterisks. We need to avoid clearing it right after Vim has been started.
        "}}}
        au my_colorscheme VimLeavePre * call colorscheme#save_last_version()

        " try to restore the exact version of the last colorscheme used
        let s:file = $HOME.'/.vim/colors/my/last_version.vim'
        if filereadable(s:file)
            exe 'so '.s:file
            unlet! s:file
        endif
        call colorscheme#set()
    endif
endif

" cmd  mode  ruler{{{2

" When we move the cursor (hjkl wbe …) and Vim consumes a lot of cpu / is slow,
" it can be for 2 reasons:
"
"         • we're inside a deep nested fold:  solution → open folds (zR)
"         • 'showcmd' is enabled:             solution → disable it

" Even though it can have an impact on performance, we enable 'showcmd',
" because sometimes it's useful to see what we type. Also, it's useful to see
" the number of lines inside the visual selection.
set showcmd


" When we're in normal mode, some information can be displayed in the bar
" which replaces the command-line:
"
"         • current mode                  don't want to see it
"         • normal command being typed    DO    want to see it

set noshowmode


" When 'stl' is empty, Vim displays the current line address, and column
" number, in the statusline.  This region is called the “ruler bar“ (:h ruler).
"
" Even though we should never see it, disable it explicitly.
set noruler

" cms {{{2

" Without the  guard, when  you reload  the vimrc, the  fold titles  display the
" comment leader.
if has('vim_starting')
    set cms=
endif

" cpoptions {{{2

" When I type `:r some_file` or `:'<,'>w some_file`, I don't want `some_file`
" to become the alternate file of the current window.
" set cpo-=aA

" 'cpo' doesn't contain the M flag by default.
" It means that escaped parentheses are ignored when we hit ib
" (inside parentheses text-object)
" E.g.:
" if we hit dib while the cursor is on O in the following text:
"     (hello \(fOo) world)
" We get:
"     () world)
" For the moment, we prefer that Vim doesn't ignore escaped parentheses:

set cpo+=M

" the nr column (`'nu'`,  `'rnu'`) will be taken into account  to decide when to
" wrap long lines
set cpo+=n

" So instead we get:
"     (hello \() world)

" What the `y` flag does?{{{
" It allows you to redo a yank command with the dot command:
"
"     set cpo+=y
"}}}
" Why you shouldn't add it to 'cpo'?{{{
"
" It breaks  the repetition of an  edition on a  set of selected lines  with the
" `:normal` command, and with our custom dot command:
"
"         :set cpo+=y
"         A ) Esc
"         visually select lines
"         :norm! .
"
" Note that by default, the dot command doesn't work in visual mode.
" It works only because of our mapping:
"
"     xno  <silent>  .  :norm! .<cr>
"
" FIXME: Why does `set cpo+=y` break `:norm! .` in visual mode?
"}}}

" diffopt {{{2

" Start diff mode with vertical splits (unless explicitly specified otherwise).
set diffopt+=vertical

" Turn off diff mode automatically for a buffer which becomes hidden.
set diffopt+=hiddenoff

if !has('nvim')
    " The “patience” algorithm gives more readable diffs.
    " Why isn't patience the default?{{{
    "
    " The default algorithm is “myers”.
    "
    " 1. patience is slower:
    "
    "     https://marc.info/?l=git&m=133103975225142&w=2
    "
    " 2.
    " > Myers has  been the universal  default diff  algorithm for so  long that
    " > enabling an alternative algorithm by default in a low-level component of
    " > our world (Git, Vim, etc.) could cause issues down the line.
    "
    " Source:
    "         https://www.reddit.com/r/vim/comments/a26phr/the_power_of_diff_vimways_124/eavzmke/
    "}}}
    set diffopt+=algorithm:patience

    " Use the indent heuristic for the internal diff library.
    " Again, this gives more readable diffs.
    set diffopt+=indent-heuristic
    " For more info, see:
    "
    "     https://vimways.org/2018/the-power-of-diff/
endif

" display {{{2

" When the last line of the window doesn't fit on the screen, Vim replaces it
" with character @. We want Vim to show us as much text as possible from the
" last line and, only when there isn't anymore room, replace the remaining text
" with @.

set display+=lastline

" fillchars {{{2

set fillchars&vim

" Replace ugly  separators (`|`)  used for vertical  splits, with  prettier utf8
" characters, to get a continuous line.
set fillchars=vert:┃

" Pad end of title lines with spaces instead of hyphens.
let &fillchars .= ',fold: '

" flp "{{{2

"                      ┌ recognize numbered lists
"                      ├──────┐
let &g:flp = '\m^\s*\%(\d\+[.)]\|[-*+•]\)\s\+'
"                                ├────┘
"                                └ recognize unordered lists

augroup my_default_formatlistpat
    au!
    " We've configured the global value of 'flp'.
    " Do the same for its local value in ANY filetype.
    au FileType * let &l:flp = &g:flp
augroup END

" Is 'flp' used automatically? {{{
"
" No, you also need to include the `n` flag inside 'fo' (we did in `vim-par`).
" This tells Vim to use 'flp' to recognize lists when we use `gw`.
"}}}
" What's the effect?{{{
"
" Some text:
"
"     1. some very long line some very long line some very long line some very long line
"     2. another very long line another very long line another very long line another line
"
" Press `gwip` WITHOUT `n` inside 'fo':
"
"         1. some very long line some very long line some very long line some very
"     long line 2. another very long line another very long line another very long
"     line another line
"
" Press `gwip` WITH `n` inside 'fo', and the right pattern in 'flp':
"
"     1. some very long line some very long line some very long line some very
"        long line
"     2. another very long line another very long line another very long line
"        another line
" }}}
" Why use `let &g:` instead of `setg`? {{{
"
" With `:setg`, you have to double  the backslashes because the value is wrapped
" inside a non-literal string.
"
" Also, you have to add an extra backslash for every pipe character
" (alternation), because one is removed by Vim to toggle its special meaning
" (command separator).
"
" So:    2 backslashes for metacharacters (atoms, quantifiers, ...)
"        3 backslashes for pipes
" }}}
" After pressing `gwip` in a list, how are the lines indented?{{{
"
" The indent of the text after the list header is used for the next line.
"}}}
" Compared to tpope ftplugin, our pattern is simpler. {{{
"
" He has added a third branch to describe a footnote. Sth looking like this:
"
"         ^[abc]:
"
" https://github.com/tpope/vim-markdown/commit/14977fb9df2984067780cd452e51909cf567ee9d
" I don't know how it's useful, so I didn't copy it.
" The title of the commit is:
"
"         Indent the footnotes also.
" }}}
" Don't conflate the `n` flag in 'fo' with the one in 'com'. {{{
"
" There's zero link between the two. This could confuse you:
"
"     setl com=f:•
"     let &l:flp = ''
"
"             • some very long line some very long line some very long line some very long line
"             • another very long line another very long line another very long line another line
"
"     gwip
"             • some very long line some very long line some very long line some
"               very long line
"             • another very long line another very long line another very long
"               line another line
"
" It worked. Vim formatted the list as we wanted. But it's a side effect of `•`
" being recognized as a comment leader, and using the `f` flag.
" For a numbered list, you have to add the `n` flag in 'fo', and include the right
" pattern in 'flp'. Why?
" Because you can't use a pattern inside 'com', only literal strings.
" }}}

" folding {{{2

" When starting  to edit another buffer  in a window, always  start editing with
" all folds closed. Technically, this global option sets the initial local value
" of 'foldlevel' in any window.
set foldlevelstart=0

" do NOT open folds when jumping with "(", "{", "[[", "[{", etc.
set foldopen-=block

" Close a fold even if it doesn't contain any line.
" Useful in our faq notes.
set foldminlines=0

" ft_ignore_pat {{{2

" Purpose:{{{
"
" We don't want `$VIMRUNTIME/filetype.vim` to set  the filetype of a `.log` file
" to `conf` simply because one of its first lines begin with a `#`.
"
" Indeed we often fold some log files using lines beginning with `#`.
"}}}
" Where did you find the beginning of the value?{{{
"
"     $VIMRUNTIME/filetype.vim:40
"}}}
let g:ft_ignore_pat = '\.\%(Z\|gz\|bz2\|zip\|tgz\|log\)$'
"                                                 ^^^

" :grep {{{2

" --vimgrep =
"
"         --column
"         --nocolor
"         --nogroup
"
" … and displays multiple matches on a single line

" Define `ag` as the program to call when using the Ex commands:
"         :[l]grep[add]

"                 ┌─ don't group all matches in a same file in a single result
"                 │  instead, prepend the filename in front of each match
"                 │
"                 │                                    ┌─ print column number
"                 │                                    │
set grepprg=ag\ --nogroup\ --nocolor\ --ignore-case\ --column\ --vimgrep\ -f
"                                                                │         │
"               when several matches are found on the same line, ┘         │
"               report each of them in a dedicated entry                   │
"               like the `g` flag for `:vimgrep`                           │
"                                                                          │
"                                                          follow symlinks ┘
"
"     Suppose we're looking for `pat` under current directory:
"             $ ag pat .
"
"     If `pat` is in `link`, which is a symlink pointing to the real file
"     outside the current directory, ag won't find it, unless we tell it to
"     follow symlinks.
"
" How to ignore a file?{{{
"
" Use the `--ignore` option.
" Example:
"
"         ag...\ --ignore\ mthesaur.txt
"}}}

" Define how the output of ag must be parsed:
"
"               ┌─ filename
"               │  ┌─ line nr
"               │  │  ┌─ column nr
"               │  │  │  ┌─ error message
"               │  │  │  │
set grepformat=%f:%l:%c:%m,%f:%l:%m
"   │
"   └─ default value:  %f:%l:%m,%f:%l%m,%f  %l%m

" hidden {{{2

" Hide a buffer when it's abandoned (instead of unloading it)

set hidden

" history {{{2

" Remember up to 1000 past commands / search patterns.
set history=1000

" invisible characters {{{2

" We define which symbol Vim must use to display certain symbols:
"
"     tab                       ▸
"     end of line               ¬
"     scroll unwrapped lines    » «
"     no-break space            ∅

set listchars=tab:▸\ ,eol:¬,precedes:«,extends:»,nbsp:∅

" includeexpr (gf) {{{2

fu! s:snr()
    return matchstr(expand('<sfile>'), '<SNR>\d\+_')
endfu

let &inex = s:snr().'inex()'

fu! s:inex() abort
    let line = getline('.')

    " Why?{{{
    "
    " If gf  fails to open the  file whose path  is under cursor, make  it retry
    " with the path after the equal sign.
    "
    " Useful because sometimes, we have something like:
    "
    "         set option=path
    "
    " And Vim tries to open 'option=path' instead of 'path'.
    "}}}
    if line =~# '='
        return substitute(v:fname, '.*=', '', '')
    else
        " The path could contain an environment variable:
        let path = '\C\%($\u\+\|"$\u\+"\|${\u\+}\|"${\u\+}"\)'.'\V'.v:fname
        "                                                        │
        "                                                        └ `v:fname` could contain a tilde
        if line =~# path
            let path = matchstr(line, path)
            let env = matchstr(path, '\u\+')
            return substitute(path, '"\=${\='.env.'}\="\=', eval('$'.env), '')
        endif
    endif

    return v:fname
endfu

" indentation {{{2

set autoindent
set expandtab
" Why don't you set 'ts'?{{{
"
" It would mess the alignment in help files, where tabs are used with a width of
" 8 cells. Besides, 'ts' is NOT used when 'expandtab' is set.
"}}}

" What's the effect of 'sr'?{{{
"
" When we hit:
"
"        • {count}>>
"        • {count}<<
"        • >{motion}
"        • <{motion}
"
" ... on indented lines,  if 'sr' is enabled, the new  level of indentation will
" be a multiple of `&sw`.
" Ex:
" The current level of indentation is 2, and `&sw` is 4.
" We hit `>>`:
"
"         • without `shiftround`, the new indent becomes 6
"         • with    `shiftround`, the new indent becomes 4
"}}}
" Why don't you enable 'sr' anymore?{{{
"
" It seems  to cause an  unexpected result when  we indent a  paragraph (`>ip`),
" some lines  of which  have an  indentation level  which is  not a  multiple of
" `&sw`.
" For more info, see our comments about our custom `>>` mapping.
"}}}
" Does it cause an issue?{{{
"
" Yes, the indentation is not fixed anymore when we do something like `>ip`.
"}}}
" Is there a solution?{{{
"
" I think you  want 'sr' to be  disabled only for buffers where  you take notes,
" not for code.
"
" Maybe you could install an autocmd (listening to BufEnter?), which would reset
" 'sr' when you enter a markdown buffer.
" Note that 'sr' is global, and not buffer-local unfortunately.
" So, you would have to re-enable 'sr' when you leave a markdown buffer (BufLeave?).
"
" For the moment,  I don't use this  solution because I'm fed up  with the “bug”
" where the relative indentation of a block of lines is lost when we do `>ip`.
" So, I prefer to  let 'sr' disabled by default, and  only enable it temporarily
" when I use `>>` or `<<`.
"
" But you may try later to use autocmds instead if you're curious.
" If this other solution works, you could remove the `>>` and `<<` mappings.
"
" Also, note that you can still fix  the indentation of a block of code with the
" `=` operator.
"}}}
" set shiftround

" What's the effect of 'sw'?{{{
"
" It controls the number of spaces added/removed when you hit:
"
"          • {count}>>
"          • {count}<<
"          • >{motion}
"          • <{motion}
"}}}
set shiftwidth=4

" When we hit `Tab` or `BS` in front of a line, we want to add/remove
" `&sw` spaces (and not `&ts` or `&sts`).
set smarttab

" By default, (when `smarttab` is not enabled), 'sts' controls how many spaces
" are added/removed when we hit `Tab` or `BS`.
"
"               ┌─ disable 'sts'; use 'sw' instead
"               │
set softtabstop=-1

" The way we've configured 'smarttab' and 'sts', we can now modify how tabs
" are handled by Vim, in all contexts, with a single option:    'sw'

" is_bash {{{2

" By default, Vim uses the Bourne shell syntax.
" We prefer to use `bash`.
"
" Indeed, most of the time, we'll use `bash`, and some bash constructs don't exist
" in Bourne shell, like commands substitutions ($(…)). These bashisms are
" considered as errors if   b:current_syntax is# 'sh'
"
" For more info, read `:h sh.vim`.
let g:is_bash = 1

" It's not needed when a shell script has a shebang containing `bash`.
" But it's  useful when we've just  created a shell file,  because initially Vim
" may not  be able  to deduce the  right shelltype (no  typical filename  and no
" shebang yet).


" For more info, see this:
"
"         https://github.com/neovim/neovim/issues/5559
"         https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=848663

" isfname {{{2

" A filename can contain an @ character.
" Example: /usr/lib/systemd/system/getty@.service
"
" It's important to include `@` in 'isf',  so that we can complete a filename by
" pressing Tab.
set isfname+=@-@

" join {{{2

" Don't insert two spaces after a '.', '?' and '!' with a join command.
set nojoinspaces

" kp {{{2

" When I press `K` on a keyword, use Vim's help by default.
set kp=:help

" lazyredraw {{{2
" What does it do?{{{
"
" Prevent the screen  from being redrawn while executing  commands which haven't
" been typed (e.g.: macros, registers).
" Also, postpone the update of the window title.
"}}}
" Why do you set it?{{{
"
" • Because of the previous description.
"
" • Setting this option prevents the screen to “flash” when we use a custom
"   mapping which makes the cursor move far from its initial position, then
"   come back. Example:  zv  *
"
" • junegunn, tpope, justinmk, blueyed,  mhinz ... they all  set this option.
"}}}
" Is there any pitfall?{{{
"
" Yes.
" Because  of this  option, sometimes,  we may  need to  execute `:redraw`  in a
" (function called by a) mapping.
"
" Example:    C-g j    (scroll-window; vim-submode)
"}}}
" Why do you check whether we're in gVim?{{{
"
" In gVim,  if you set 'lz'  and 'showcmd', then when  you press `j` and  `k` in
" normal mode, you see `gj` and `gk` being spammed on the command-line.
" I don't like that, and it could have a bad impact on performance.
"
" TODO:
" Why does resetting 'lz' in Vim does NOT make `gj` being displayed when I press
" `j`?
" And why does setting 'lz' in gVim DOES make `gj` being displayed when I press `j`?
" MWE:
"
"     nno  j  gj
"     nno  k  gk
"     set lazyredraw
"     set showcmd
"}}}
" TODO: Is 'lazyredraw' broken in Neovim?{{{
"
" In the past, I think it caused the  index message after a search to be weirdly
" displayed.
"
"         https://github.com/neovim/neovim/pull/6366#issuecomment-289273001
"
" Revisit this when the PR is merged.
"}}}
if !has('gui_running') && has('vim_starting')
    " Why do you delay the 'lazyredraw' setting?{{{
    "
    " Start neovim like this:
    "
    "     $ nvim -Nu NONE +'set lz'
    "
    " Then press `:` immediately before Neovim has the time to draw the statusline.
    " The statusline prints this:
    "
    "     [No Name]^^^...^^^0,0-1^^^^^^^^^^All
    "              ├───────┘
    "              └ 92 times
    "
    " You must press `:` really fast:
    " position your left little finger on the left control key,
    " your right middle finger  on `m`,
    " and your right index finger on `:`.
    "
    " The issue is easier to reproduce with a custom config, because the startup
    " time increases  a little, which  gives you more time  to press `:`  at the
    " right moment.
    "
    " In Vim, when  you press `:` before the statusline  has been drawn, nothing
    " is printed.
    " This is less distracting than in Neovim, but it's still distracting to see
    " the statusline not drawn.
    "
    " That's why we don't set 'lz' too early:
    " so that the statusline  is correctly drawn even if we  press `:` very fast
    " after (Neo)Vim has been started.
    "}}}
    augroup delay_lazy_redraw
        au!
        au CursorHold,InsertEnter,CmdlineEnter * set lazyredraw
            \ | exe 'au! delay_lazy_redraw'
            \ | aug! delay_lazy_redraw
    augroup END
endif

" match (showmatch / matchtime) {{{2

" Show matching brackets.

set showmatch

" If I have the following html buffer:
"
"     foobar
"     foo
"
" then type {}, C-b to go back inside the curly brackets, the cursor stays where
" it is. I have to hit C-b twice (or wait half a second, &matchtime).
" The pb comes from the fact that the cursor jumps to the opening bracket for
" &matchtime. So, I set this option to 0.
"
" FIXME: matchtime bug
"
" Why does the pb appear only in html file?
" And why only with curly brackets, and not with round / square brackets?
" Edit:
" It seems to happen  in any file ...
" And it's not an issue with 'matchtime' but with 'showmatch'.

set matchtime=0

" matchpairs {{{2

augroup my_matchpairs
    au!
    au FileType * setl mps+=“:”,‘:’
augroup END

" modelines {{{2

" If 'modeline' is set, and the value of 'modelines' is greater than 0, then Vim
" will search inside  the first/last `&mls` lines of the  buffer and execute any
" `:set` commands it finds.

" This allows easy file-specific configuration.
" But I don't like that, for security reason.

set nomodeline
set modelines=0

" mouse {{{2

" Enable mouse usage (all modes)

set mouse=a

" nrformats {{{2

" when using the `c-a` and `c-x` commands, don't treat the numbers as octla
" E.g.:
"         `c-a` on 007  →  010  ✘
"         `c-a` on 007  →  008  ✔
set nrformats-=octal

" path {{{2

" Where should `:find` and `gf` look for a file?
set path=.,**
"        │ │
"        │ └─ and in the working directory recursively
"        └─ look in the directory of the current buffer, non-recursively

" Its default value was:
"
"     .,/usr/include,,
"     │ │            │
"     │ │            └─ empty value = working directory
"     │ └─ /usr/include directory
"     └─ directory of the current buffer

" scroll {{{2

" display at least 3 lines above/below the cursor
set scrolloff=3

" display at least 3 columns before/after the cursor
" when scrolling horizontally an unwrapped long line
set sidescrolloff=3

" minimum nr of columns to scroll horizontally
set sidescroll=5

" shortmess {{{2

" What does it do?{{{
"
" Prevent Vim  from printing the "ATTENTION" message when  an existing swap file
" is found.
"}}}
" If I edit a file in a second Vim instance, will the change be reflected in the first?{{{
"
" Yes, it should whenever CursorHold is fired.
" Because, in vim-term, we have:
"
"     • a custom autocmd executing `:checktime`
"
"          it will check whether the file has been changed
"          outside the current Vim instance
"
"     • set 'autoread'
"
"          it will automatically reload the file if the file has been changed
"          outside the current Vim instance
"}}}
" What happens if I edit a file in a 2nd Vim instance, get back to the 1st, and change it before `CursorHold`?{{{
"
" In theory, Vim should warn you:
"
"     WARNING: The file has been changed since reading it!!!
"     Do you really want to write to it (y/n)?
"
" If you  don't want to lose the  changes from the 2nd Vim  instance, you should
" answer no.
" Then, wait for CursorHold, or execute `:checktime`.
"
" In practice, there should be no such message, because, in vim-term, we have an
" autocmd listening to  `FocusGained` and `FocusLost` which reloads  the file if
" it has been changed outside the current Vim instance.
"}}}
" Why don't you enable the flag anymore?{{{
"
" I deal with the "ATTENTION" message with an autocmd listening to `SwapExists`.
"}}}
" set shm+=A

" enable all sort of abbreviations
set shm+=a

" Don't print |ins-completion-menu| messages.  For example:
"
"     - "-- XXX completion (YYY)"
"     - "match 1 of 2"
"     - "The only match"
"     - "Pattern not found"
"     - "Back at original"
set shm+=c

" don't print the file info when editing a file, as if `:silent` was used
set shm+=F

" When starting Vim without any argument, we enter into an unnamed buffer
" displaying a long message; hide this message.
set shm+=I

" don't print "search hit BOTTOM, continuing at TOP"
set shm+=s

" don't print "written" or "[w]" when writing a file
set shm+=W

" signcolumn {{{2

" We want a margin between the left of the screen and the text.
set signcolumn=yes

" OLD WAY:
" sign define dummy
" augroup dummy_sign
"     au!
"     au BufReadPost * exe 'sign place 9999 line=1 name=dummy buffer=' . bufnr('%')
" augroup END

" startofline {{{2

" Some commands move the cursor to the first non-blank of the line:
"
"         c-d, c-u, c-b, c-f, G, H, M, L, gg, :123, :+    (motions)
"         dd, <<, >>                                      (operators)
"         c-^, :bnext, :bprevious
"
" I prefer the cursor to stay on the same column as before.
set nostartofline

" switchbuf {{{2
"         How to configure 'swb'?{{{

" You give it a list of values. Example:
"
"     set switchbuf=useopen,usetab
"}}}
"         What does it do?{{{

" If you  try to open a  split to display  a loaded buffer with  `:sbuffer`, Vim
" will first check  whether the buffer is  already displayed in a  window of the
" current tab page (`useopen`), or in another tab page (`usetab`).
" And if  it finds one,  instead of  creating a split,  it will simply  give the
" focus to this window.
"}}}
"         Which commands honor 'swb'?{{{

" |quickfix| commands, when jumping to errors (`:cc`, `:cn`, `cp`, etc.).
" All buffer related split commands: `:sbuffer`, `:sbnext`, `:sbrewind`…
"}}}
"         Are there pitfalls?{{{

" When we move in the qfl quickly, the focus can change from a window to another
" and it's distracting.
" Besides, once the focus has changed, if  we advance further in the qf list, it
" can make us lose the buffer which was opened in the window.
"
" When we press `C-w CR` on an entry of  the qfl, and the latter is present in a
" buffer which is already displayed somewhere else, Vim opens a split displaying
" an unnamed buffer.
"
" Why?
" Because FIRST it splits the window,  THEN checks whether the buffer to display
" is already displayed  somewhere else. When it finds one, it  changes the focus
" as expected, but it doesn't close the  split with the unnamed buffer (which is
" unexpected).
"
" MWE:
"     vim -Nu NONE -c 'set swb+=useopen' ~/.bashrc
"     :vim /./ % | copen
"     C-w CR
"}}}
"         Are there workarounds?{{{

" You could temporarily reset 'swb' while:
"
"         • the qf window is opened; in a qf filetype plugin:
"
"                   if !exists('s:swb_save')
"                       let s:swb_save = &swb
"                       set swb=
"                   endif
"
"                   au BufWinLeave <buffer> let &swb = get(s:, 'swb_save', &swb) | unlet! s:swb_save
"
"         • when you execute some commands / mappings
"
"           you would need to create wrapper around default normal commands
"           with a try conditional, and a finally clause, to empty 'swb'
"           and/or,
"           you would need to install an autocmd listening to CmdlineLeave,
"           to set 'swb' only when you use some Ex commands
"
" You could install unimpaired-like mappings to toggle the value of 'swb'.
"}}}
"         Why don't we set it?{{{
"
"     • Too many issues.
"     • I don't need it atm.
"     • To give the focus to an already displayed buffer, there are alternatives:
"
"           :FzWindows  (<space>fw)
"           :drop       (:drop ~/**/*some_file)
"}}}
" synmaxcol {{{2

" don't syntax-highlight long lines
set synmaxcol=250
"             │
"             └─ weight in bytes
"                any character prefixed by a string heavier than that
"                will NOT be syntax highlighted

" t_ut {{{2

" We don't really need this atm.
" It's only useful if you start Vim inside `xterm-kitty` (and outside tmux).
if &term =~# '-256color$\|^xterm-kitty$' && has('vim_starting')
  " Disable Background Color  Erase (BCE) so that color  schemes render properly
  " when inside 256-color tmux and GNU screen.
  " See: http://snk.tuxfamily.org/log/vim-256color-bce.html
  set t_ut=
endif

" tags {{{2

" When searching the tags file, ignore the case unless an upper case letter is used.
set tagcase=smart

" What's the default value? {{{
"
"         ./tags,./TAGS,tags,TAGS
"
" Explanation:
"
"        ┌────────┬──────────────────────────────────────────────────────────────────┐
"        │ ./tags │ file in the directory of the CURRENT FILE and whose name is tags │
"        ├────────┼──────────────────────────────────────────────────────────────────┤
"        │ tags   │ file in the WORKING DIRECTORY             and whose name is tags │
"        └────────┴──────────────────────────────────────────────────────────────────┘
"}}}
" What's the effect of this new value?{{{
"
" We define a new value by adding a semicolon after `./tags`.
" `;` tells Vim to look UP recursively.
" It's the opposite of `**` which looks DOWN recursively.
" You could also include the value `tags;`:
"
"         set tags=./tags;,tags;
"
" Explanation:
"
"       ┌─────────┬──────────────────────────────────────────────────────────────┐
"       │ ./tags; │ file in the directory of the CURRENT FILE, then              │
"       │         │ in its parent directory, then in the parent of the parent    │
"       │         │ and so on, recursively                                       │
"       ├─────────┼──────────────────────────────────────────────────────────────┤
"       │ tags;   │ file in the WORKING DIRECTORY, then in its parent directory, │
"       │         │ then in the parent of the parent and so on, recursively      │
"       └─────────┴──────────────────────────────────────────────────────────────┘
"
" The value of 'tags' influence commands such as `:tj` and `:ltag`.
" But also, tag completion in insert mode.
" The completion function  invoked by `i_^x^]` looks for candidates  in the tags
" files whose path are stored in the value of 'tags'.
"}}}
set tags=./tags;
" Why could a command such as `:tj` or `:ltag` include some irrelevant tags? {{{
"
" It's probably due to the combination of two factors:
"
"         • vim-gutentags is enabled
"
"         • you have a tags file in a big directory containing many different
"           projects
"
"           For example,  you may have  executed `$ ctags  -R` by accident  in a
"           wrong directory, such as `~/.vim` or `~/.vim/plugged`.
"
"           Or maybe it  was executed by `vim-gutentags`  because you accidently
"           created  a git  repo (via  something like  `git {add|commit|push}`),
"           where you shouldn't have.
"
" `vim-gutentags` appends the global value  of 'tags' to the buffer-local value,
" for buffers inside a git repo.
"
" So, if `./tags;` and/or `tags;` is  inside the global value of 'tags', because
" of `vim-gutentags`, it will also be in the local value.
"
" And thus, when  you'll be working on a project,  like the `vim-session` plugin
" for example, here's the kind of local value that 'tags' will contain:
"
"         tags=~/.vim/plugged/vim-session/tags,./tags;,tags;
"                                                    ^     ^
"  Because  of  the semicolons,  Vim  may  include a  wrong  tags  file such  as
" `~/.vim/tags`. If that happens, you'll end up with way too many tags.
"}}}
" What to do if that happens? {{{
"
" 1. Try  to configure  `vim-gutentags` and  prevent it  from including  the
"    global value of 'tags' inside the local one.
"
" 2. Remove wrong tags files (`$ rm`), and make sure there's no `.git/`
"    directory outside a valid  repository.
"    Otherwise, `vim-gutentags` may recreate a tags file.
"}}}

" In our vimrc file, we want the ability to jump from the call of a function
" defined in `myfuncs.vim`, to its definition, with `C-]`.
augroup tags_vimrc
    au!
    au BufReadPost $HOME/.vim/vimrc setl tags=$HOME/.vim/autoload/tags
    " update the tags file whenever we write `myfuncs.vim`
    exe 'au BufWritePost '.resolve($HOME.'/.vim/autoload/myfuncs.vim')
    \ . ' sil! !ctags -f $HOME/.vim/autoload/tags $HOME/.vim/autoload/myfuncs.vim'

    au! BufWritePost .zshrc sil call system('source '.expand('%:p:S'))
augroup END

" temporary files:  undo, swap, backup {{{2

" FIXME:
" Review all this section.
" Finish implementing proper backup.
" Read files in `backup` session.
"
" And read this:
"
"         https://www.zachpfeffer.com/single-post/Practice-Recovering-a-File-in-Vim
"
" TODO:
" Read this:
" https://vi.stackexchange.com/a/53/13370
" Add a cron job to delete temp files when they've been changed for a long time
" (3 months?).


" In neovim, there's no need to create directories for backup, undo, swap.
" The default value of the relevant options are set so that all the temp files
" are created inside `~/.local/share/nvim`.


if !isdirectory($HOME.'/.vim')
    call mkdir($HOME.'/.vim', '', 0770)
endif

" 'directory' ('dir') est une option dont la valeur est une suite de chemins
" séparés par des virgules.
" Quand on commence à éditer le fichier bar, et que Vim doit créer un fichier
" d'échange pour ce dernier (.bar.swp), il utilise le 1er dossier présent dans
" l'option 'dir' et dans lequel il peut écrire (existe + droits suffisants).
"
" La valeur par défaut de 'dir' est:
"         .,~/tmp,/var/tmp,/tmp
"
" Ça signifie que Vim crée le fichier d'échange dans le même dossier que bar.
" Le problème est que ça pollue le système de fichiers avec des fichiers
" d'échange un peu partout.
"
" On veut les confiner dans un dossier qui leur sera dédié, pex:
"         ~/.vim/tmp/swap
" Pour ce faire, on ajoute au début (^=) de 'dir' la valeur:
"         "$HOME/.vim/tmp/swap//"
"
" Pk un double slash à la fin ?
" Par défaut, le fichier d'échange créé s'appellera: .bar.swp
" Ceci peut poser pb, si on édite plusieurs fichiers bar dans des dossiers
" différents. Leurs fichiers d'échange auront tous le même nom.
" Le double backslash demande à Vim d'utiliser le chemin vers bar pour créer
" un nom de fichier d'échange unique:
" %path%to%.bar.swp
" Au passage, on remarque que les slashs séparant les dossiers du chemin vers
" bar sont remplacés par des %.
set directory=$HOME/.vim/tmp/swap//

" make sure the swap directory exists
if !isdirectory(&directory)
    call mkdir(&directory, 'p', 0700)
endif


" enable persistent undo
set undofile

" choose location of undo files
set undodir=$HOME/.vim/tmp/undo

" make sure the undo directory exists
if !isdirectory(&undodir)
    call mkdir(&undodir, 'p', 0700)
endif


" Why don't we enable 'backup'?{{{
"
" Because  of  a bug,  'backupdir'  doesn't  support  the correct  double  slash
" filename expansion: the  name of a backup  file contains only the  name of the
" original file, not its whole path. If you  edit 2 files with the same name, in
" 2 different directories, only the last one will have a backup (overwrite).
" See:
"     https://code.google.com/p/vim/issues/detail?id=179
"     https://stackoverflow.com/a/38479550/8243465
"}}}
set nobackup
" Future Workaround:{{{

" This is the workaround for the backup filename expansion problem.
augroup my_backup
    au!
    " au BufWritePre * call s:save_backups()
augroup END

fu! s:save_backups() abort
    for pat in split(&backupskip, ',')
        if expand('%:p') =~# pat | return | endif
    endfor

    " If this is a newly created file, don't try to create a backup
    if !filereadable(expand('%:p')) | return | endif

    for backupdir in split(&backupdir, ',')
        if s:save_backup(backupdir)
            break
        endif
    endfor
endfu

fu! s:save_backup(backupdir) abort
    let filename = expand('%:p')
    let backup = a:backupdir =~# '//$'
             \ ?     escape(substitute(filename, '/', '%', 'g').&backupext, '%')
             \ :     escape(expand('%').&backupext, '%')
    let backup_path = a:backupdir.backup
    sil! exe '!cp '.resolve(filename).' '.backup_path
    if v:shell_error
        " reset `v:shell_error`
        call system('')
        return 1
    endif
endfu
"}}}

" Vim peut créer parfois un fichier de backup qui correspond à une copie du
" fichier tq qu'il était avant qu'on ne l'édite.
" La création d'un fichier de backup est déterminée par plusieurs options
" (dont 'backup' et 'writebackup') et expliquée dans l'aide: :h backup-table
"
" Par défaut, le chemin du backup du fichier bar est:
"         ./.bar~
" L'emplacement des fichiers de backup est déterminé par l'option 'backupdir'
" / 'bdir'.
" On veut qu'ils soient tous confinés dans ~/.vim/tmp/backup
set backupdir=~/.vim/tmp/backup//

" make sure the backup directory exists
if !isdirectory(&backupdir)
    call mkdir(&backupdir, 'p', 0700)
endif

" termguicolors {{{2

" Enable true color when supported.

" My current version of urxvt and xfce4-terminal don't support true color.
"
" FIXME:
" We should use a whitelist, not a blacklist.
"
" Atm,  the  only  terminals  which  I  can  install  and  support  true  color,
" are  Konsole  and  gnome-terminal. I  know  how to  detect  Konsole,  but  not
" gnome-terminal (there's no environment variable we could inspect).
if $COLORTERM isnot# 'rxvt-xpm' && $COLORTERM isnot# 'xfce4-terminal'
    set termguicolors
    if !has('nvim')
        " In Vim, if `$TERM` is not  'xterm', Vim won't automatically set 't_8f'
        " nor 't_8b'.  We need to do it manually. See: :h xterm-true-color.
        let &t_8f = "\e[38;2;%lu;%lu;%lum"
        let &t_8b = "\e[48;2;%lu;%lu;%lum"
    endif
endif

" thesaurus {{{2

" It is possible to replace the word before the cursor by a synonym.
" To do that, we must hit in insert mode C-x C-t.
" This should make the popup menu appear.
" The menu should be populated with various synonyms for the word.
" The completion function looks for synonyms in all the files whose path
" is present in the option 'thesaurus'.
" Each line of the file must contain a group of synonyms separated by
" a character which is not in 'isk' (space or comma for example).
"
" We can download such a file at the following url:
"         https://archive.org/stream/mobythesauruslis03202gut/mthesaur.txt
"
" Otherwise, search the following query on google:
"         mthesaur.txt filetype:txt

set thesaurus+=$HOME/.vim/tools/mthesaur.txt

" timeout {{{2

" enable a timeout for mappings
set timeout

" same thing for keycodes
set ttimeout

" set the timeout for mappings to 3s
set timeoutlen=3000

" ... and 6 ms for keycodes.
" Previously we used 50ms, but 6 is the max value to prevent this error:
"
"       1. insert sth wrong
"       2. hit escape
"       3. hit u (undo)    →    M-u: uppercase next word
set ttimeoutlen=6
" the lower the value, the less risk there is for keys manually typed to be
" interpreted as a keycode
"
" E.g.:
" When Vim receives `Esc` then `d`, it has to decide:
"
" does it mean “escape to normal mode“, then “hit the `d` operator“,
" or does it mean `M-d` (delete the next word)?
" If `d` came less than `&ttimeoutlen` ms after `Esc`, Vim will assume it's
" the keycode for `M-d`. Otherwise, it will think we've just manually hit
" `Esc` then `d`.


" Si on a créé un mapping qui à la séquence de touches (keycodes) a et b,
" associe une action, qd on appuiera sur a, Vim attendra un certain temps pour
" nous laisser taper b. Au-delà si l'option 'timeout' est activée, Vim
" exécutera l'action associée à la touche a.
" Cette durée est définie par l'option 'timeoutlen' qui par défaut vaut 1000.
"
" De la même façon, les touches de contrôle produisent souvent une séquence
" d'échappement / de keycodes.
" Pex, F1 produit escape + O + P, on peut vérifier via la commande shell: $ xxd p
"
" Ainsi quand on tape sur escape puis sur O, Vim attend un certain temps avant
" d'ouvrir une nouvelle ligne au-dessus de l'actuelle, pour laisser le temps
" au keycode associé à P d'arriver.
"
" Cette durée est définie par l'option 'ttimeoutlen' qui par défaut vaut -1,
" ce qui signifie qu'elle prend la même valeur que 'timeoutlen', à savoir 1000.
"
" Cette valeur pose pb car elle introduit un délai d'une seconde quand on
" appuie sur escape puis O. Pour résoudre ce pb, on configure 'timeoutlen' à
" 3000 (3s), pour se laisser du temps quand on tape nos mappings, et on
" configure 'ttimeoutlen' à 100 pour raccourcir le délai après un escape + O.
"
" Ça ne devrait pas poser de pb puisqu'aucun de nos mappings ne commence
" par cette séquence de keycodes, par contre il faudra faire attention.
" Dans une session Vim qui tourne sur une machine distante, le lag ou la charge
" de la machine pourrait nous empêcher d'utiliser correctement des touches de
" contrôle (F1, F2, flèches …).
" En effet, 100ms pourrait s'avérer insuffisant pour que l'un des keycodes qui
" compose la séquence arrive à temps.

" ttymouse {{{2

" Pour redimensionner les viewports à la souris, il faut que 'ttymouse' ait pour
" valeur `xterm2` ou `sgr`. Par défaut, sa valeur dépend de `$TERM`.

" Atm, dans xfce4-terminal et dans guake :
"     TERM=xterm ⇒ ttym=sgr
"
" Et dans Tmux :
"     TERM=screen ⇒ ttym=xterm

" Résultat, le redimensionnement des viewports à la souris fonctionne dans Vim
" qd il tourne ds xfce4-terminal et ds guake mais pas dans Tmux.

" Pour résoudre ce pb, le code qui suit vérifie la valeur de l'option term, et
" si elle débute par screen il donne la valeur xterm2 à ttymouse.

" Source:
" http://superuser.com/a/550482

" FIXME:
" Is it really still needed?
" It seems we can resize viewports without.
"
" However:
"     1. resizing is brittle/wonky no matter what
"     2. `xterm2` might be a better value than default `xterm`:
"
"            “This works much faster and more precise.”
"
"     3. why do we sometimes get into visual mode when we try to resize?
"
"        ┌ nvim doesn't have this issue, and 'ttym' has been removed from it
"        │
if !has('nvim') && &term =~# '^\%(screen\|tmux\)'
    set ttym=xterm2
endif

" updatetime {{{2

"              ┌─ our current chosen value
"              │  if you change it, do the same in:
"              │
"              │          ~/.vim/plugged/vim-readline/autoload/readline.vim
"              │
"              │  function:
"              │
"              │          `readline#do_not_break_macro_replay()`
"              │
set updatetime=2000

" viminfo {{{2

" Useful to save `g:MY_LAST_QFL`.
set viminfo+=!

" virtualedit {{{2

" In visual-block mode, let us move the cursor on a cell where there's no character:
"
"         • in the middle of a tab
"         • beyond the last char on a line
"
" Useful to select a rectangle out of irregular (different lengths) lines.
set virtualedit=block

" wildignore(case) {{{2

" Why tweaking `'wig'`?{{{
"
" Some files can't be edited by Vim.
" Or they shouldn't.
"
" We never want to see them:
"
"         • in a dirvish listing
"         • on the command-line after a tab completion
"         • in the output of `expand()`, `glob()`, `globpath()`
"}}}

set wig&vim
" lock files (example: ~/.gksu.lock)
set wig+=*.lock

" vim temporary files
set wig+=*.bak,*.swo,*.swp,*~

" latex temporary files
set wig+=*.aux,*.fdb_latexmk,*.fls,*/auxiliary/*,*/build/*

" password databases
set wig+=*.kdb,*.kdbx

" media files (music, pictures, ...)
set wig+=*.gif,*.jpeg,*.jpg,*.mp3,*.mp4,*.png

" python objects/cache
set wig+=*.pyc,*/__pycache__/*
" Why not `*/__pycache__/**/*` ?{{{
"
" No need to. The depth of a python cache is 1.
" See the contents of `~/.vim/pythonx/__pycache__/`.
"}}}

" undo files
"
"                          ┌─ `*` can match any string/path
"                          │  (including as many `/` as you want, but not a dot)
"                          │
let &wig .= ','.&undodir.'/*'
let &wig .= ','.&undodir.'/*.*'
let &wig .= ','.&undodir.'/*.*.*,'
"                          │
"                          └─ `*` can't match a dot, and the path of an
"                              undofile often contains 1 or 2 dots

" Why don't you ignore archives?{{{
"
"     set wig+=*[^0-9].gz,*.rar,*.tar.*,*.zip
"               ├────┘
"               └ don't ignore man pages in `/usr/share/man/man1/`
"
" Some system files are stored in archives, logs for example.
" When we inspect the contents of a directory in dirvish, I want to see them
" (whether I can open them or not).
" Besides, usually, they can be read in Vim.
" Example:
"
"     /usr/share/keymaps/i386/azerty/azerty.kmap.gz
"
"}}}

set wig+=tags

" A file in a `.git/` directory.
set wig+=*/.git/*
" If you see a `.git/` directory in dirvish, before tweaking this option, have a look at `fex#format_entries()`:{{{
"
"         ~/.vim/plugged/vim-fex/autoload/fex.vim:22
"}}}
" If this setting causes an issue, read this:{{{
"
"     https://www.reddit.com/r/vim/comments/626no2/vim_without_nerd_tree_or_ctrlp/dfkbm97/
"     https://github.com/tpope/vim-fugitive/issues/121#issuecomment-38720847
    "}}}

" Tab completion should be case-insensitive.
" If we type `:e bar Tab`, and a file `Bar` exists, we should get:
"
"         :e Bar
set wildignorecase

" wildmenu  wildchar(m) {{{2

" enable wildmenu
set wildmenu

" The value of 'wildmode' is a comma-separated list of (up to 4) parts.
" Each part defines what happens when we press Tab (&wc) the 1st/2nd/3rd/4th time.
set wildmode=full

" What's 'wc'?{{{
"
" The  key to  press for  Vim to  start a  wildcard expansion  (which opens  the
" wildmenu).
"}}}
" What's 'wcm'?{{{
"
" The key to press for Vim to start a wildcard expansion, from:
"
"     • the recording of a macro
"     • the rhs of a mapping
"}}}
" What does the value `26` stand for?{{{
"
"     C-z
"}}}
" What does `set wcm=26` imply?{{{
"
" When you want  Vim to start a wildcard  expansion, in the rhs of  a mapping or
" while recording a macro, you'll have to write/press `C-z`, instead of Tab.
"
" If you write/press Tab, the mapping/macro  won't work as expected, because the
" Tab  characters  they  contain  will be  interpreted  literally  (no  wildcard
" expansion).
"}}}
" Is there an alternative value?{{{
"
" Yes, you could write:
"
"     set wcm=9
"}}}
" Would it be better?{{{
"
" Yes, because  you could write/press Tab  in your mappings/macros, to  make Vim
" start a wildcard expansion, exactly like you would the rest of the time.
"}}}
" Then, why don't you use it?{{{
"
" Suppose your macro contains Tab characters.
" While on the command-line, *any* one  of them will start a wildcard expansion.
" It may have unexpected results.
" For a real example, run:
"
"     :so $VIMRUNTIME/syntax/hitest.vim
"
" (Taken from `:h hitest.vim`)
" It will raise `E475`, and the dumped highlight groups won't be highlighted.
" This is because of these commands:
"
"     % yank a
"     @a
"
" They run the contents of the buffer as Ex commands (`@a` ⇔ `:@a`).
" The buffer contains Tab characters.
" They all make Vim start a wildcard expansion, but in the buffer they were just
" used to separate some texts.
" They were not supposed to expand anything.
"}}}
set wc=9
set wcm=26

" winaltkeys {{{2

" disable `alt + {char}` key bindings used in gVim to access some menu entries
" They could shadow some of our custom mappings using the meta modifier key.

set winaltkeys=no

" word / line wrapping {{{2

" don't wrap long lines by default
set nowrap

" display a character in front of a wrapped line
set showbreak=↪

" a soft-wrapped line will be displayed with the same level of indentation as
" the first one
set breakindent

" soft-wrap long lines at a character in 'breakat' (punctuation, math
" operators, tab, @) rather than at the last character that fits on the screen
set linebreak

" allow to soft-wrap after ) ] }
set breakat+=)]}

" allow `h` and `l` motion to move across lines
set whichwrap=h,l
" }}}1
" MAPPINGS {{{1
" NEW {{{2

fu! s:remember_new_mappings(some_lhs) abort
    for lhs in a:some_lhs
        exe 'nno  <silent>  '.lhs[0].'  :<c-u>call <sid>reminder_new_mapping('.string(lhs[1]).')<cr>'
    endfor
endfu

fu! s:reminder_new_mapping(new_lhs) abort
    echohl WarningMsg
    echo 'Press '.a:new_lhs.'    [3 times to make it stick faster]'
    echohl NONE
endfu

call s:remember_new_mappings([
    \ ['-e', '!e'],
    \ ['g?', '!m'],
    \ ['zs', '!s'],
    \ ])

" FREE {{{2

" A key can be used as a prefix iff one of these conditions is true:
"
"           • it's useless for you (ex: U)
"           • it's used as a prefix by default (ex: Z)
"
" This means that you can NOT use `!` as a good prefix.
" Not useless, and not a prefix by default, so it would lead to too many issues.
"
" Still, you may  occasionally use a key sequence `!{char}`.   But do NOT infer,
" that `!` can be  used as a prefix associated with a meaning,  to build a whole
" family of mappings.
" There would be  times when it wouldn't  work, and then you would  have to build
" mappings which do not  follow the same scheme (shell command  → !). It would
" bring inconsistencies.


" When you find a new prefix, if it has a default meaning, disable it:
"
"         nno <pfx> <nop>
"
" Do NOT do it here from the vimrc.
" Do it from `~/.vim/after/plugin/disable.vim`: it's more reliable.
" See the first comment there for an explanation.


"    • C-q is not used in insert mode (except for exiting a completion menu)
"      we could supercharge  it to do something  else when we aren't  in a completion
"      menu
"
"    • C-z has been disabled in visual mode
"
"      in insert mode, we use it as an “easier-to-type“ C-x C-p
"
"    • gh, gH, g C-h, gl, v_C-g
"
"    • @# has been mapped to g8, so g8 is free
"
"    • gy, gz
"
"    • PageUp PageDown
"
"    • S-Tab (not Tab, because it would also affect C-i used for moving
"      inside the jumplist)
"
"    • C-_
"
"    • search for 'not used' in the window opened by `:viu`

" LEADER {{{2

" If we install a  plugin which defines mappings using the  leader key, we don't
" want any clash with one of  our existing mapping. So, we assign to `mapleader`
" a garbage key. Why `S-F13`? See the configuration of UltiSnips.

" As an  example, this strategy is  useful to avoid the  `unicode.vim` plugin to
" introduce lag  when we hit  `<space>u`. Indeed this plugin installs  a mapping
" whose lhs is `<leader>un` (:h <plug>(UnicodeSwapCompleteName)).

" Other benefit:
"
"       :no <leader>    →    display all mappings installed by third-party plugins
"                            in normal / visual / operator-pending mode

let mapleader = "\<s-f13>"

" same thing for localleader
let maplocalleader = "\<s-f14>"

" COMMAND-LINE {{{2
" C-r C-h       fuzzy search history {{{3

" Why not C-r C-r?{{{
"
" Already taken (:h c^r^r).
"}}}
" Why not C-r C-r C-r ?{{{
"
" Would cause a timeout when we press C-r C-r to insert a register literally.
"}}}
cno  <expr>  <c-r><c-h>  getcmdtype() =~ '[/?]' ? '<Esc>:FzHistory/<cr>' : 'FzHistory:<cr>'

" C-r C-l       insert current line {{{3

cno  <c-r><c-l>  <c-r><c-r>=substitute(getline('.'), '^\s*"\=\s*:\=', '', '')<cr>

" }}}2
" INSERT {{{2

" Most of these mappings take care of not breaking undo sequence (C-g U).
" It means we can repeat an edition with the dot command, even if we use them.
" If you add another mapping, try to not break undo sequence. Thanks.

" C-g             (prefix) {{{3
" C-h {{{4
"
" Sometimes, we want to do this:{{{
"
"        ┌ exceeding amount of whitespace
" ┌──────┤
"         some text
"     ↓
" some text
"│
"└─ compacted whitespace
"}}}
" Also, sometimes we want to do this:{{{
"
"       ┌ exceeding amount of whitespace
" ┌─────┤
"        " some text
"     ↓
" " some text
" │
" └─ compacted whitespace
"}}}

" This  mapping  tries  to  perform  both edits,  depending  on  the  amount  of
" whitespace between the comment leader and the rest of the text.
ino  <silent>  <c-g><c-h>  <c-r>=<sid>compact_whitespace()<cr>

fu! s:compact_whitespace() abort
    if empty(&l:cms)
        return ''
    endif
    let cml = '\V'.matchstr(split(&l:cms, '%s')[0], '\S*').'\m'

    if getline('.') =~# cml.'\s\s' && &ft isnot# 'markdown'
        let pat = '\s*'.cml.'\zs\s\+'
        let rep = ' '
    else
        let pat = '^\s*\ze\S'
        let rep = ''
    endif

    call setline('.',
    \            substitute(getline('.'), pat, rep, ''))
    return ''
endfu

" }}}3
" C-m             more granular undo {{{3

" When we write a paragraph then hit `u` to undo, Vim removes the whole
" paragraph. I want it to remove only the last line. Then the one before, etc.
" To get a more granular undo, we need to hit `c-g u` every time we hit Enter.
" This will break the undo block into smaller blocks.
" Every time we hit `c-g u`, the current state of the buffer is accessible
" with `u`/`c-r`.
"
" :h i_ctrl-g_u

fu! s:c_m() abort
    " If the completion menu is active, we want `Enter` to validate the item
    " currently selected.
    if pumvisible()
        return "\<c-y>"
    endif

    " If we hit Enter on a commented line with nothing in it, we want to
    " delete everything.
    let cml = get(split(&l:cms, '%s'), 0, '')

    if empty(cml)
        return "\<c-g>u\<cr>"
    endif

    if getline('.') =~ '^\s*\V'.escape(cml, '\').'\v\s*$'
        " We can't invoke `setline()` immediately, because of `<expr>`.
        call timer_start(0, { -> setline('.', '') })
        return ''

        " OLD:
        " Not reliable, because sometimes BS deletes more than one char.
        " Happens after a sequence of whitespace.
        "
        "         return "0\<c-d>".repeat("\<BS>", strchars(cml) + 1)
    endif

    return "\<c-g>u\<cr>"
endfu

ino  <expr>  <c-m>  <sid>c_m()

" C-q             exit completion menu {{{3

" Because  of a  mapping in  `vim-readline`, we've  lost the  ability to  exit a
" completion menu. Restore it on `c-q`.

ino  <c-q>  <c-e>

" C-r  X          output of last eX command  {{{3

" insert output of last eX command
ino  <expr><silent>  <c-r>X  <sid>output_last_ex_command()

fu! s:output_last_ex_command() abort
    let paste_save = &paste
    " enable 'paste' so that Vim  doesn't automatically add indentation when the
    " output has multiple lines
    set paste
    call timer_start(0, {-> execute('set '.(paste_save ? '' : 'no').'paste')})
    try
        " We remove the first newline, so that we can insert the output of a command
        " inline, and not on the next line.
        return substitute(execute(histget(':')),'\n','','')
    catch
        " If the last command failed and produced an error, it will fail again.
        " But we still want something to be inserted: the error message(s).
        let messages = reverse(split(execute('messages'), '\n'))
        let idx = match(messages, '^E\d\+')
        call remove(messages, idx+1, -1)
        return join(reverse(messages), "\n")
    endtry
endfu

" C-s             save {{{3

" I often type C-s in insert mode to save, and miss/forget the escape
" to get back in normal mode first.
" Alternative:
"     imap  <c-s>  <esc><c-s>
ino  <silent>  <c-s>  <esc>:sil update<cr>

" M-a  M-e {{{3

ino  <silent>  <m-a>  <c-r>=<sid>move_by_sentence(0)<cr>
ino  <silent>  <m-e>  <c-r>=<sid>move_by_sentence(1)<cr>

fu! s:move_by_sentence(is_fwd) abort
    if a:is_fwd
        norm! (
    else
        norm! )
    endif
    return ''
endfu

" \ {{{3

ino  <silent>  <bslash>  <c-r>=<sid>indent_before_backslash()<cr>

fu! s:indent_before_backslash() abort
    if &ft isnot# 'vim'
        return '\'
    endif

    let has_text_before_cursor = matchstr(getline('.'), '.*\%'.col('.').'c') =~# '\S'
    let prev_indent            = matchstr(getline(line('.')-1), '^\s*\\')
    let next_indent            = matchstr(getline(line('.')+1), '^\s*\\')

    if   has_text_before_cursor
    \ || empty(prev_indent) && empty(next_indent)
        return '\'
    endif

    let current_indent = empty(next_indent)
        \ ?     prev_indent
        \ :     next_indent

    "       ┌ if the cursor is in the middle of the indentation,
    "       │ `0 C-d` removes all whitespace before the cursor AND after
    "       ├─────┐
    return "0\<c-d>".current_indent.' '
    "                │               │
    "                │               └ to avoid that `\?` or `\:`
    "                │                 which can cause a bug when Vim parses
    "                │                 the ternary operator `?:` in a lambda
    "                │
    "                └ includes a backslash at the end
endfu

" }}}2
" NORMAL {{{2
" SPC                 (prefix) {{{3
" SPC                           za {{{4

nno  <space><space>  za
xno  <space><space>  za

" . {{{4

" `.` repeats the last edit.
" But if we want to repeat it on the same text which we've just changed (`@"`),
" we have to look for it manually.
"
" Solution:
" install a mapping which:
"
"         1. puts the last changed text in the search register
"         2. cuts its next occurrence
"         3. inserts the previously inserted text and stop insert

" After `<space>.`  has been pressed,  you can repeat  with `.`, <space>  is not
" needed anymore.
nno  <expr><silent>  <space>.  <sid>repeat_last_edit_on_last_text()

fu! s:repeat_last_edit_on_last_text() abort
    " put the last changed text inside the search register, so that we can refer
    " to it with the text-object `gn`

    "                                      ┌─ last changed text
    "                                      │
    let last_text = '\V'.substitute(escape(@", '\'), '\n', '\\n', 'g')
    " The last changed text may contain newlines, but if it ENDs with one, we
    " usually don't want it.
    let last_text = substitute(last_text, '\\n$', '', '')
    let @/ = last_text

    set hls
    "               ┌ insert the previously inserted text and stop insert
    "          ┌────┤
    return "cgn\<c-@>"
endfu

" aa    ac    ad    al    an    arglist {{{4

nno  <silent>  <space>aa  :<c-u>argedit %<cr>

" load Current argument
nno  <silent>  <space>ac  :<c-u>argument<cr>

" Delete current argument
nno  <silent>  <space>ad  :<c-u>.argdelete<cr>

" create Local arglist (by copying the global one)
nno  <silent>  <space>al  :<c-u>arglocal<cr>

" start New arglist
"
" Define a new argument list, which is local to the
" current window, and containing only the current buffer.
" This causes the buffer to be reloaded.
" Add a bang to `:arglocal` to discard unsaved changes in the current buffer.
nno  <silent>  <space>an  :<c-u>arglocal %<cr>

" f                             fuzzy search {{{4

" Mnemonic:
" SPC fl  = l for :ls (listing)
" SPC fr  = most Recently used (files and buffers)
" SPC fgc = Git Changed files

" `:FzSnippets` only returns snippets whose tab trigger contains the text
" before the cursor.

fu! s:fuzzy_mappings() abort

    let fuzzy_mappings = {
                         \ 'a' : 'Ag',
                         \ 'bt': 'BTags',
                         \ 'f' : 'Files',
                         \ 'gf': 'GFiles',
                         \ 'gc': 'GFiles?',
                         \ 'ht': 'Helptags',
                         \ 'l' : 'Buffers',
                         \ 'm' : 'Maps',
                         \ 'M' : 'Marks',
                         \ 'r' : 'History',
                         \ 's' : 'Snippets',
                         \ 't' : 'Tags',
                         \ 'w' : 'Windows',
                         \ }

    for [l:char, cmd] in items(fuzzy_mappings)
        exe 'nno  <space>f'.l:char.'  :<c-u>Fz'.cmd.'<cr>'
    endfor

    nno  <silent>  <space>fF  :<c-u>FZF $HOME<cr>
endfu

call s:fuzzy_mappings()

" To use `:FzBCommits` and `:FzCommits`, we first need to be in the working
" tree of the repo:
"
"     - on which the current file belong
"
"     - in which we are interested;
"       let's say, again, the one where the current file belong

nno  <silent>  <space>fbc  :<c-u>lcd <c-r>=expand('%:p:h')<cr> <bar> FzBCommits<cr>
nno  <silent>  <space>fc   :<c-u>lcd <c-r>=expand('%:p:h')<cr> <bar> FzCommits<cr>

" Fuzzy search mappings from insert / visual / operator-pending mode.

" C-g is often used as a prefix to create mappings in insert mode.
" So, to maintain some consistency, we use it to create a fuzzy search mapping
" in insert mode.
"
" We can safely do it without overriding / shadowing and existing mapping,
" because it's not present in:
"
"     :h i_^g C-d
"     :echo map(taglist('^i_CTRL-G'), { i,v -> v.name })
"
" There is no default equivalent for visual mode, but we often use `m` for
" visual mode mappings. So, here again, we'll use `m` as a prefix.

imap  <c-g>m  <plug>(fzf-maps-i)
xmap  mm      <plug>(fzf-maps-x)
omap  m       <plug>(fzf-maps-o)

" s S                           saiw  saiW{{{4

nmap  <space>s  saiw
nmap  <space>S  saiW

" t                             new tab page {{{4

nno  <silent>  <space>t  :<c-u>exe (v:count ? v:count.'tabnew' : 'tabnew')<cr>
"}}}3
" [    ]              (prefix) {{{3
" ]kj                           various alignments {{{4

"  [k [j align the beginning of the current line with the one of the
"  previous/next line
"
"  ]k ]j align the end of the current line with the one of the
"  previous/next line

nno  <silent>  [k  :<c-u>call myfuncs#align_with_beginning_save_dir(-1)<bar>set opfunc=myfuncs#align_with_beginning<cr>g@l
nno  <silent>  [j  :<c-u>call myfuncs#align_with_beginning_save_dir(1)<bar>set opfunc=myfuncs#align_with_beginning<cr>g@l
nno  <silent>  ]k  :<c-u>call myfuncs#align_with_end_save_dir(-1)<bar>set opfunc=myfuncs#align_with_end<cr>g@l
nno  <silent>  ]j  :<c-u>call myfuncs#align_with_end_save_dir(1)<bar>set opfunc=myfuncs#align_with_end<cr>g@l

" }}}3
" \                   (prefix) {{{3
" \b            select current box {{{4

" select the current box, so that we can move it quickly with `vim-schlepp`
nno  <silent>  \b  :<c-u>call myfuncs#block_select_box()<cr>

" \f            find digraph {{{4

" We've mapped `f` to a function of `vim-sneak`.
" But it doesn't work with a digraph, contrary to the default `f` command.
" Use `\f` when you need to look for a complex character (ex: →).

nno  \f  f

" \p            select paragraph in a block {{{4

" Select a box around the current paragraph.
" Useful to write some text FIRST, then hit `\p` and `mb` (draw-it plugin)
" to draw a box around it.

nno  <expr><silent>  \p  myfuncs#block_select_paragraph()

" }}}3
" g                   (prefix) {{{3
" g^ g$       first/last tabpage {{{4

nno  g^  :<c-u>1tabnext<cr>
nno  g$  :<c-u>$tabnext<cr>

" g c-v       select last edited text {{{4

"                ┌─ Visually select
" Mnemonic:    c-v
"              └─ the Changed text
nno  g<c-v>  `[v`]

" g SPC       break line {{{4

nno  <silent>  g<space>  :<c-u>set opfunc=<sid>break_line<cr>g@l

fu! s:break_line(_) abort
    " I sometimes press `g SPC` by  accident after getting back to the beginning
    " of a markdown file.
    " It creates a superfluous empty line.
    if col('.') ==# 1
        return
    endif

    try
        " break the line
        exe "norm! i\r"

        " trim ending whitespace on both lines
        keepj keepp .-,.s/\s\+$//e

        if !empty(bufname('%')) && fnamemodify(bufname('%'), ':p') isnot# $MYVIMRC
            sil update
        endif
    catch
        return lg#catch_error()
    endtry
endfu

" ga          easy align {{{4

" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap  ga  <plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap  ga  <plug>(EasyAlign)

" gf          & friends, in vimrc {{{4

" Purpose:
" When we're on a line enabling a plugin, it's convenient to be able to edit its
" configuration files by pressing `ZF`.
" So, we try to make `gf` & friends smarter.

augroup vimrc_mappings
    au!
    au BufReadPost $MYVIMRC  call s:install_vimrc_mappings()
augroup END

fu! s:install_vimrc_mappings() abort
    nno  <buffer><nowait><silent>  gf       :<c-u>call <sid>try_to_edit_plugin_config('gf')<cr>
    nno  <buffer><nowait><silent>  gF       :<c-u>call <sid>try_to_edit_plugin_config('gF')<cr>
    nno  <buffer><nowait><silent>  <c-w>f   :<c-u>call <sid>try_to_edit_plugin_config("\<lt>c-w>f")<cr>
    nno  <buffer><nowait><silent>  <c-w>F   :<c-u>call <sid>try_to_edit_plugin_config("\<lt>c-w>F")<cr>
    nno  <buffer><nowait><silent>  <c-w>gf  :<c-u>call <sid>try_to_edit_plugin_config("\<lt>c-w>gf")<cr>
    nno  <buffer><nowait><silent>  <c-w>gF  :<c-u>call <sid>try_to_edit_plugin_config("\<lt>c-w>gF")<cr>

    nmap <buffer><nowait>          <c-w>GF  <c-w>gF
    nmap <buffer>                  Z        <c-w>
endfu

fu! s:try_to_edit_plugin_config(cmd) abort
    let pat = '\C^\s*\<Plug\s\+''.\{-}/\%(vim-\)\=\zs.\{-}\ze\%([.-]vim\)\=/\='''
    let plugin = matchstr(getline('.'), pat)

    if empty(plugin)
        try
            exe 'norm! '.a:cmd
        catch
            echohl ErrorMsg
            echom v:exception
            echohl NONE
        endtry
    else
        let split = a:cmd[0] is# 'g' ? 'edit' : a:cmd[1] is# 'g' ? 'tabedit' : 'split'
        let files =  [$HOME.'/.vim/plugin/'.plugin.'.vim']
        let files += [$HOME.'/.vim/after/plugin/'.plugin.'.vim']
        let files += [$HOME.'/.vim/autoload/slow_call/'.plugin.'.vim']
        call filter(files, {i,v -> filereadable(v)})
        if empty(files)
            echo 'There''s no config file for '.string(plugin)
            return
        endif

        let a_file_is_opened = 0
        for f in files
            exe (a_file_is_opened ? 'sp ' : split).f
            let a_file_is_opened = 1
        endfor
    endif
endfu

" go {{{4

nno  <silent>  gof  :<c-u>call myfuncs#gtfo_open_gui(expand('%:p:h', 1))<cr>
nno  <silent>  goF  :<c-u>call myfuncs#gtfo_open_gui(getcwd())<cr>

nno  <silent>  got  :<c-u>call myfuncs#gtfo_open_term(expand('%:p:h', 1))<cr>
nno  <silent>  goT  :<c-u>call myfuncs#gtfo_open_term(getcwd())<cr>

" gQ {{{4

" In Ex mode,  every time we press a  key which is expanded into the  value of a
" custom function,  if the latter contains  empty lines, it will  raise an error
" (E501, E749).
"
" So, we  install a wrapper around  `gQ` to temporarily disable  all mappings in
" command-line mode.

"                   ┌ make sure we have visited the command-line at least once since Vim's startup
"                   │ otherwise E501:
"                   │ probably because custom command-line mappings haven't been installed yet,
"                   │ so `ToggleEditingCommands 0` is useless / too soon
"               ┌───┤
nno  <expr>  gQ ":\e".execute('ToggleEditingCommands 0', 'silent!').'gQ'

" gt  gT      search todo/fixme (Tags) {{{4

nno  <silent>  gt  :<c-u>call myfuncs#search_todo('buffer')<cr>
nno  <silent>  gT  :<c-u>call myfuncs#search_todo('project')<cr>

"}}}3
" m                   (prefix) {{{3
" m/  m?         put current location in loclist {{{4

" these mappings can be used to traverse an arbitrary set of locations in the
" current buffer, using `m/` and `m?` to populate/empty the loclist, and `[l`,
" `]l` to move from one location to the other

" If we use our breakdown plugin, it will make us lose the current loclist.
" But we could still recover it:    :lol[der]
"                                   :lhi[story]

" add current position in loclist
nno  <silent>  m/  :<c-u>call <sid>add_to_loclist(1)<cr>
" empty loclist
nno  <silent>  m?  :<c-u>call <sid>add_to_loclist(0)<cr>

fu! s:add_to_loclist(populate) abort
    let s:my_marks = a:populate
                 \ ?     get(s:, 'my_marks', []) + [{'bufnr': bufnr('%'), 'lnum': line('.'), 'col': col('.')}]
                 \ :     []
    "                               ┌─ without this, Vim would create a new
    "                               │  loclist every time we invoke the function
    "                               │
    call setloclist(0, s:my_marks, 'r')
    call setloclist(0, [], 'a', {'title': 'My marks'})
endfu

"}}}3
" U                   (prefix) {{{3

" go to previous save
" TODO:
" Previously, we used `UU`, but I suspect we pressed it by accident too often.
" So, now, we use `U C-o` (C-o like to move in the jumplist).
" For convenience, maybe install a submode, so that we can repeat the mapping,
" simply by pressing `C-o`.
nno  <silent>  U<c-o>  :<c-u>ea 1f<cr>
" we use `M-u u` to upcase a visual selection, so don't worry about shadowing `U`
xno  U<c-o>  :<c-u>ea 1f<cr>

" go to next save
nno  <silent>  U<c-i>  :<c-u>later 1f<cr>

" go to most recent version of the file
nno  <silent>  U<c-r>  :<c-u>exe 'undo '.undotree().seq_last<cr>

" fugitive
nno  <silent>  Ud  :<c-u>Gdiff<cr>

nno  <silent>  Up  :<c-u>call <sid>try_fugitive_cmd('Gpush')<cr>
nno  <silent>  Us  :<c-u>call <sid>try_fugitive_cmd('Gstatus')<cr>

fu! s:try_fugitive_cmd(cmd) abort
    if exists(':'.a:cmd) !=# 2
        echo 'Not in a git repo'
        return
    endif

    exe a:cmd
    if a:cmd is# 'Gstatus'
        sil! keepj keepp 1;/^# \%(Changes\|Untracked files\)/
    endif
endfu

" z                   (prefix) {{{3
" z= {{{4

" Will a repetition of this command open a new menu?{{{
"
" No, it will simply repeat the previous edit.
" Consider this text:
"
"     Hellzo peozple.
"
" Move your cursor on `Hellzo`, and press `z=` to fix it.
" Move your cursor on `peozple`, and press `.` to repeat.
" Vim will simply replace the word with `Hello`, it won't
" try to fix `people`.
"
" This is normal, do NOT try to change the code so that
" it opens a new menu.
" From `z=`:
"
"     When a word was replaced the redo command "." will
"     repeat the word replacement.  This works like "ciw",
"     the good word and <Esc>.
"}}}
nno  <silent>  z=  :<c-u>set opfunc=<sid>my_z_equal<cr>g@l

fu! s:my_z_equal(type) abort
    let spell_save = &l:spell
    try
        setl spell
        " Why not `norm! z=`?{{{
        "
        " We would not be  able to select an entry in  the menu, because `:norm`
        " would press `Escape`.
        " Indeed, it  considers `z=`  as in INcomplete  command, since  we don't
        " give it the number of the entry we want to select in advance.
        " From `:h norm`:
        "
        "     {commands} should be a complete command.  If
        "     {commands} does not finish a command, the last one
        "     will be aborted as if <Esc> or <C-C> was typed.
        "}}}
        call feedkeys('z=', 'in')
    catch
        return lg#catch_error()
    finally
        call timer_start(0, {-> execute('let &l:spell = '.spell_save, '')})
    endtry
endfu

" zd {{{4

" make `zd` repeatable
nno  <silent>  zd  :<c-u>set opfunc=<sid>my_zd<cr>g@l

fu! s:my_zd(type) abort
    norm! zd
endfu

" zf {{{4

nno  <silent>  zf  :<c-u>set opfunc=<sid>my_zf<cr>g@
xno  <silent>  zf  :<c-u>call <sid>my_zf('vis')<cr>

fu! s:my_zf(type) abort
    let cml = !empty(&l:cms) ? split(&l:cms, '%')[0] : ''
    " TODO: Why did we write these wrapper mappings?{{{
    "
    " It seems they remove a possible superfluous comment leader:
    "
    "     " this is a comment " { { {
    "                         ^
    "                         ✘
    "
    " But I can't find an example where Vim adds a superfluous comment leader...
    "}}}
    let pat = '^\s*\V'.escape(cml, '/\').'\m.*\zs\V'.escape(cml, '/\').'\m\ze\s*{'.'{{'
    if a:type is# 'vis'
        norm! '<V'>zf
        sil! exe 'keepj keepp ''<s/'.pat.'//'
    else
        norm! '[zf']
        sil! exe 'keepj keepp ''[s/'.pat.'//'
    endif
endfu

" zg (&friends) {{{4

" The default commands to add good / bad words in:
"
"     • a temporary list  use an uppercase character
"     • a persistent list use only lowercase characters
"
"     ┌────────────┬──────────────┬──────────────┐
"     │            │ mark         │ undo         │
"     ├────────────┼──────┬───────┼──────┬───────┤
"     │            │ good │ wrong │ good │ wrong │
"     ├────────────┼──────┼───────┼──────┼───────┤
"     │ persistent │ zg   │ zw    │ zug  │ zuw   │
"     ├────────────┼──────┼───────┼──────┼───────┤
"     │ temporary  │ zG   │ zW    │ zuG  │ zuW   │
"     └────────────┴──────┴───────┴──────┴───────┘
"
" For the moment, I  prefer to always add good / bad words  to a temporary list,
" so that  my choices don't persist  across sessions. Therefore, I swap  all the
" commands (easier to type lowercase characters):

" mark word under cursor as good
nno  <silent>  zg  :<c-u>call <sid>repeat_which_spell_command('zG')<bar>set opfunc=<sid>repeatable_spell_commands<cr>g@l
nno  <silent>  zG  :<c-u>call <sid>repeat_which_spell_command('zg')<bar>set opfunc=<sid>repeatable_spell_commands<cr>g@l

" mark word under cursor as wrong
nno  <silent>  zw  :<c-u>call <sid>repeat_which_spell_command('zW')<bar>set opfunc=<sid>repeatable_spell_commands<cr>g@l
nno  <silent>  zW  :<c-u>call <sid>repeat_which_spell_command('zw')<bar>set opfunc=<sid>repeatable_spell_commands<cr>g@l

" undo the marking of word under cursor as good
nno  <silent>  zug :<c-u>call <sid>repeat_which_spell_command('zuG')<bar>set opfunc=<sid>repeatable_spell_commands<cr>g@l
nno  <silent>  zuG :<c-u>call <sid>repeat_which_spell_command('zug')<bar>set opfunc=<sid>repeatable_spell_commands<cr>g@l

" undo the marking of word under cursor as wrong
nno  <silent>  zuw :<c-u>call <sid>repeat_which_spell_command('zuW')<bar>set opfunc=<sid>repeatable_spell_commands<cr>g@l
nno  <silent>  zuW :<c-u>call <sid>repeat_which_spell_command('zuw')<bar>set opfunc=<sid>repeatable_spell_commands<cr>g@l

fu! s:repeat_which_spell_command(cmd) abort
    let s:repeat_this_spell_command = a:cmd
endfu

fu! s:repeatable_spell_commands(type) abort
    let cmd = s:repeat_this_spell_command
    let last_char = cmd[-1:-1]
    let last_char_is_uppercase = last_char is# toupper(cmd[-1:-1])
    let cmd_to_repeat = cmd[:-2].(last_char_is_uppercase
        \ ? tolower(last_char)
        \ : toupper(last_char))
    exe 'norm! '.cmd
endfu

" }}}3
" |                   (prefix) {{{3
" |C  |F     open html file in firefox/chrome {{{4

nno  <silent>  <bar>F  :<c-u>exe ':sil !firefox localhost/' .
                       \ substitute(expand('%'), $HOME . '/htdocs/', '', '') <bar>
                       \ redraw!<cr>

nno  <silent>  <bar>C  :<c-u>exe ':sil !google-chrome localhost/' .
                       \ substitute(expand('%'), $HOME . '/htdocs/', '', '') <bar>
                       \ redraw!<cr>

" |c         execute the Compiler {{{4

nno  <silent>  <bar>c  :<c-u>sil make! <bar> redraw! <bar> cw<cr>

" |g         grep word under cursor / visual selection {{{4

" grep the word under the cursor, recursively in all the files of cwd
nno  <silent>  <bar>g  :<c-u>set operatorfunc=myfuncs#op_grep<cr>g@

" same thing for visual selection
xno  <silent>  <bar>g  :<c-u>call myfuncs#op_grep('vis')<cr>

" Why not `!g` for the `{lhs}` ?
" Because it would introduce some "lag" whenever we hit `!` to filter some
" visual selection. We would need to wait, or hit the second character of our
" command to see the bang on the command-line.

" |t         translate {{{4

"                                               ┌─ 1st invocation
"                                               │
nno  <silent>  <bar>t  :<c-u>call myfuncs#trans(1)<cr>
nno  <silent>  <bar>T  :<c-u>call myfuncs#trans_stop()<cr>
xno  <silent>  <bar>t  :<c-u>call myfuncs#trans(1, 1)<cr>
"              │                                   │
"              │                                   └─ visual mode
"              │
"              └─ do NOT use `!t`, it would prevent you from writing a visual selection
"                 on the standard input of a shell command whose name begins with a `t`
"
"                 do NOT use `!<c-t>`, it would introduce lag when we press `!` in visual mode
"
"                 do NOT use `<c-t>!`, it would be inconsistent with other similar mappings
"                 Ex:
"
"                         xno <silent>  <bar>x  "my:TxSend(@m)<cr>
"                                       │
"                                       └─ can't use `<c-x>!`, it would introduce lag when decreasing numbers

" cycle through several types of translations
nno  <silent>  coT  :<c-u>call myfuncs#trans_cycle()<cr>


" OLD CODE:
"
" nno <silent>  <bar>w  :<c-u> sil! call system('xdg-open http://www.wordreference.com/enfr/'
"                       \   .  expand('<cword>'))
"                       \<bar> redraw!<cr>

" |x  |X     Tmux run last / current command {{{4

nno  <silent>  <bar>x  :<c-u>call myfuncs#tmux_last_command()<cr>
nno  <silent>  <bar>X  :<c-u>call myfuncs#tmux_current_command(getline('.'))<cr>

" }}}3
" -                   (prefix) {{{3
" -a  -8           ascii / bytes info {{{4

" We remap `-a` to a function of the unicode.vim plugin which gives us more info
" about the  character under the  cursor. In particular, its unicode  name, html
" entity (&entity_name; OR &#entity_number;), and digraph inside parentheses (if
" there's one defined).
nmap  -a  <plug>(UnicodeGA)

" We remap `-8` to `g8` for consistency.
nno  -8  g8

" -c               TOC {{{4

" Source:
" https://github.com/neovim/neovim/pull/4449#issuecomment-237290098

" In Neovim, they use `gO`. Should we do the same?
nno  <silent>  -c  :<c-u>call myfuncs#tab_toc()<cr>
"               ^
"               Contents

" -f               show filetype {{{4

nno  -f  :<c-u>echohl Title <bar> echo '[filetype] '.(!empty(&ft) ? &ft : '∅') <bar> echohl NONE <cr>

" full path current file
"
" C-g does sth similar (:h ^g), but its output is:
"
"     • noisy
"     • not colored
"     • unable to expand `~`
"     • relative to the working directory

" -p  -P           show filePath / :pwd {{{4

nno  -p  :<c-u>call <sid>print_full_path()<cr>
nno  -P  :<c-u>pwd<cr>

fu! s:print_full_path() abort
    echohl Title
    let fname = expand('%:p')
    " later, we'll compare `fname` with its resolved form,
    " and the comparison may be wrongly different because of an extra ending slash
    let fname = substitute(fname, '/$', '', '')

    if fname is# ''
        echo '[No Name]'
    elseif &bt is# 'quickfix'
        echo w:quickfix_title
    else
        if fname[0] is# '/' || fname =~# '^\l\+://'
            let resolved = resolve(fname)
            echo resolved is# fname ? fname : fname.' -> '.resolved
        else
            " Why is adding the current working directory sometimes necessary?{{{
            "
            " If you edit a new buffer whose path is relative (to the working
            " directory), `expand('%:p')` will return a relative path:
            "
            "     :cd /tmp
            "     :e foo/bar
            "     :echo expand('%:p')
            "}}}
            echo getcwd().'/'.fname
        endif
    endif

    echohl NONE
endfu

" -q               faq {{{4

" Purpose:{{{
"
" Open a split in which you can write answers to a faq in a wiki.
" The height of the split will stay the same, even when you focus the wiki,
" because we temporarily set its window option 'pvw'.
" Also, we temporarily enable the “auto open folds” mode.
"}}}
" Usage:{{{
"
"     press `-q`
"             begin answering a faq in a wiki
"
"     press `-q` again
"             stop answering the faq
"}}}

nno  <silent>  -q  :<c-u>exe <sid>faq()<cr>

fu! s:faq() abort
    if stridx(expand('%:p'), '/wiki/') ==# -1 && expand('%:p') isnot# $XDG_RUNTIME_VIM.'/faq'
        return 'echo "you''re not in a wiki"'
    endif

    let this_tab = tabpagenr()
    let win_in_this_tab = filter(getwininfo(), {i,v -> v.tabnr ==# this_tab})
    let faq_file = $XDG_RUNTIME_VIM.'/faq'

    for win in win_in_this_tab
        if bufname(get(win, 'bufnr', '')) is# faq_file
            exe win.winnr . 'close'
            sil norm ]oz
            return ''
        endif
    endfor

    call map(deepcopy(win_in_this_tab), {i,v -> getwinvar(v.winnr, '&pvw', 0)})
    if index(win_in_this_tab , 1) !=# -1
        return 'echoerr "E590: A preview window already exists: previewwindow"'
    endif

    if index(map(deepcopy(win_in_this_tab), {i,v -> bufname(v.bufnr)}), faq_file) !=# -1
        echo 'a window displaying  '.faq_file.'  already exists'
        return ''
    endif

    exe 'sp '.faq_file
    sil norm [oP
    sil norm [oz
    wincmd p
    return ''
endfu

" -r               edit README {{{4

" Works also for a CONTENTS file.
"
" Mnemonic:
" Root (main) file of the directory.

nno  <silent>  -r  :<c-u>call <sid>edit_readme()<cr>

fu! s:edit_readme() abort
    let files = glob(expand('%:p:h').'/*', 0, 1)
    let kwd = '\%(readme\|contents\)'
    let pat = '\c/'.kwd.'\%(\..\{-}\)\=$'
    let readmes = filter(files, {i,v -> v =~# pat})
    let readme = get(readmes, 0, '')
    if filereadable(readme) || isdirectory(readme)
        exe 'sp '.readme
        " Why `:exe`?{{{
        "
        " If later  you add  a bar  after the  command, `1`  will be  interpreted as
        " `:1p[rint]`.
        " We don't want that side-effect.
        "
        " MWE:
        "     " ✘ the 123th line is printed on the command-line
        "     123 | sleep 1
        "
        "     " ✔ nothing is printed
        "     exe '123' | sleep 1
        "}}}
        exe '1'
    endif
endfu

" -s               edit snippets {{{4

" Why did you remove `-S`, which showed all our snippets?{{{
"
" `SPC fs` is better.
" It  allows   us  to   fuzzy  search  our   snippets,  and   can  automatically
" inserts+expands the selected tab trigger.
"}}}
nno  <silent>  -s  :<c-u>UltiSnipsEdit<cr>

" -U               show unicode table {{{4

" We define this mappping because  it's more convenient than the `:UnicodeTable`
" command, and  to install a buffer-local  mapping to close the  “unicode table“
" window with a single `q` (instead of `:q`).
nno  <silent>  -U  :<c-u>call <sid>unicode_table()<cr>

fu! s:unicode_table() abort
    UnicodeTable
    nno  <buffer><nowait><silent>  q  :<c-u>close<cr>
endfu

" -u               :UndotreeShow {{{4

" `D` toggles the diff window.
nno  <silent>  -u  :<c-u>UndotreeShow<cr>

" }}}3
" +                   (prefix) {{{3
" +>    +<      split/join listing or long data {{{4

" long data = dictionary, list, bulleted list

nno  <silent>  +>  :<c-u>set opfunc=myfuncs#long_data_split<cr>g@l
nno  <silent>  +<  :<c-u>set opfunc=myfuncs#long_data_join<cr>g@
xno  <silent>  +<  :<c-u>call myfuncs#long_data_join('vis')<cr>

" +t            trim whitespace {{{4

nno  <silent>  +t   :<c-u>set opfunc=myfuncs#op_trim_ws<cr>g@
xno  <silent>  +t   :<c-u>call myfuncs#op_trim_ws('vis')<cr>
nno  <silent>  +tt  :<c-u>set opfunc=myfuncs#op_trim_ws<bar>exe 'norm! '.v:count1.'g@_'<cr>

" +y  (+yc)     incremental yank (clear) {{{4

nno  <silent>  +y   :<c-u>set opfunc=myfuncs#op_incremental_yank<cr>g@
xno  <silent>  +y   :<c-u>call myfuncs#op_incremental_yank('vis')<cr>
nno  <silent>  +yy  :<c-u>set opfunc=myfuncs#op_incremental_yank<bar>exe 'norm! '.v:count1.'g@_'<cr>

nno  <silent>  +yc  :<c-u>call <sid>clear_z()<cr>

fu! s:clear_z() abort
    let [@z, @+] = ['', '']
    sil! put
    sil! undo
    echo 'z register: cleared'
endfu

" }}}3
" CR / Tab / Shift / Control / Meta {{{3
" CR                  move cursor on 80/100 column {{{4

" If the buffer is special (`!empty(&buftype)`), we let `CR` unchanged.
" Special  buffers  include   the  ones  displayed  in  the   quickfix  and  the
" command-line windows.
" It's important to not alter the behavior of `CR` in those buffers, because
" usually it's already mapped to a very useful function such as executing
" a command or going to an entry in the quickfix list.
"
" Otherwise, if the buffer is a regular one, we remap `CR` to move on the 80th
" column. It can be overridden on a filetype-basis, by an arbitrary Ex command.
" Example:
"         let b:cr_command = 'echo "hello"'
"
" If we wrote the previous line in a python ftplugin, hitting CR would display
" 'hello'.

nno  <expr><silent>  <cr>  !empty(&buftype)
                       \ ?     '<cr>'
                       \ :     ':<c-u>'.getbufvar('%', 'cr_command', 'norm! 80<bar>').'<cr>'
"                                 │
"                                 └── important, otherwise, if we hit a nr
"                                 (e.g. 42) by accident before `CR`, it would do:    :42norm! 100|
"                                 which would move the cursor 42 lines below the
"                                 current one

" S-→    C-↑ ...      modified arrow keys {{{4

" A terminal emulator gives its name to the programs through the shell
" environment variable $TERM.

" When Vim runs inside a terminal whose name begins with 'xterm' (xterm,
" xterm-256color), it automatically sets up a few keys including the modified
" arrow keys (S-Left, S-Right, C-Up, C-Down …).
"
" However, if the name  of the terminal begins with 'screen'  or 'tmux', it does
" NOT set up those keys.
" For  tmux   to  function  properly,   we  have  configured  ~/.shrc   so  that
" $TERM=tmux-256color (in tmux only, not in basic terminal emulator).
" Because of this, Vim does NOT set up the modified arrow keys when we run it
" inside tmux. This means we can't map any action to a modified arrow key.
" For example, by default Vim moves the cursor by word in normal mode when we
" hit S-Left / Right.
"
" We need to set up the modified arrow keys ourselves.

" To understand the code, read:
"
"         https://unix.stackexchange.com/a/34723/289772
"
" See also: :h xterm-modifier-keys
"
" :h version7:
"
"         Not all modifiers were recognized for xterm function keys.  Added the
"         possibility in term codes to end in ";*X" or "O*X", where X is any
"         character and the * stands for the modifier code.
"         Added the <xUp>, <xDown>, <xLeft> and <xRight> keys, to be able to
"         recognize the two forms that xterm can send their codes in and still
"         handle all possible modifiers.
"
" The `*` in the next code stands for the modifier `C-`, `S-`, `M-`.
" While the `x` is there because it seems that `xterm` can send codes in
" 2 forms.

if &term =~# '^\%(screen\|tmux\)'
    sil! exe "set <xUp>=\e[1;*A"
    sil! exe "set <xDown>=\e[1;*B"
    sil! exe "set <xRight>=\e[1;*C"
    sil! exe "set <xLeft>=\e[1;*D"
endif

" C-g C-g             show info about current file {{{4

nno  <c-g><c-g>  <c-g>

" C-np                move across tab pages {{{4

nno  <silent>  <c-p>  :<c-u>tabprevious<cr>
nno  <silent>  <c-n>  :<c-u>call <sid>move_across_tabpages(v:count)<cr>

fu! s:move_across_tabpages(cnt) abort
    " If the  mapping received a count,  move the current window  to the tabpage
    " whose number matches this count.
    if a:cnt
        let bufnr = bufnr('%')
        close!
        exe 'tabnext '.min([a:cnt, tabpagenr('$')])
        exe 'sb '.bufnr
    else
        tabnext
    endif
endfu

" M-m                 matchadd / matchdelete search pattern {{{4

fu! s:where_are_my_matches() abort
    if exists('w:my_matches')
        sil! call matchdelete(w:my_matches)
        unlet! w:my_matches
    else
        let w:my_matches = matchadd('WildMenu', '\c'.@/, 10)
    endif
endfu

nno  <silent>  <m-m>  :<c-u>noh <bar> call <sid>where_are_my_matches()<cr>

" M-n    M-p          navigate between marks {{{4

nno  <m-n>  ]'
nno  <m-p>  ['

" }}}3
" =A                  toggle alignment {{{3

nno  <silent>  =A  :<c-u>set opfunc=myfuncs#op_toggle_alignment<cr>g@
xno  <silent>  =A  :<c-u>call myfuncs#op_toggle_alignment('vis')<cr>

" >>                  indent without 'shiftround' {{{3

" You refer to `v:count1` in the mapping, then in the function. Isn't it too much?{{{
"
" No.
" In the mapping, you can't press `g@` without `v:count1`.
" `g@` alone would reset `v:count1` to `1`.
"
" We could probably use `']` and the `>` operator in our function,
" but `v:count1` seems simpler.
"}}}
nno  <silent>  >>  :<c-u>call <sid>indent_without_shiftround_save('increase')<bar>set opfunc=<sid>indent_without_shiftround<bar>exe 'norm! '.v:count1.'g@l'<cr>
nno  <silent>  <<  :<c-u>call <sid>indent_without_shiftround_save('decrease')<bar>set opfunc=<sid>indent_without_shiftround<bar>exe 'norm! '.v:count1.'g@l'<cr>

fu! s:indent_without_shiftround_save(dir) abort
    let s:indent_without_shiftround_dir = a:dir
endfu

fu! s:indent_without_shiftround(type) abort
    let op = (s:indent_without_shiftround_dir is# 'increase' ? '>>' : '<<')
    let sr_save = &sr
    try
        set sr
        exe 'norm! '.v:count1.op
    catch
        return lg#catch_error()
    finally
        let &sr = sr_save
    endtry
endfu

" Why don't you use the following code anymore.{{{
"
" It breaks  `>>` and `<<`, because as  soon as you press `>` or  `<`, Vim calls
" the corresponding operator.
" When we press `>`/`<` a second time, we don't provide a valid motion/text-object.
" Therefore, the operation is cancelled.
"}}}

" What did these mappings?{{{
"
" They indent  a text-object, like  the default  `>` and `<`,  while temporarily
" disabling 'sr'.
"}}}
" Why did you install them?{{{
"
" Watch:
"     foo
"       bar
"     baz
"
" press `>ip` →
"
"            foo
"            bar
"            baz
"
" The relative indentation between them has been lost.
" They now all have the same  indentation level, while before `bar` had a bigger
" indentation level.
"
" The cause seems to be 'sr'.
"}}}
" nno  <silent>  >  :<c-u>call <sid>set_indentation_direction('increase')
"                   \ <bar>set opfunc=<sid>indent_without_shiftround<cr>g@
"
" nno  <silent>  <  :<c-u>call <sid>set_indentation_direction('decrease')
"                   \ <bar>set opfunc=<sid>indent_without_shiftround<cr>g@
"
" fu! s:set_indentation_direction(dir) abort
"     if a:dir is# 'increase'
"        let s:indentation_direction = 'increase'
"     else
"        let s:indentation_direction = 'decrease'
"     endif
" endfu
"
" fu! s:indent_without_shiftround(type) abort
"     let sr_save = &sr
"     try
"         set nosr
"         let operator = get(s:, 'indentation_direction', '') is# 'decrease' ? '<' : '>'
"         exe 'norm! '.line("'[").'G'.operator.line("']").'G'
"     catch
"         return lg#catch_error()
"     finally
"         let &sr = sr_save
"     endtry
" endfu

" >b  <b              create/destroy box {{{3

" Draw a box around the text inside the paragraph.
" The fields must be separated with `|`.
" The function will populate the `s` and `x` registers with 2 kind of
" separation lines. We can paste them to fine tune the box.
nno  <silent>  >b  :<c-u>set opfunc=myfuncs#box_create<cr>g@ip

" undo the box, make it come back to just bars between cells
nno  <silent>  <b  :<c-u>set opfunc=myfuncs#box_destroy<cr>g@ip

" =d                  fix display {{{3

" In normal mode, we remapped `C-l` to give the focus to the right window.
" But by default, `C-l` redraws the screen by executing `:redraw!`.
"
" So, we need to bind `:redraw!` to another key, `=d` could be a good
" candidate.

nno  <silent>  =d  :<c-u>call <sid>fix_display()<cr>

fu! s:fix_display() abort
    let view = winsaveview()

    " redraw screen
    redraw!
    " redraw all status lines
    redraws!

    " update differences between windows in diff mode
    diffupdate!
    "         │
    "         └ check if the file was changed externally and needs to be reloaded

    " update folds
    norm! zx

    " update title in folds
    do BufWinEnter

    " Re-install HGs which may have been cleared after changing the colorscheme.{{{
    "
    " Remember that to change the brightness  of `seoul-256`, in effect, we *do*
    " change the colorscheme.
    " Also, note  that `do Syntax` will  only re-install a HG  if its attributes
    " are defined in a syntax plugin which is sourced for the current buffer.
    "}}}
    " We already run `:do Syntax` from an autocmd listening to `ColorScheme`.  Is it really useful here?{{{
    "
    " It could be useful if we have a loaded buffer which is not displayed anywhere...
    "}}}
    do Syntax

    " Purpose:{{{
    "
    " Reset the min/max number of lines above the viewport from which Vim begins
    " parsing the buffer to apply syntax highlighting.
    "
    " Sometimes syntax highlighting is wrong, these commands should fix that.
    "
    " We could also be more radical, and execute:
    "
    "     :syntax sync fromstart
    "
    " But after we execute  it in our `vimrc`, every time  we source the latter,
    " we experience lag.
    "}}}
    syntax sync minlines=200
    syntax sync maxlines=400

    call winrestview(view)
endfu

" =m                  fix macro {{{3

" Usage:
"     =ma  →  edit macro a
"     …
"     =mz  →  edit macro z
nno  <expr><silent>  =m  <sid>fix_macro()

fu! s:fix_macro() abort
    let c = getchar()
    if c < 97 || c > 123
        call timer_start(0, {-> execute('redraw')})
        return ''
    endif
    let c = nr2char(c)
    return printf("q:ilet @%s = \<c-r>\<c-r>=string(@%s)\r\e0f'", c, c)
endfu

" ""                  easier access to system register  {{{3

" We don't tweak 'cb' anymore, because it causes too many issues.

nno  ""  "+
xno  ""  "+

" { }                 move by paragraphs {{{3

nno  <silent>  {  :<c-u>call search('\v(^\s*$<bar>%^)\_s*\zs\S', 'bW')<cr>zv
nno  <silent>  }  :<c-u>call search('\v\S+.*\ze\n\s*$', 'W')<cr>zv

" c*                  change word under cursor {{{3

" What you need to know to understand these mappings:
"
"       cgn    change next occurrence of search register
"       cgN    change previous occurrence of search register
"
"       we've enabled 'ignorecase', because it's convenient for a broader search
"       we've enabled 'smartcase', to make Vim a bit smarter:
"
"               if the search register contains uppercase characters, we
"               probably want to take the case into account
"
"       `*` and `/` are resp. stupid and clever, because the former ignores
"       'smartcase' while the latter respects it
"
"       the `c*` mapping uses `*` to populate the search register
"       so, it will be stupid, and we need to make it clever:
"               /<up><cr>``
"               │
"               └─ fixes `*` stupidity


"        ┌─ populate search register with word under cursor
"        │
"        │┌─ get back where we were
"        ││
"        ││          ┌─ get back where we were
"        ││          │
"        ││          │   ┌ change next occurrence of pattern
"        ││          │ ┌─┤
nno  c*  *``/<up><cr>``cgn
"           └───────┤
"                   └ take 'smartcase' into account

nno  c#  #``/<up><cr>``cgN


" We also install `cg*` and `cg#` if we want to look for the word under the
" cursor WITHOUT the anchors `\<`, `\>`.
nno  cg*  g*``/<up><cr>``cgn
nno  cg#  g#``/<up><cr>``cgN

" crg                 coerce to glyph {{{3

" The behavior of this operator can be customized via
" g:Unicode_ConvertDigraphSubset.
" Have a look at: ~/.vim/after/plugin/abbrev.vim

nmap  crg   <plug>(MakeDigraph)
nmap  crgg  <plug>(MakeDigraph)_

" dr                  replace without yank {{{3

" We save the name of the register which was called just before `dr` inside
" a script-local variable (`s:replace_reg_name`) through the `myfuncs#set_reg()`
" function. Why?
" Because if we repeat the operation with `.`, we want the operator to look
" for the replacement text from the same register that we used the first time.
" The dot command doesn't save that information.
" So, we have to do it manually.

" TODO:
" maybe we could get rid of `myfuncs#set_reg()` and use `repeat#setreg()` instead.

nno  <silent>  dr  :<c-u>call myfuncs#set_reg(v:register)
                  \ <bar>set opfunc=myfuncs#op_replace_without_yank<cr>g@

nno  <silent>  drr  :<c-u>call myfuncs#set_reg(v:register)
                   \ <bar>set opfunc=myfuncs#op_replace_without_yank
                   \ <bar>exe 'norm! '.v:count1.'g@_'<cr>

" j  k  ^  0  $       gj  gk  … {{{3

" By default, we can't move across several lines of a long wrapped line with
" `j` and `k`.
"
"                       ┌─ if we used a count, we probably don't care about wrapped lines
"                       │
nno  <expr><silent>  j  v:count ? (v:count >= 5 ? "m'".v:count : '').'j' : 'gj'
nno  <expr><silent>  k  v:count ? (v:count >= 5 ? "m'".v:count : '').'k' : 'gk'
"                                 └────────────────────────────────┤
"                                                                  └ if the count was bigger than 5,
"                                                                    we consider the motion as a jump
"                                                                    useful to come back with `c-o`

" If we're inside a long wrapped line, `^` and `0` should go the beginning
" of the line of the screen (not the beginning of the long line of the file).
nno  <silent>  ^  g^
nno  <silent>  0  g0

" To draw freely, sometimes we need to enable 'virtualedit'.
" And then, when we hit `$`, the cursor moves to the very end of the screen.
" We never want that. We want the cursor on the last non whitespace.
nno  <expr>  $  &virtualedit is# 'block' ? 'g$' : 'g_'

" FIXME:
" Consider the following buffer:
"     foo = a
"           ab
"           abc

" If I want to surround a, ab and abc with single quotes, I could do:
"         :set startofline
"         C-v G h A '
"         :nunmap $
"         $ .

" But if instead of hitting `$`, I hit `g$`, the ending quote is too far:
"       foo = 'a     '
"             'ab    '
"             'abc   '

" Why does the dot command changes its behavior when we hit `g$`.
" According to :h g$, `g$` differs from `$` when:
"
"         • preceded with a count
"         • on a wrapped line
"         • on a line longer than the screen
"         • if 'virtualedit' is enabled
"
" Here, none of these conditions is met. So what happens?
" Should I unmap `$` in normal mode?
"
" Hypothesis:
" Maybe it has something to do with :h visual-repeat:
"
"         If the "$" command was used as one of the last commands to extend
"         the highlighted text, the repeating will be applied up to the rightmost
"         column of the longest line.


" Same mappings for visual mode.
xno  <silent>  j  gj
xno  <silent>  k  gk
xno  <silent>  ^  g^
xno  <silent>  0  g0

" H  L  M             collapse/expand folds {{{3

" collapse all
nno  H  zMzz
" expand all
nno  L  zRzz
" expand just enough to see where we are
nno  M  zMzvzz

" J        gJ         join without moving {{{3

nno  <silent>  J  @="mzJ`z"<cr>

" gJ doesn't insert or remove any spaces
nno  <silent>  gJ  @="mzgJ`z"<cr>

" Q        q {{{3

" Par défaut, Q fait passer en mode Ex, un mode d'édition dans lequel:
" on n'interagit qu'avec des commandes Ex
" pas besoin de taper : au début de chaque nouvelle commande
" l'écran n'est pas mis à jour après chaque édition
"
" C'est un mode adapté lorsqu'on travaille sur une machine distante avec
" laquelle il y a beaucoup de lag.
"
" On entre souvent dans ce mode par erreur. Pour en sortir, il faut taper
" :vi[sual]
" Pour ne plus entrer dans ce mode par accident, on remap Q à q.
nno  Q  q

" Y        y$ {{{3

nno  Y  y$

" We can't separate a register name from the `y` command, with a motion.
" They  must be consecutive. Otherwise the  yanking fails to target  the desired
" register. MWE:
"
"         C-v 3j "+ $ y    ✘
"         C-v 3j $ "+ y    ✔
"
" As  soon as  we type  the `$`  motion, the  register name  is lost  (watch the
" command-line).
" So, we use an  expression, to make sure that they are consecutive.
xno  <expr>  Y  '$"'.v:register.'y'

" yc / yC    ym / yM      yank comments / Code  matching / non-matching lines {{{3

" comments
nno  <silent>  yc   :<c-u>call myfuncs#op_yank_matches_set_action(1, 1)
                   \ <bar> set opfunc=myfuncs#op_yank_matches<cr>g@
xno  <silent>  myc  :<c-u>call myfuncs#op_yank_matches_set_action(1, 1)
                   \ <bar> call myfuncs#op_yank_matches('vis')<cr>

" Code
"                      don't yank where a commented line is found ┐
"                                                                 │
nno  <silent>  yC   :<c-u>call myfuncs#op_yank_matches_set_action(0, 1)
                   \ <bar> set opfunc=myfuncs#op_yank_matches<cr>g@
xno  <silent>  myC  :<c-u>call myfuncs#op_yank_matches_set_action(0, 1)
                   \ <bar> call myfuncs#op_yank_matches('vis')<cr>

" lines matching last search
nno  <silent>  ym   :<c-u>call myfuncs#op_yank_matches_set_action(1, 0)
                   \ <bar> set opfunc=myfuncs#op_yank_matches<cr>g@
xno  <silent>  mym  :<c-u>call myfuncs#op_yank_matches_set_action(1, 0)
                   \ <bar> call myfuncs#op_yank_matches('vis')<cr>

" lines which do NOT match last search
nno  <silent>  yM   :<c-u>call myfuncs#op_yank_matches_set_action(0, 0)
                   \ <bar> set opfunc=myfuncs#op_yank_matches<cr>g@
xno  <silent>  myM  :<c-u>call myfuncs#op_yank_matches_set_action(0, 0)
                   \ <bar> call myfuncs#op_yank_matches('vis')<cr>

" }}}2
" OBJECTS {{{2
" i% {{{3

" OLD CODE:{{{
"
"                    ┌ move cursor to next surrounding symbols
"               ┌────┤
"               │    │          ┌ do NOT add a bang:
"               │    │          │ it would break the mapping for custom text-object like `i“`
"               │    │          │
" xno <silent> i% <esc>%:exe 'norm vi'.matchstr(getline('.'), '\%'.col('.').'c.')<cr>
"                                    │
"                                    └ surrounding symbol
"
"                                      We could also use:
"
"                                              getline('.')[col('.')-1]<cr>
"
"                                      … but it would not work for multibyte characters.
"}}}
" Why don't we use the old code anymore?{{{
"
" The new  one takes  into consideration  all pairs  stored in  the buffer-local
" value of 'mps'. Including “” and ‘’.
"}}}
" Could the new code be improved?{{{
"
" Yes, currently  it doesn't always  work on multiline text-object,  because the
" initial `%` finds an opening symbol, reliably, only when it's on the last line
" of the text-object.
"
" MWE:
"
"         (foo
"         b|ar
"         baz)
"
"         “foo
"         bar
"         b|az”
"
" Press `vi%`, while the cursor is on the bar.
"
"}}}
" Why no `v_a%`?{{{
"
" It would shadow `v_a%` from the `matchit` plugin:
"
"         xno <silent> a% <Esc>%v%
"         ono <silent> a% :norm va%<cr>
"}}}
xno  <silent>  i%  <esc>:call <sid>select_percent_object()<cr>
ono  <silent>  i%  :norm vi%<cr>

fu! s:select_percent_object() abort
    let pos = getcurpos()
    " search for a closing/opening symbol
    norm! %
    if getcurpos() ==# pos
        return
    endif
    " save closing/opening symbol
    let sym = matchstr(getline('.'), '\%'.col('.').'c.')
    " Maybe we could speed the process by storing the next 2 values in buffer-local
    " variables every time `FileType *` is fired. Not sure it's worth it.
    let opening_syms = map(split(&l:mps, ','), { i,v -> matchstr(v, '.')} )
    let closing_syms = map(split(&l:mps, ','), { i,v -> matchstr(v, '.$')} )
    " check it is indeed in 'mps'
    if index(opening_syms, sym) < 0 && index(closing_syms, sym) < 0
        return
    endif
    " check we're on a closing symbol
    if index(opening_syms, sym) >= 0
        norm! %
    endif
    " select object and quit to set the marks
    exe "norm! v%\e"
    " check there's at least one character inside the object
    if getline("'<") ==# getline("'>") && virtcol("'>") ==# virtcol("'<") + 1
        return
    endif
    norm! gvloh
endfu

" iE {{{3

" Entire buffer
" We don't use `ie` but `iE`, because `ie` is too easily typed.
" We could easily delete the whole buffer `cie`, `die` by mistake.

xno  <silent>  iE  G$ogg0
ono  <silent>  iE  :<c-u>norm ViE<cr>

" if {{{3

" Vim function

" FIXME:
" not reliable text objects (check out kana plugin)
" fix also `o_il` and `o_al` (i.e. add support for visual mode)
xno  <silent>  if  :<c-u>call <sid>textobj_func(1)<cr>
ono  <silent>  if  :<c-u>norm Vif<cr>

xno  <silent>  af  :<c-u>call <sid>textobj_func(0)<cr>
ono  <silent>  af  :<c-u>norm Vaf<cr>

fu! s:textobj_func(inside) abort
    if search('^\s*fu\%[nction]', 'bcW')
        k<
        call search('^\s*endf\%[unction]\s*$', 'eW')
        k>
        exe 'norm! gv$'.(a:inside ? 'koj' : '')
        " we want a linewise selection no matter the original visual mode
        exe (mode() isnot# 'V' ? 'norm! V' : '')
    endif
endfu

" il {{{3

" `il` = in line (operate on the text between first and last non-whitespace on the line)
" Useful to copy a line and paste it characterwise (in the middle of another line)

ono  <silent>  il  :norm! _vg_<cr>
ono  <silent>  al  _

" We don't need to create `al` (around line) to operate on the whole line
" including newline, because `_` can be used instead.
" Example:
"
"     +y_
"     +y3_
"
" … add current line to plus register (`+y` = custom operator, incremental yanking).
" Besides, an operator should be able to operate on the current line when it's
" repeated (`cc`, `yy`, `dd`…).
" But still, it brings consistency/symmetry.

" in {{{3

" Source: https://vimways.org/2018/transactions-pending/

" Pattern matching numbers.
" The order matters ... Keep `\d` last!.
" `\+` will be appended to the end of each.
let s:pat_numbers = ['0b[01]', '0x\x', '\d']

fu! s:around_number() abort "{{{4
    " This can handle the following three formats:{{{
    "
    "   1. binary  (eg: "0b1010", "0b0000", etc)
    "   2. hex     (eg: "0xffff", "0x0000", "0x10af", etc)
    "   3. decimal (eg: "0", "0000", "10", "01", etc)
    "
    " If there  is no number on  the rest of  the line starting at  the  current
    " cursor  position, then  visual selection  mode  is ended  (if  called  via
    " `:omap`) or nothing is selected (if called via `:xmap`).
    " This is true even if on the space following a number.
    "}}}

    let stopline = line('.')

    " create pattern matching any binary, hex, decimal number
    let pat = join(s:pat_numbers, '\+\|') . '\+'

    " move cursor to end of number
    if !search(pat, 'ce', stopline)
        " if it fails, there was not match on the line, so return prematurely
        return
    endif

    " move cursor to end of any trailing whitespace (if there is any)
    call search('\%'.(virtcol('.')+1).'v\s*', 'ce', stopline)

    " start visually selecting from end of number + potential trailing whitspace
    norm! v

    " move cursor to beginning of number
    call search(pat, 'bc', stopline)

    " move cursor to beginning of any whitespace preceding number (if any)
    call search('\s*\%'.virtcol('.').'v', 'b', stopline)
endfu
" }}}4

" next number on line and possible surrounding whitespace
xno <silent> an :<c-u>call <sid>around_number()<cr>
ono <silent> an :<c-u>call <sid>around_number()<cr>

fu! s:in_number() abort "{{{4
    " select the next number on the line

    let stopline = line('.')

    " Create pattern matching any binary, hex, decimal number.
    let pat = join(s:pat_numbers, '\+\|') . '\+'

    " move cursor to end of number
    if !search(pat, 'ce', stopline)
        " if it fails, there was not match on the line, so return prematurely
        return
    endif

    " start visually selecting from end of number
    norm! v

    " move cursor to beginning of number
    call search(pat, 'bc', stopline)
endfu
" }}}4

" next number after cursor on current line
xno <silent> in :<c-u>call <sid>in_number()<cr>
ono <silent> in :<c-u>call <sid>in_number()<cr>

" iS {{{3

" `vim-sandwich` installs the following mappings:
"
"         x  is  <plug>(textobj-sandwich-query-i)
"         x  as  <plug>(textobj-sandwich-query-a)
"         o  is  <plug>(textobj-sandwich-query-i)
"         o  as  <plug>(textobj-sandwich-query-a)
"
" They  shadow  the  built-in  sentences  objects. But I  use  the  latter  less
" frequently than  the sandwich objects. So,  I won't remove  the mappings. But,
" instead, to restore the sentences objects, we install these mappings:

ono  iS  is
ono  aS  as

xno  iS  is
xno  aS  as

" }}}2
" SELECT {{{2

" DWIM:
" move to left/right in select mode (useful for UltiSnips)
snor  <c-b>  <esc>i<left>
snor  <c-f>  <esc>i<right>

" After expanding a snippet, I want to be able to delete the character after
" the cursor with C-d like in insert mode.
snor  <c-d>  <esc>i<del>

" TERMINAL {{{2

" In Vim, we can't use `esc` in the  lhs of a mapping, because any key producing
" a  sequence of  keycodes  containing Esc,  would be  subject  to an  undesired
" remapping (m-b, m-f, left, right, …).
"
" Example:  `M-b`  produce Escape  (go to  Terminal-Normal mode)  + b  (one word
" backward). We DO  want to go one  word backward, but  we also want to  stay in
" Terminal-Job mode.
"
" Neovim doesn't suffer from this issue.
" So, to  go from Terminal-Job mode  to Terminal-Normal mode, we  could use this
" mapping:
"
"         exe 'tno '.(has('nvim') ? '<esc>' : '<esc><esc>').' <c-\><c-n>'
"
" But  I prefer to  stay consistent. Double Escape in  Vim → double  escape in
" neovim.
" TODO:
" Find a  way to send  an Escape  key to the  foreground program running  in the
" terminal. Maybe something like this:
"
"         exe "set <m-[>=\e["
"         tno  <m-[>  <esc>
"
" It doesn't work, but you get the idea.
tno  <esc><esc>  <c-\><c-n>

" Do NOT add this mapping:  tno  <esc>:  <c-\><c-n>:{{{
"
" Why?
"
"     z<      open a terminal
"     Esc :   enter command-line
"     Esc     get back to terminal normal mode
"     z>      close terminal
"
" The meta keysyms are disabled.
" }}}
"}}}
" VISUAL {{{2
" C-s {{{3

" Search inside visual selection
" What difference with :*ilist! foobar ?
" `:ilist`:
"
"     • searches in all included files. :g only in current buffer.
"     • can ignore comment if we don't put a bang
"     • automatically adds \<,\> around the pattern, if we don't surround it with slashes

xno  <c-s>  <esc>:keepj keepp *g/\%V/#<left><left>

" /           search only in visual selection {{{3

" Do not try to install an `<expr>` mapping which would return the keys.{{{
"
" Before the  function checks the  position of the  visual marks, you  must have
" quit the visual mode so that they  have been updated.
" But you can't do that if the function is called while the text is locked.
"}}}
xno  <silent>  /  :<c-u>call <sid>visual_slash()<cr>
fu! s:visual_slash() abort
    if line("'<") ==# line("'>")
        call feedkeys('gv/', 'int')
    else
        " Do not reselect the visual selection with `gv`.{{{
        "
        " It would make move the end of the selection.
        " That's not what we want.
        " We want to search in the last visual selection.
        "}}}
        call feedkeys('/\%V', 'int')
    endif
endfu

" .    @ {{{3

" Repeat last edit on all the visually selected lines with dot
xno  <silent>  .  :norm! .<cr>
"                      ^
" Warning: The bang may prevent the repetition of pseudo-operators such as `ys` provided by `vim-surround`.{{{
"
" I think that's because `vim-surround` doesn't implement real operators.
" It emulates them.
" `vim-sandwich` doesn't suffer from this issue.
"}}}

" Purpose:{{{
"
" Repeat last macro on all the visually selected lines with `@{reg}`.
"}}}
" Why not `xno  @  :norm @<c-r>=nr2char(getchar())<cr><cr>`?{{{
"
" The  last carriage  return which  executes the  command (norm  @q^M) is  moved
" before the register name (`norm @^Mq`).
"
" The reason is  probably because `getchar()` consumes  the remaining characters
" from the mapping.
" At the end of the mapping, there's a CR.
" When `getchar()` is called, it consumes it, instead of just waiting for our input.
" The solution would be to use  `inputsave()` / `inputrestore()`, but that would
" make the mapping uselessly complex.
"}}}
xno  <silent>  @  :<c-u>exe "'<,'>norm @".nr2char(getchar())<cr>
"                                    │
"                                    └─ Do NOT add a bang:{{{
"
" We want the recursiveness, for one of our mapping to be used.
" It temporarily disables some keysyms which may break the replay of a macro.
"}}}

" A  I  gI    niceblock {{{3

" https://github.com/kana/vim-niceblock/blob/master/doc/niceblock.txt
"
" v_b_I = Visual-block Insert
" v_b_A = Visual-block Append
"
"         • Make |v_b_I| and |v_b_A| available in all kinds of Visual mode.
"         • Adjust the selected area to be intuitive before doing blockwise insertion.

let s:niceblock_keys = {
    \   '$'    : {'v': 'g$h',      'V': '$',          "\<c-v>": '$'},
    \   'I'    : {'v': "\<c-v>I",  'V': "\<c-v>^o^I", "\<c-v>": 'I'},
    \   'A'    : {'v': "\<c-v>A",  'V': "\<c-v>0o$A", "\<c-v>": 'A'},
    \   'gI'   : {'v': "\<c-v>0I", 'V': "\<c-v>0o$I", "\<c-v>": '0I'},
    \   '>'    : {'v': "\<c-v>>",  'V': "0\<c-v>>",   "\<c-v>": '>'},
    \   '<'    : {'v': "\<c-v><",  'V': "0\<c-v><",   "\<c-v>": '<'},
    \ }

fu! s:niceblock(key) abort
    return s:niceblock_keys[a:key][mode()]
endfu


" The purpose of this mapping is to not include a newline when selecting
" a characterwise text until the end of the line.
xno  <expr>  $  <sid>niceblock('$')

xno  <expr>  I   <sid>niceblock('I')
xno  <expr>  gI  <sid>niceblock('gI')
xno  <expr>  A   <sid>niceblock('A')

" Why these assignments:
"
"         niceblock_keys['>']['V'] = "0\<c-v>>"
"         niceblock_keys['<']['V'] = "0\<c-v><"
"
" ... and not simply:
"
"         niceblock_keys['>']['V'] = ">"
"         niceblock_keys['<']['V'] = "<"
"
" ? Because, without "\<c-v>", sometimes the alignment is lost.

xno  <expr>  >  <sid>niceblock('>')
xno  <expr>  <  <sid>niceblock('<')

" d y         preserve last deleted/yanked visual selected text through registers {{{3

" When we delete sth in visual mode to  move it somewhere else, if we delete sth
" else before  pasting it, we  lose it  (well technically it's  still accessible
" from a numbered register, but if we  delete several things, we have to execute
" `:reg` to see where it is now).

" With this  mapping, we can  always access the last  text we deleted  in visual
" mode, from the `v` register.
xno  <expr><silent>  d  'd'.timer_start(0, {-> execute('let @v=@"')})[-1]

" same thing when we yank
xno  <expr><silent>  y  'y'.timer_start(0, {-> execute('let @v=@"')})[-1]

" h l         disable at the beginning/end of line in visual block mode {{{3

xno  <expr>  h  mode() is# '<c-v>' && virtcol('.') ==# 1            ? '' : 'h'
xno  <expr>  l  mode() is# '<c-v>' && virtcol('.') ==# &columns - 2 ? '' : 'l'

" ip          disable on empty line {{{3

" sometimes I hit `vip` by accident on an empty line
" annoying, because it can make me lose previous visual selection
" (you can cycle through the last 2 visual selections with `gv`)

nno  <expr><silent>  vip  getline('.') =~# '^\s*$' ? '' : 'vip'

" gJ  g C-j   join lines {{{3

" We use J to move the selection down. The J command needs to be restored.
xno  gJ       J
" Now `gJ` needs to be restored.
xno  g<c-j>  gJ

" mJ  m C-j   join blocks {{{3

" Difference compared to :JoinBlocks?:
"
"   • easier to use;  no need to position the cursor on
"                     the first line of the 2nd block
"                     no need to provide the nr of lines in a block
"                     as an argument
"
"   • not repeatable; each time we call it, we must first visually select
"                     the lines (or provide an arbitrary range)
"                     :JoinBlocks can be repeated simply by typing @:


" How does `join_blocks()` work?
" It mainly executes 3 commands:
"
"   • insert a literal ^A in front of all the lines in the 2nd block
"   • join the 2 blocks
"   • align the blocks using ^A as a delimiter

xno  <silent>  mJ      :<c-u>call myfuncs#join_blocks(0)<cr>
xno  <silent>  m<c-j>  :<c-u>call myfuncs#join_blocks(1)<cr>
"                                                     │
"                                                     └─ first, reverse the order of the blocks
"                                                        then, join them

" }}}1
" COMMANDS {{{1
" Warning: Here, do NOT create commands which are only relevant for a specific type of buffer. {{{2
"
" Those should be defined in a filetype plugin with the `-buffer` attribute.
" }}}2

" CGrep / LGrep {{{2

" :Grep /  :LGrep grep  for a  pattern below  the cwd  using the  external shell
" program defined by the option 'grepprg'.
" At the moment, it's `$ ag`.
" Usage:
"         CGrep pat
"
" Don't type:
"         CGrep pat .
"                   │
"                   └─ ✘ current directory
"                        our  command  would include  `  .`  inside the  pattern
"                        literally (because  of `shellescape() which  quotes the
"                        whole argument`)

com! -nargs=+  CGrep  call myfuncs#op_grep('Ex', <q-args>, 0)
com! -nargs=+  LGrep  call myfuncs#op_grep('Ex', <q-args>, 1)

" CheckHealth {{{2

if has('nvim')
    "                                      ┌ to set window-local options (so that sections are folded)
    "                                      │
    com! -bar CheckHealth checkhealth | do bufwinenter
endif

" Doc    {{{2

com! -bar -nargs=* Doc call s:doc(<f-args>)

fu! s:doc(...) abort
    if a:0 && (a:1 is# '--help' || a:1 is# '-h')
        echo printf("usage:\n    %s\n    %s\n    %s",
        \ ':Doc             word under cursor, scoped with current filetype',
        \ ':Doc div         keyword ''div'', scoped with current filetype',
        \ ':Doc html div    keyword ''div'', scoped with html'
        \ )
        return
    endif

    let cmd = 'xdg-open'
    " For the syntax of the query, see this link:
    "         https://devdocs.io/help#search
    let url = 'http://devdocs.io/?q='

    let args = a:0 ==# 0
           \ ?     url.&ft.' '.expand('<cword>')
           \ : a:0 ==# 1
           \ ?     url.&ft.' '.a:1
           \ :     url.join(a:000)

    sil! call system(cmd.' '.string(args))
endfu

" DiffLines {{{2

com! -bar -bang -range -nargs=? DiffLines call myfuncs#diff_lines(<bang>0, <line1>, <line2>, <q-args>)

" DiffOrig {{{2

" See differences between current buffer and original file.
com! -bar DiffOrig echo s:diff_orig()

fu! s:diff_orig() abort
    sil call save#toggle_auto(0)
    let cole_save = &l:cole
    setl cole=0

    let tempfile = tempname().'/Original File'
    exe 'vnew '.tempfile
    setl bt=nofile nobl noswf nowrap

    sil 0r #
    $d_
    setl noma ro

    nno  <buffer><nowait><silent>  q  :<c-u>close<cr>

    diffthis
    nno  <buffer><nowait><silent>  q  :<c-u>close<cr>
    let &ft = getbufvar('#', '&ft')

    let s:tmp_partial = function('s:diff_orig_restore_settings', [cole_save])
    augroup diff_orig_restore_settings
        au! * <buffer>
        au BufWipeOut <buffer> sil call save#toggle_auto(1)
        \ |                    call timer_start(0, s:tmp_partial)
    augroup END

    exe winnr('#').'windo diffthis'
    return ''
endfu

fu! s:diff_orig_restore_settings(cole,_) abort
    exe 'setl cole='.a:cole
    diffoff!
    norm! zvzz
    aug! diff_orig_restore_settings
    unlet s:tmp_partial
endfu

" DumpWiki {{{2
" Usage:
"         DumpWiki https://github.com/oniony/TMSU/

com! -bar -nargs=1 DumpWiki call myfuncs#dump_wiki(<q-args>)

" GotoChar {{{2

com! -bar -nargs=1 GotoChar call search('\m\%^\_.\{<args>}', 'es')

" Hex2Dec {{{2

" This command converts numbers from hex to decimal (and the reverse with
" a bang). It uses the shell command 'bc'. For example, if we type:
"
"     :Hex2Dec 2026
"
"         … sends to the shell:
"
"     $ echo "ibase=16;obase=A;2026" | bc
"
" And thus displays 8230.

com! -bar -bang -nargs=1 Hex2Dec echo expand('`echo "ibase='.(<bang>0 ? 'A' : '16')
\                                                 .';obase='.(<bang>0 ? '16' : 'A')
\                                                 .';'.<q-args>.'" | bc`')

" HlWeirdWhitespace {{{2

" Why don't you use an autocmd instead?{{{
"
" So, you're thinking about sth like this:
"
"     augroup strange_whitespace
"         au!
"         au WinEnter * call s:strange_whitespace()
"     augroup END
"
" Ok, but I wouldn't be able to disable the highlight in a 'fex_tree' buffer.
"
" The  same issue  would probably  apply to  other types  of buffers  (like help
" buffers), where I don't want this highlighting.
"
" The issue comes from the fact that when `WinEnter` is fired after a split, the
" current buffer is still the one displayed  in the original window, not the one
" which is going to be loaded.
" So this guard wouldn't work:
"
"     let bufnr = winbufnr(winnr())
"     if getbufvar(bufnr, '&ft', '') is# 'fex_tree'
"         return
"     endif
"
" MWE:
"
"     :LogEvents! WinEnter
"     :sp /tmp/file
"         → 12:34  WinEnter  /home/user/.vim/vimrc
"                            ^^^^^^^^^^^^^^^^^^^^^
"                            ✘ we would need `/tmp/file`,
"                              but the latter has not yet been loaded
"}}}
com! -bar -range=%  HlWeirdWhitespace  call s:hl_weird_whitespace()

fu! s:hl_weird_whitespace() abort
    if !exists('w:strange_whitespace')
        " https://vi.stackexchange.com/a/17697/17449
        let pat = '[\x0b\x0c\u00a0\u1680\u180e\u2000-\u200a\u2028\u202f\u205f\u3000\ufeff]'
        "                                     ├───────────┘
        "                                     └ yes, one can write an arbitrary range of unicode characters
        let w:strange_whitespace = matchadd('ErrorMsg', pat)
    else
        call matchdelete(w:strange_whitespace)
        unlet! w:strange_whitespace
    endif
endfu

" InANotInB {{{2

" This command outputs the lines which are in buffer A but not in buffer B.

" Why `<f-args>`?{{{
"
" A filename can contain whitespace.
"}}}
com! -bar -nargs=+ -complete=buffer InAButNotInB call myfuncs#in_A_not_in_B(<f-args>)

" IsPrime {{{2

com! -bar -nargs=1 IsPrime echo lg#math#is_prime(<args>)

" JoinBlocks {{{2

" The following command joins 2 blocks of lines.
" To use it, you must:
"
"     • remove possible empty lines between the blocks
"     • be on the 1st line of the 1st block
"     • provide the nr of lines of a block as an argument to the command
"
" After an initial join, you can repeat it with @:

" How it works?{{{
"
" If the blocks are 5 lines long, the command will execute:
"
"             ┌ for each line of the first block (.,.+4g/^/)
"     ┌───────┤
"     .,.+4g/^/''+5m.|-j
"              └────┤ └┤
"                   │  └─ then join the two lines
"                   │
"                   └ move the first line of the second block (''+5) under the current one (m.)


" We can notice that the address of the 1st line of the 1st block is expressed
" in 2 different ways, depending on the context.
" Inside the range passed to `:g` it's `.` (current line when `:g` starts).
" Inside the command executed by `:g`, it can't be `.` anymore (because the
" current line changes constantly), so here we use `''` instead.
" Indeed, before jumping to the first line to process, `:g` adds an entry in the
" jumplist, whose mark is `''`. So:
"
"             we're on the 1st line of the 1st block
"         and ''    is a line specifier for the latter
"         and a block has 5 lines
"
"         ⇒
"
"         ''+5    is a line specifier for the 1st line of the second block
"
" This shows that the range passed to `:g` is entirely processed BEFORE
" the command (here `:m`) it executes.
" Remember:
" `.` doesn't stand for the same line inside a range passed to `:g`, and inside
" a range passed to a command executed by the same `:g`.
" Also, if `:Ex`  is a command executed by `:g`  (`:g/pat/Ex`), inside `:Ex` you
" can use `''` to refer to the initial line when `:g` was started.


" `:g` will cycle through the lines of the 1st block, and always move + join
" the SAME line:
"
"         the 1st of the 2nd block
"
" But, the contents of this line will constantly change. It will be successively:
"
"     • the 1st of the 2nd block
"     • the 2nd one (after the 1st has been joined)
"     • the 3rd one ("         2nd ")
"     • the 4th one ("         3rd ")
"     • the 5th one ("         4rd ")
"
" Why `-j`, and not simply `j` ?
" Because, when `:m` moves a line, the cursor doesn't stay where it is; it jumps
" onto the moved line.
" So, before joining the lines, we have to get back on the original line above
" (`-` = `.-1`).
"}}}

" This command isn't really needed (we have `v_mj`), but I keep it for educational
" purpose.

com! -bar -bang -nargs=1 JoinBlocks
\ |                                 let &l:fen = 0
\ |                                 exe "keepp .,.+<args>-1g/^/''+<args>m.|-j<bang>"
\ |                                 let &l:fen = 1

" OnlySelection {{{2

" This command deletes everything except the current visual selection (or any
" arbitrary range).
"
" Usage:
"
"     :'<,'>OnlySelection
"     :12,34OnlySelection

com! -bar -range=% OnlySelection call myfuncs#only_selection(<line1>,<line2>)

" PluginsToCommit {{{2

com! -bar -nargs=0 PluginsToCommit  call s:plugins_to_commit()

fu! s:plugins_to_commit() abort
    let script = 'commit-these-vim-plugins.sh'
    if !executable(script)
        echom '[PluginsToCommit]: '.script.' is not available'
        return
    endif

    sil let output = systemlist('commit-these-vim-plugins.sh')
    if output == []
        echom '[PluginsToCommit]: nothing to commit'
        return
    endif

    call filter(output, {i,v -> v =~ '^\S'})
    call map(output, {i,v -> glob($HOME.'/.vim/plugged/'.v.'/*', 0, 1)[0]})
    call map(output, {i,v -> {'filename': v, 'valid': 1}})
    call setqflist(output)
    call setqflist([], 'a', {'title': 'Plugins to commit'})
    cw
endfu

" PluginGlobalVariables {{{2

" Usage:
"
" PluginGlobalVariables ulti
"
"         → display all global variables containing the keyword `ulti`

com! -bar -nargs=1 PluginGlobalVariables call myfuncs#plugin_global_variables(<q-args>)

" PA    PQ    populate arglist / qfl with shell command {{{2

" Usage:
"         :PA find /etc -name '*.conf'
"         :PQ grep -IRn foobar ~/.vim | grep -v backup

" We already have `:CGrep`, so why `:PQ`?{{{
"
"                                                                 ┌ TODO: sure? To confirm.
"                                                                 │
"                                                                 │ I think so, because we use `:cgetexpr`,
"                                                                 │ and not `:grep`.
"                                                                 │
" `:CGrep` (and `|g`) relies on the value of 'grepprg' (and 'efm' !!).
" `:PQ` gives us more control on the grep program.
" For example, it allows us to pass the argument `-w` to `$ ag`:
"
"        ┌────────────────┬────────────────────────────────────────┐
"        │ :CGrep     pat │ search any `pat` using   'grepprg'     │
"        ├────────────────┼────────────────────────────────────────┤
"        │ :PQ ag     pat │ search any `pat` using   `$ ag`        │
"        ├────────────────┼────────────────────────────────────────┤
"        │ :PQ ag -w  pat │ search a whole word `pat` using `$ ag` │
"        └────────────────┴────────────────────────────────────────┘
"                 -w --word-regexp
"                        Only match whole words.
"}}}
com! -bar -nargs=1 PA exe myfuncs#populate_list('arglist',  <q-args>)
com!      -nargs=1 PQ exe myfuncs#populate_list('quickfix', <q-args>)

" PI    Plugin Install {{{2

com! -bar -nargs=1 PI call myfuncs#plugin_install(<q-args>)

" PU    update Vim plugins {{{2

com! -bar PU call s:plugins_update()

fu! s:plugins_update() abort
    " :h spellfile-cleanup
    runtime spell/cleanadd.vim

    " Install `wfrench` package. Useful for dictionary completion.
    if expand('`aptitude show wfrench | sed -n "2p"`') =~? 'state:\s*not\s\+installed'
        echom 'Need to install the wfrench package for the french dictionary.'
        let password = inputsecret('Enter sudo password:')."\n"
        echo system('sudo -S aptitude install wfrench', password)
    endif

    if !isdirectory($HOME.'/.vim/tmp/snapshot')
        call mkdir($HOME.'/.vim/tmp/snapshot', 'p')
    endif
    "                                                                       ┌ put the month before the day
    "                                                                       │ so that, in the output of `$ ls`,
    "                                                                       │ the files are listed chronologically
    "                                                                       │
    exe 'PlugSnapshot! '.fnameescape($HOME.'/.vim/tmp/snapshot/'.strftime('%m-%d__%H-%M').'.vim')
    "                                                                               │
    "                                    don't put a colon, it could be problematic ┘
    " Why a colon is a bad idea in a filename?{{{
    "
    " 1. It's not inside  the default value of 'isf'. Which means  that Vim
    "   doesn't consider this character  to be a part  of a filename when
    "   using  `\f` in a pattern.
    "
    " 2. In most buffers, the local value of 'efm' probably uses the `%f` item
    "   to match a filename. Here's what `:h error-file-format` says about
    "   the latter:
    "
    " >       The "%f" conversion may depend on the current 'isfname' setting.
    "
    "   So, if you  try to parse the output  of a shell command, or  to read an
    "   error file/buffer  to populate the  qfl, Vim  will fail to  recognize a
    "   filename containing a colon. You'll get non-valid entries.
    "
    " 3. It's interpreted as a separator  in $PATH, so it can be dangerous if
    "   used in a directory.  And if we avoid the colon in a directory name,
    "   to stay consistent we should do the same in a filename.
    "
    " 4. It has a special meaning in  Windows, so if the file is copied on
    "   a different OS, it can cause an issue.
    "}}}
    " Which character are safe to use in a filename?{{{
    "
    "     [a-z]
    "     [A-Z]
    "     [0-9]
    "     .
    "     - (but not at the very beginning)
    "     _
    "
    " https://stackoverflow.com/a/458001/8243465
"}}}

    " wipe the Vim buffer containing the snapshot
    if getline(1) is# '" Generated by vim-plug'
        bw
    endif
    PlugUpgrade
    PlugUpdate
endfu

" RemoveDuplicateLines {{{2

com! -bar -range=% RemoveDuplicateLines exe myfuncs#remove_duplicate_lines(<line1>,<line2>)

" RemoveSwapFiles {{{2

com! -bar RemoveSwapFiles call s:remove_swapfiles()

fu! s:remove_swapfiles() abort
    for swapfile in glob($HOME.'/.vim/tmp/swap/*', 1, 1)
        call delete(swapfile)
    endfor
endfu

" RemoveTabs {{{2

" The purpose of this command is to replace all tab characters in the buffer
" with a nr of spaces which will occupy the same nr of cells.
"
" Before using it, set 'ts' (2,4,8) so that the text is aligned.
com! -bar -range=% RemoveTabs call myfuncs#remove_tabs(<line1>,<line2>)

" Retab {{{2

" The system :retab command substitutes all the tabs from a file to spaces.
" We don't want that. We want a command which substitutes only leading tabs.
"
" Besides, :retab automatically chooses which substitution to do based on the
" value of &expandtab:    &et ? spaces → tabs : tabs → spaces
" We prefer to manually decide the type of substitution.
"
" So, we define the custom command :Retab which accepts a bang.
" :Retab  = tabs   → spaces
" :Retab! = spaces → tabs
" Mnemonic: we use spaces as the default way to indent, so it makes sense to
" to use a bang only for the less useful conversion: spaces → tabs

com! -bar -bang -range=% Retab call s:retab(<line1>,<line2>, <bang>0)

fu! s:retab(line1, line2, bang) abort
    let view = winsaveview()
    if !a:bang
        exe 'sil keepj keepp '.a:line1.','.a:line2.'s:^\t\+:\=repeat(" ", &ts * len(submatch(0))):e'
    else
        exe 'sil keepj keepp '.a:line1.','.a:line2.'s:\v^( {'.&ts.'})+:\=repeat("\t", len(submatch(0))/&ts):e'
    endif
    call winrestview(view)
endfu

" ReverseEveryNLines {{{2

com! -bar -range=% -nargs=1 ReverseEveryNLines call s:reverse_every_n_lines(<args>, <line1>, <line2>)

fu! s:reverse_every_n_lines(n, line1, line2) abort
    let mods = 'keepj keepp'
    let range = a:line1.','.a:line2
    let l:Address = { -> ( line('.')- a:line1 + 1 ) % a:n ? ( line('.') - a:line1 + 1 ) % a:n : a:n }
    sil exe mods.' '.range.'g/^/exe "m .-".l:Address()'
endfu

" SearchInternalVariables {{{2

" The purpose of this command is to place the cursor on a line where it thinks
" we assigned a value to a variable whose name is the same as an internal
" variable.
" It could help us avoid conflicts.
" Whenever the command finds such variable (`key`, `char`, `lnum`, …), we
" should put it in an explicit scope (s:, l:, …).
"
" Update:
" In reality,  it seems that  Vim puts a variable  inside a function  (and whose
" scope is not explicit) inside `v:` only for a very narrow set of variables:
"
"     • count
"     • errmsg
"     • shell_error
"     • this_session
"     • version
"
" Source:
"     https://github.com/Kuniwak/vint/issues/245#issuecomment-337296606
"
" It seems to be true, if you look at this file:
"
"         https://github.com/vim/vim/blob/master/src/eval.c
"
" And if you search for 'VV_COMPAT', you only find these 5 variables atm.
"
" Maybe we could just memorize those 5 variable names, and eliminate the command.

com! -bar SearchInternalVariables call myfuncs#search_internal_variables()

" ShowLongLines {{{2

" This command highlights in red the character after a given column.
" Repeat the command toggles the highlighting.

com! -bar -nargs=? ShowLongLines echo s:shll(<args>)

fu! s:shll(...) abort
    if !exists('w:shll')
        let w:shll = matchadd('Error', '\v%'.((a:0 ? a:1 : 80)+1).'v', 20)
    else
        call matchdelete(w:shll)
        unlet w:shll
        if a:0
        " we've executed 2 `:ShowLongLines` commands, probably with different arguments
        " we've just get rid of the old match of the previous command,
        " now we need to create a new one for the 2nd command
            call s:shll(a:1)
        endif
    endif
    return ''
endfu

" SortLines {{{2

" Commented for the moment. Keep it for educational purpose.

" " We define the :SortLines command which moves lines containing foo or bar at
" " the bottom. Lines containing foo are put before the ones containing bar.
"
"     com! -bar -range=%  SortLines  call s:sort_lines(<line1>, <line2>)
"
"     fu! s:compare_lines(l1, l2) abort
"         " The greater the score, the further to the right in the sorted list
"         let score1 = a:l1=~ 'bar' ? 2 : a:l1 =~ 'foo'
"         let score2 = a:l2=~ 'bar' ? 2 : a:l2 =~ 'foo'
"         return score1 - score2
"     endfu
"
"     fu! s:sort_lines(line1, line2) abort
"         let sorted_lines = sort(getline(a:line1, a:line2), 's:compare_lines')
"         let c = 0
"         for line in sorted_lines
"             call setline(a:firstline + c, line)
"             let c+=1
"         endfor
"     endfu

" SumColumn {{{2

com! -bar -range SumColumn sil! keepj keepp <line1>,<line2>g/=\s*$/ t. | s/// | exe '.!bc' | -j

" TW {{{2

com! -bar -range=% TW call s:trim_whitespace(<line1>,<line2>)
fu! s:trim_whitespace(line1,line2) abort
    let view = winsaveview()
    exe 'keepj keepp '.a:line1.','.a:line2.'s/\s\+$//e'
    call winrestview(view)
endfu

" UnicodeToggle {{{2

" This command  looks for  special characters  \u or \U  + code  points (\u1234)
" inside the range of lines it received.
" If it  finds one,  it tries  to translate  all similar  ones into  the literal
" characters they stand for.
" If it doesn't find any \u...., it tries to do the reverse.
" Translate all characters whose code point  is above 255 (anything which is not
" in the extended ascii table) into special characters + code points.

com! -bar -range=% UnicodeToggle call myfuncs#unicode_toggle(<line1>,<line2>)

" WebPageRead {{{2

" this command opens a new tab page, loads a temporary buffer, and dumps
" the contents of a webpage inside the latter
com! -bar -nargs=1 WebPageRead call myfuncs#webpage_read(<q-args>)

" WordFrequency {{{2

" Display words in the current buffer sorted by frequency

com! -bar
\    -nargs=?
\    -range=%
\    -complete=custom,myfuncs#wf_complete
\            WordFrequency
\            call myfuncs#word_frequency(<line1>,<line2>, <q-args>)

" }}}1
" AUTOCMDS {{{1
" Warning: If you need to write an autocmd listening to `BufWritePost`, put it BEFORE the one reloading our vimrc.{{{
"
" Otherwise, if the pattern is `$MYVIMRC`,  it won't work, probably because when
" the vimrc is reloaded, the augroup it cleared.
" Yes, the autocmd is re-installed, but it's  a new one, which won't take effect
" immediately for the current `BufWritePost` event.
" It will be executed only for the next `BufWritePost`.
" At that point, the issue will repeat.
"
" MWE:
"
"     $ cat /tmp/vim.vim
"         augroup test_sth
"             au!
"             au  BufWritePost  /tmp/vim.vim  so %
"             au  BufWritePost  *             let g:d_ebug = get(g:, 'd_ebug', 0) + 1
"         augroup END
"
"     $ vim -Nu /tmp/vim.vim /tmp/vim.vim
"     :w
"     :echo d_ebug
"         → ✘ E121
"
" The issue disappears if you change the order of the autocmds.
"}}}

" Command Window {{{2

" Form more ideas:
" http://vim.wikia.com/wiki/Enhanced_command_window

augroup my_cmdline_window
    au!
    au CmdWinEnter * nno  <buffer><nowait><silent>  q      :<c-u>q<cr>
    au CmdWinEnter * nno  <buffer><nowait><silent>  ZZ     <cr>
    " Purpose:{{{
    "
    " By default,  C-c is useful to  quit the command-line  window, and populate
    " the command-line with the command which was being edited in the window.
    " But, it doesn't erases the command-line window.
    " Our `C-c` mapping takes care of that.
    "}}}
    au CmdWinEnter * nno  <buffer><expr><nowait>    <c-c>  '<c-c>'.timer_start(0, {-> execute('redraw')})[-1]

    " Purpose:{{{
    "
    " These  autocmds try  to update  the  command-line history  of the  current
    " session,  and  to   make  it  persist  across   sessions,  by  overwriting
    " `~/.viminfo`  every  time some  lines  were  deleted in  the  command-line
    " window.
    "}}}
    au CmdWinEnter : let s:old_cmd_hist = getline(1, line('$')-1)
    au CmdWinLeave : call s:update_history()
    "              │
    "              └ only Ex command-line window
augroup END

" If one day you want to add support for the search window (`q/`, `q?`), be aware that it's tricky.{{{
"
" It seems Vim merges both search history (/ + ?) in the window.
" Also, in `~/.viminfo`, an entry corresponding to a:
"
"         • forward  search,  begins with  `?/`
"         • backward search,  begins with  `? `  (note the space)
"}}}
fu! s:update_history() abort
    " update history of CURRENT session
    "                              remove any command 5 characters long or shorter ┐
    "                                                               ┌──────────────┤
    let new_hist = filter(getline(1, '$'), {i,v -> v !~# '^\s*$' && v !~# '^.\{,5}$'})
    call histdel(':')
    for line in new_hist
        call histadd(':', line)
    endfor

    " no need to try to update `~/.viminfo` if the latter isn't readable
    let viminfo = expand($HOME.'/.viminfo')
    if !filereadable(viminfo)
        return
    endif
    let info = readfile(viminfo)

    " FIXME:
    " One of the next 2 lines should probably be improved, because it seems to
    " fail to delete an entry containing a literal CR.
    "
    "                            ┌ take the old history
    "                            ├──────────────────┐
    let deleted_entries = filter(copy(s:old_cmd_hist), {i,v -> index(new_hist, v) ==# -1})
    "                                                          └───────────────────────┤
    "            ... and keep only the entries which aren't in the new history anymore ┘
    "
    " convert the text entries to delete, into their numeric indexes inside
    " the list `info`
    call map(deleted_entries, {i,v -> index(info, ':'.v)})

    " sort them, and check they were all found (no -1)
    call sort(filter(deleted_entries, {i,v -> v >= 0}))
    if empty(deleted_entries)
        return
    endif

    " Every time we  delete a line, the  addresses of the next  ones decrease by
    " one.
    " To avoid  having to update  the addresses  after each removal,  delete the
    " lines in reverse order.
    for entry in reverse(deleted_entries)
        call remove(info, entry, entry + 1)
    endfor
    call writefile(info, viminfo, 'b')
endfu

" Create Missing Directory {{{2

fu! s:make_missing_dir(file, buf) abort
    " Before creating a directory, make sure that the current buffer:
    "
    "     • is not a special one    :h special-buffers
    "     • is not a remote file    ftp://...
    "
    " Found here:    http://stackoverflow.com/a/4294176

    if empty(getbufvar(a:buf, '&buftype')) && a:file!~#'^\w\+:/'
        let dir = fnamemodify(a:file, ':h')
        if !isdirectory(dir)
            " TODO: if the directory is in a root directory, `mkdir()` will fail.
            " We would need to call `$ sudo mkdir`.
            call mkdir(dir, 'p')
        endif
    endif
endfu

augroup make_missing_dir
    au!
    au BufWritePre * call s:make_missing_dir(expand('<afile>:p'), expand('<abuf>'))
augroup END

" Default Extension {{{2

" Temporarily commented, because I find it annoying now with `.vim`.
" Keep it, because it could still be useful for other extensions.

" augroup DefaultExtension
"     au!
"     au BufNewFile * nested call s:default_extension(expand('<afile>:p'))
" augroup END

" fu! s:default_extension(buffer) abort
"
"     " If the buffer name ends with a dot, it's probably a mistake.
"     " We don't want to add a default extension.
"     " We would end up with a buffer whose name contains a sequence of
"     " consecutive dots.
"
"     if a:buffer[-1:-1] is# '.'
"         return
"     endif
"
"     " If the buffer is created inside /tmp and has no extension
"     if strpart(fnamemodify(a:buffer, ':p:h'),0,4) is# '/tmp' && empty(fnamemodify(a:buffer, ':e'))
"
"         " make sure it will be wiped when it's hidden
"         " which will happen after the next command
"         setlocal bufhidden=wipe
"
"         " edit a new buffer with the same name + the .vim extension
"         exe 'keepalt edit ' . fnameescape(a:buffer) . '.vim'
"
"         " Why fnameescape()? Suppose we type :e foo\ bar to open a buffer
"         " whose name is 'foo bar'.
"         " The function will receive as an argument 'foo bar' (the backslash
"         " has been removed once Vim processed the :edit command).
"         " Then, the previous instruction will result in: :edit foo bar.vim
"         " and Vim will complain with: E172: Only one file name allowed
"         " We have to reprotect the space with fnameescape().
"         "
"         " Security_measure:
"         " if the previous command fails without  giving an error, and we stay in
"         " our current buffer  whose 'bufhidden' option's local  value is 'wipe',
"         " we want to  remove the latter (so  that the global value  is used like
"         " before). If it fails with an error,  the rest of the function won't be
"         " executed though.
"         set bufhidden<
"
"     endif
" endfu

" Delete Noname Buffers {{{2

" We want to automatically delete buffers which are empty and don't have a name.
" So we install an autocmd listening to `BufHidden`.

augroup wipe_noname_buffers
    au!
    " Why delay `s:wipe_noname()`?{{{
    "
    " It seems the BufHidden event occurs just before a buffer becomes hidden.
    " Because of this, calling `s:wipe_noname()` immediately would wipe all noname
    " buffers, except the most recent one we're creating by closing its last window.
    "
    " We have to wait a little bit, to be sure that the last noname buffer we've
    " closed is really hidden.
    "
    " An alternative would be to call an intermediary function which would install
    " a fire-once autocmd listening to BufEnter (this event happens right after
    " BufHidden). At that moment, we could be sure the last hidden noname buffer
    " is really hidden. And the autocmd would just have to call `s:wipe_noname()`.
"}}}
    au BufHidden * call timer_start(0, {-> s:wipe_noname()})
augroup END

fu! s:wipe_noname() abort
    " do NOT wipe any buffer while a session is loading
    "
    " When we save a session, Vim writes some commands towards the beginning of
    " the session file, to check if the current buffer is a noname-empty buffer.
    " And towards the end, it wipes it.
    " If we load a session from a noname-empty buffer, it will become hidden,
    " our autocmd will kick in, this function will be invoked, and it will
    " wipe the buffer before the end of the restoration of the session.
    " This will cause an error, because Vim will try to wipe the buffer a 2nd
    " time while it doesn't exist anymore.

    if exists('g:SessionLoad')
        return
    endif

    " Source: http://stackoverflow.com/a/6561076
    let to_wipe = filter(range(1, bufnr('$')), { i,v ->
    \    buflisted(v)
    \ && empty(bufname(v))
    \ && empty(win_findbuf(v)) })
    "    │
    "    └─ make sure the buffer is NOT displayed in any window

    if !empty(to_wipe)
        sil! exe 'bw! '.join(to_wipe, ' ')
    endif
endfu

" Filetype Linter {{{2

" TODO:
" Instead of using a match, automatically populate the qfl, and place signs.
"     https://gist.github.com/BoltsJ/5942ecac7f0b0e9811749ef6e19d2176

" Purpose: get a warning when we make a typo in a filetype detection script {{{
"
" We often write something like this:
"
"     set sh
"
" Instead of:
"
"     set ft=sh
"}}}
augroup filetype_linter
    au!
    au WinEnter    filetype.vim,*/ftdetect/*.vim  call s:filetype_linter('enable')
    au BufWinLeave filetype.vim,*/ftdetect/*.vim  call s:filetype_linter('disable')
augroup END

fu! s:filetype_linter(action) abort
    if exists('w:my_filetype_linter')
        sil! call matchdelete(w:my_filetype_linter)
        unlet! w:my_filetype_linter
    endif
    if a:action is# 'enable'
        let pat = '\m\C\%(^\%(\s*"\)\@!.*\)\@<=\mset\s\+\%(ft\|filetype\)\@!'
        let w:my_filetype_linter = matchadd('ErrorMsg', pat)
    endif
endfu

" Jump Last Position {{{2

augroup jump_last_position
" Jump to last position when reopening a file
" taken from :h line()

    au!
    " FIXME:
    "
    " Why isn't the mark `"` always correctly updated?
    "
    " It's updated when we quit the last buffer of a Vim session.
    " It's updated when we quit a buffer whose window is not the last of a tab page.
    " It's NOT updated when we quit a buffer whose window is the last in a tab page.
    "
    " Because of this, the following autocmd often doesn't work.
    " Taken from `:h last-position-jump`:
    "
    "         au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
    "
    " The following could be a workaround:

    au BufReadPost * sil! norm! g`.zvzz

    " We use  g`.  to jump to the last edit, so that no entry is added in the jumplist.
    "
    " Although it doesn't make the same thing.
    " The old automcd was supposed to position the cursor where it was the
    " last time we quit the last window displaying a buffer.
    " The new one positions the cursor on the last edit.
augroup END

" Man pages {{{2

" We want to use Vim as a pager to read man pages in bash.
" To do so, we need to set the filetype when the buffer is a man page,
" so that ~/.vim/after/ftplugin/man.vim is loaded.
" When we open a man page, $MAN_PN is set with the name of the page (ex:
" man(1)).
" We can test its value to know if Vim has been launched to read a man page.
if !empty($MAN_PN)
    augroup man_pages
        au!
        " Why do we use an autocmd, instead of just writing the command:
        " setl ft=man | file $MAN_PN directly ?
        " Because it would be too soon, the buffer wouldn't be loaded yet.
        " We have to wait for the standard input to have been read completely.
        "
        " Why an augroup? Probably not necessary, but don't like an autocmd
        " outside an augroup.
        au StdinReadPost * setl ft=man
    augroup END
endif

" Read special files {{{2

" The following autocmd  allows us to read  special files like a pdf  or an odt.
" They use a few shell utilities as filter:
"
"       • antiword
"       • odt2txt
"       • pandoc
"       • pdftotext
"       • unrtf

augroup filter_special_file
    au!
    " Why not use `BufReadPost`?{{{
    "
    " It would indeed be more appropriate than `BufWinEnter`.
    " But  for some  reason,  Vim doesn't  fire `BufReadPost`  when  it reads  a
    " `.docx` or `.epub` file.
    "
    "     au BufReadPost  *.docx  sil %!pandoc -f docx -t markdown %:p:S
    "        ^
    "        ✘
    "
    " We could use `FileType tar`:
    "
    "     au FileType  tar  sil %!pandoc -f docx -t markdown %:p:S
    "
    " ... but $VIMRUNTIME/plugin/tarPlugin.vim would leave some undesired
    " messages inside the buffer; it's noise.
    " Maybe it's because the event is fired too early, and the built-in tar plugin
    " processes the buffer after the event.
    "}}}
    au BufWinEnter  *.{doc,docx,epub,odp,odt,pdf,rtf}  call s:filter_special_file()
augroup END

fu! s:filter_special_file() abort
    if get(b:, 'did_filter_special_file', 0)
        return
    endif

    let fname = expand('%:p:S')
    let ext = expand('%:e')
    let ext2cmd = {
        \ 'doc' : '%!antiword '.fname,
        \ 'docx': '%!pandoc -f docx -t markdown '.fname,
        \ 'epub': '%!pandoc -f epub -t markdown '.fname,
        \ 'odp' : '%!odt2txt '.fname,
        \ 'odt' : '%!odt2txt '.fname,
        \ 'pdf' : '%!pdftotext -nopgbrk -layout -q -eol unix '.fname.' -',
        \ 'rtf' : '%!unrtf --text',
        \ }

    if has_key(ext2cmd, ext)
        let filter = matchstr(ext2cmd[ext], '%!\zs\S*')
        if !executable(filter)
            echom 'cannot filter '.expand('%:p').'; please install '.filter
            return
        endif

        setl ma noro
        " About: '%!pdftotext -nopgbrk -layout -q -eol unix '.fname.' -'{{{
        "                                                             │
        "                                                             └ write output on STDOUT, which is piped to `par`
        "}}}
        " FIXME: Initially, we used the shell utility `fmt`:{{{
        "
        "     '%!pdftotext -nopgbrk -layout -q -eol unix '.fname.' - | fmt -w78'
        "
        " The formatting was awful (too much random spacing everywhere).
        " `par` gives a more readable text:
        "
        "     '%!pdftotext -nopgbrk -layout -q -eol unix '.fname.' - | par -w80rjeq'
        "
        " However, there are still errors.
        " Look at the bottom  of a `pdf` file, filtered by  `par`, to find error
        " messages. It's often  due to  a too long  “word” (more  precisely what
        " `par` considers a word). Because of this, a pdf is often truncated.
        " So, I don't use it atm.
        "
        " Try to  fix these errors  by learning  how to better  configure `par`,
        " through  command-line  options,  and/or through  `$PARINIT`. Then  use
        " `par` to format a pdf.
        "}}}
        sil exe ext2cmd[ext]
        let b:did_filter_special_file = 1
        setl bt=nofile noma noswf ro
    endif
endfu

" Reload config {{{2

augroup source_files
    au!
    " Why no `-merge`?{{{
    "
    " If you pass the `-merge` option to `xrdb`, the background color you choose
    " for urxvt won't be applied in xterm, because of this existing resource:
    "
    "         *customization: -color
    "
    " See `xrdb -query` to get a list of all existing resources.
    "}}}
    au BufWritePost  ~/.Xresources  sil call system('xrdb ~/.Xresources')
    au BufWritePost  ~/.vim/autoload/myfuncs.vim  exe 'source '.expand('<afile>:p')

    " Why shouldn't I write any autocmd listening to `BufWritePost` after this one?{{{
    "
    " see `Warning` at the beginning of our autocmd section.
    "}}}
    " Could I move the autocmd sourcing `myfuncs.vim` afterwards nonetheless?{{{
    "
    " Yes, because they are not triggered by the same filename.
    " When you write `myfuncs.vim`, this augroup is not cleared.
    " Still, don't do it.
    "}}}
    au BufWritePost  $MYVIMRC  exe 'source '.expand('<afile>:p')
augroup END

" Standard Input {{{2

augroup my_stdin
    au!
    au StdInReadPost * if line2byte(line('$')+1)<=2 | cquit | endif
augroup END

" Spell files {{{2

" It's not technically an autocmd, but it's the only section where it fits.
" It generates binary files on certain conditions, so it could be assimilated
" as an autocmd.
"
" When spell checking is enabled, and we mark a word as good or bad,
" we make an addition into `~/.vim/spell/fr.utf-8.`.
" But, for Vim to take this addition into account, it has to perform
" a successful check on the corresponding binary file `fr.utf-8.add.spl`.
"
" Versioning those binary files with git could cause pb (conflicts between
" different versions).

" When we switch to another machine, we should regenerates them with the
" `:mkspell!` command.
" The bang asks to overwrite an old binary if there's already one.
" So we do it here, for every spell binary file, but only if
" the binary (.add.spl) is older than the original addition file (.add).

fu! s:mkspell() abort
    for spell_file in glob('~/.vim/spell/*.add', 1, 1)
        if filereadable(spell_file) && !filereadable(spell_file.'.spl')
      \ || (getftime(spell_file) > getftime(spell_file.'.spl'))
            exe 'mkspell! '.fnameescape(spell_file)
        endif
    endfor
endfu
call s:mkspell()

" Why the for loop?
" Because there can be several spell files (one per language), in which we
" made additions.
"
" http://vi.stackexchange.com/a/5052/6960

" Swapfile Handling "{{{2

" What does it do?{{{
"
" It answers automatically to the question asked when a swapfile is found.
" If the swapfile is older than the  file, it's removed because useless, and the
" file is editd as if nothing happened.
"
" If the swapfile is newer, the file is opened in readonly mode, so that you can
" see its contents, but not change it (without being warned).
"}}}
" Why do you use this autocmd, instead of `set shm+=A`?{{{
"
" `set  shm+=A` would  completely bypass  the question  and the  existence of  a
" swapfile would never be brought to our attention.
"
" In contrast, this autocmd will still warn us whenever a swapfile is found, and
" write the warning in  the messages, so that we can review it  later if we need
" to debug some unexpected behavior from Vim.
"
" Besides, it won't let us edit a file for which a newer swapfile exists.
" There could be valuable information in there.
"}}}
" A swapfile has been found, and the file has been loaded in readonly mode!  What should I do?{{{
"
" If you only need to read it, nothing. Just read it.
"
" If you need to edit it, you have an issue.
" Indeed, if  the autocmd hasn't  removed the swapfile,  it means the  latter is
" more recent than the file (or has the same timestamp).
"
" So, it  could contain valuable  information, that  you need to  recover BEFORE
" doing any further change (because this valuable information may radically alter
" the change you intend to do).
"}}}
" How do I recover the contents of a swapfile?{{{
"
"     # recover swapfile
"     $ vim -r file
"
"     " save the result in another file
"     :write file.recovered
"
"     " load the original (unrecovered) file in readonly mode
"     " (this works thanks to our autocmd which should answer the question)
"     :e!
"
"     " show the differences between the original file and its recovered version
"     :diffsp file.recovered
"
" We have encapsulated this procedure in a zsh function (`vim_recover()`).
"
" If the recovered file looks good, you still have to execute:
"
"     $ mv file.recovered file
"
" See `:h 11.1` for more info.
"}}}

" (stolen from blueyed)
augroup swapfile_handling
    au!
    au SwapExists * call s:handle_swapfile(expand('<afile>:p'))
augroup END

fu! s:handle_swapfile(filename) abort
    " If swapfile is older than file itself, just get rid of it.
    if getftime(v:swapname) < getftime(a:filename)
        call s:warning_msg('Old swapfile detected, and deleted:   '.a:filename)
        call delete(v:swapname)
        let v:swapchoice = 'e'
    else
        call s:warning_msg('Swapfile detected, opening read-only:   '.a:filename)
        let v:swapchoice = 'o'
    endif
endfu

fu! s:warning_msg(msg) abort
    echohl WarningMsg
    " It seems that when `SwapExists` is fired, Vim executes `:echom` silently.
    unsilent echom a:msg
    echohl NONE
endfu

" Terminal {{{2

augroup my_terminal
    if has('nvim')
        au TermOpen * call s:setup_neovim_terminal()
    else
        au TerminalOpen  *  call s:setup_vim_terminal()
    endif
augroup END

fu! s:setup_vim_terminal() abort
    " Neovim automatically disables 'wrap' in a terminal buffer.
    " Not Vim. We do it in this function.
    setl nowrap
    call s:setup_neovim_terminal()
    exe 'nno  <buffer><nowait><silent>  p  i<c-e>'.&termwinkey.'""'
endfu

fu! s:setup_neovim_terminal() abort
    nno  <buffer><nowait><silent>  I   I<c-a>
    nno  <buffer><nowait><silent>  A   A<c-e>
    nno  <buffer><nowait><silent>  C   i<c-k>
    nno  <buffer><nowait><silent>  D   i<c-k><c-\><c-n>
    nno  <buffer><nowait><silent>  cc  i<c-e><c-u>
    nno  <buffer><nowait><silent>  dd  i<c-e><c-u><c-\><c-n>

    xno  <buffer><nowait><silent>  c  <nop>
    xno  <buffer><nowait><silent>  d  <nop>
    xno  <buffer><nowait><silent>  p  <nop>
    xno  <buffer><nowait><silent>  x  <nop>
endfu

" By default, a terminal buffer is not modifiable. We could change this with
" an autocmd. Useful to copy some text, and then paste it to execute it as a command.
" However, if we delete one or 2 lines, neovim may crash.
" So, for the moment, we don't want a terminal buffer to be modifiable.
" It may change in the future though:
"
"     https://github.com/neovim/neovim/issues/5431
"     https://github.com/neovim/neovim/pull/6142
"
" We can still paste text on the command-line though.
" No matter what we copy, no matter where we are, it will be put on the command
" line, without our cursor to move.

" if has('nvim')
"     augroup my_neovim_terminal
"         au!
"         DANGEROUS
"         au TermOpen * setlocal modifiable
"         DOESN'T WORK (why?)
"         au TermOpen * setlocal bufhidden=hide
"     augroup END
" endif

" Trailing Whitespace {{{2

" Trailing whitespace in red but not in insert mode, and not if the filetype
" is in the list:
let s:NO_TRAILING_WHITESPACE_FT = ['', 'git', 'help', 'qf']
" TODO: Prevent a match from being added in an fzf buffer.
" For some reason, adding 'fzf' in this list doesn't work.

augroup trailing_whitespace
    au!
    au WinEnter,InsertLeave * call s:trailing_whitespace(1)
    au InsertEnter          * call s:trailing_whitespace(0)
augroup END

fu! s:trailing_whitespace(create_match) abort
    if !a:create_match && exists('w:my_trailing_whitespace')
        call matchdelete(w:my_trailing_whitespace)
        unlet w:my_trailing_whitespace

    elseif a:create_match
       \ && !exists('w:my_trailing_whitespace')
       \ && index(s:NO_TRAILING_WHITESPACE_FT, &ft) ==# -1
        let w:my_trailing_whitespace = matchadd('Error', '\s\+$', -1)
    endif
endfu
" }}}1
" TO_DO {{{1

" *s/^\v%V"\s=\zs\d+\ze\s*-/\=submatch(0)-1/c
"
" 1 -
" We should never create special buffers:
"
"         vim /sil file/gj ~/.vim/**/*.vim ~/.vim/vimrc
"
" We should always use the qfl. The latter gives us more commands to interact.
" Exception:
" If you need some  kind of interactivity that a qf  window can't provide (think
" :PlugUpdate).
"
" 2 - solve the following pbs:
"
"    • join
"    • delete
"    • sort
"
" … every N lines.
" Write a command implementing each solution.
" Group the interface of the commands, with `:ReverseEveryNLines`.
" Try to infer some general principles underlying the solutions of this family
" of problems. For example:
"
"         when you perform an operation which changes the addresses of the lines
"         below, do it in reverse order
"
" 3 - move the cursor some lines down (cd) or up (cu).
" The motion bypasses all the lines which have an indentation level greater or
" equal than our current cursor position.
" Useful to move by logical blocks of code of the same level.
"
"        http://vi.stackexchange.com/a/213/6960
"        nno cd /\%<c-r>=virtcol('.')<cr>v\S<cr>
"        nno cu ?\%<c-r>=virtcol('.')<cr>v\S<cr>
"
" 4 - Vimcast, Episode 50, An introduction to vspec
"
"     https://github.com/junegunn/vader.vim (927 sloc)
"
"     http://whileimautomaton.net/2013/02/13211500
"     https://github.com/kana/vim-vspec
"     https://github.com/kana/vim-flavor
"     http://www.relishapp.com/kana/vim-flavor/docs
"
" 5 - Implement the concept of "narrowing region".
"
" A mapping, or command which would copy a range of lines in a temporary buffer.
" We could edit this temp buffer, and after writing it, the original selection
" would be replaced by it.
" There's a plugin for that:
"
"     https://github.com/chrisbra/NrrwRgn
"
" ... but the source code is too long (1500 sloc).
" Take inspiration from it.
"
" 6 - Implement ]n, ]s, ]u, ]x, ]y from unimpaired.vim
"
" 7 - Tmux navigation
" La navigation entre les panes de Tmux et les viewports de Vim n'est pas
" cohérente. Pour aller dans un pane Tmux depuis Vim, on peut taper C-{hjkl}.
" Mais en sens inverse (Tmux → Vim), il faut passer par le préfixe Tmux, pfx
" + hjkl.
" On a fait ça pour ne pas perdre les raccourcis readline dans le shell.
" On devrait peut être associer un keycode modificateur (Hyper?) sur la touche
" Super (ou la touche ctrl gauche?), et se servir de cette dernière pour naviguer
" entre Tmux et Vim: Super + {hjkl}.
"
" Plus généralement, revoir tout le code tmuxnavigator et repenser la
" navigation. Trop d'incohérences. Navigation entre onglets Vim, viewports
" Vim, panes Tmux, fenêtres Tmux, Tmux <-> Vim … C'est un gros bordel:
" AltGr-hl, C-hjkl, pfx-hjkl, M-hl
" Autre Idée:
"
"     C-hjkl             pour naviguer entre viewports et onglets  Vim.  (facile?)
"     Left Right Down Up "                   panes     et fenêtres Tmux. (difficile?)
"
" For the Tmux part, we would need to define conditional mappings.
" Maybe draw inspiration from here:
" http://stackoverflow.com/a/12380693
"
" Autre lien intéressant:
" https://silly-bytes.blogspot.fr/2016/06/seamlessly-vim-tmux-windowmanager_24.html
" Même raccourcis pour window manager, Tmux, vim
"
" 8 -
"
" créer des commandes pour fuzzy search la changeslist, et d'autres listes (via fzf).
"
" 9 -
"
"     https://github.com/hunspell/mythes
"     https://hunspell.github.io/
"     http://icon.shef.ac.uk/moby/mthes.html
"
" lire le code de:
"
"     https://github.com/beloglazov/vim-online-thesaurus/
"
" ajoute ça dans le vimrc:
"
"     plug 'beloglazov/vim-online-thesaurus'
"     let g:online_thesaurus_map_keys = 0
"
" très court (144 sloc).
" comme le plugin est court, on pourrait peut-être l'adapter pour le support
" du français.
" chercher un site équivalent à thesaurus.com pour le français.
" ou chercher une bdd de synonymes, et écrire un algo qui l'analyse:
"
"         http://www.dicollecte.org/download.php?prj=fr
"
" on pourrait aussi s'inspirer de la méthode du plugin pour ouvrir un split de
" taille dynamique, adapté à la taille des données à afficher.
"
" jeter un oeil aux liens suivants :
"
"         https://hyperdic.net/en/doc/antonyms (trouvé en cherchant "where can
"         i download antonym file" page 3)
"         https://github.com/emugel/vim-thesaurus-files
"
"         character-wise visual mode word lookup
"         https://github.com/beloglazov/vim-online-thesaurus/pull/31
"
" créer une méthode mucomplete qui s'en sert.
"
" 10 -
" in `vim-completion`, we have to choose between 2 problems.
" either we add `noselect` inside 'cot' and we break undo sequence.
" or we don't, but then, when we complete a word, if there're several
" candidates and we insert a character to reduce their nr, the popup menu closes.
" not sure there's a solution. make a choice. simplify `act_on_pumvisible()`.
" don't need to cover several cases, we only use one configuration of 'cot'.
"
" and btw, which value should we choose for 'cot' when we invoke standard
" completion methods manually?
"
" 11 -
" Why `:FzAg!` + `foobar` (in interactive mode) gives much more results than
" `:FzAg! foobar`?
" More generally, I don't know how `:ag` and `$ ag` interpret metacharacters.
" Make some tests, read doc.
" Example: compare `:FzAg! foo.*bar` and `:FzAg!` + `foo.*bar`
"
" I think `:FzAg! pattern` does not fuzzy search pattern, it performs
" a standard search (not fuzzy).
" OTOH, `:FzAg!` + `pattern` performs a live fuzzy search.
"
" 12 -
" use fzf (and/or fzf.vim) to create a mapping which would fuzzy search inside
" our abbreviations (including their {rhs}).
" it would be useful in a case such as this:
"
"     what's the abbreviation which expands into a command to search a character
"     in the unicode table?
"
"     {fzf mapping} → type keyword `unicode` → look for the right abbreviation
"                                            → `:ucs`
"
" 13 -
" extract big chunks of code from `myfuncs.vim` into separate plugins.
"
" 14 -
" read/bookmark/follow this:
"     https://github.com/neovim/neovim/wiki/following-head
"
" and read this:
"     https://neovim.io/doc/user/vim_diff.html#vim-differences
"     :h vim-differences (in neovim)
"
" ... in particular to improve our options
"
" 15 -
" read and integrate `:h slow-start` in our notes
"
" 16 -
"
"     :h /\@>
"
" … called “match without retry“ in `:h perl-patterns`, and “possessive matching“
" in perldoc.perl.org.
" it can be used to optimize a regex, or it can be necessary to describe the
" text we're interested in.
"
" for more info, see:
"     http://www.regular-expressions.info/possessive.html
"
" and :
"
"     http://perldoc.perl.org/perlre.html#extended-patterns
"
" this section is very long.
" to find what the excerpt dedicated to `(?>pattern)`, look right before the
" next section:
" http://perldoc.perl.org/perlre.html#special-backtracking-control-verbs
"
" basically, it's a type of quantifier.
" there are greedy quantifiers (`*`, `+`, …), non-greedy or lazy (`{-}`), and
" possessive (`@>`).
" the (non-)greedy ones control how to repeat a token, the possessive one
" prevents backtracking (`>` = move forward no matter what).
"
" 17 -
" implement a command which would show us the last keys typed.
"
" also, implement a mechanism which would analyze the log:
"
"     http://www.drbunsen.org/vim-croquet/
"     https://github.com/nelstrom/vimprint
"     http://vimcasts.org/blog/2013/05/vimprint---a-vim-keystroke-parser/
"
" 18 -
" https://github.com/lifepillar/vim-mucomplete/issues/59#issuecomment-293920115
"
" 19 -
" syntaxe à documenter (dans nos notes vim et awk):
"
" let myvar = other_var ==# 2    ⇔    let myvar = other_var ==# 2 ? 1 : 0
"                                                                 -------
"                                                                    |
"                                                                 inutile
"
" en viml, comme en awk, une comparaison est une expression dont la valeur est
" 1 si elle est vraie, 0 autrement.
"
" 20 -
" when replicating plugin cheat40, automatically set last motion with:
"
"     sil! call lg#motion#repeatable#make#set_last_used(']s', {'bwd': ',', 'fwd': ';'})
"
" this way, we can move along long lines with ; and ,
"
" 21 -
" integrate ~/Dropbox/wiki/diff.md into ~/Dropbox/wiki/vim/vim.md
" or into ~/Dropbox/wiki/admin.md
" yeah... maybe everything which is related to diff or vimdiff, put it inside
" admin
"
" 22 -
" http://blog.owen.cymru/fzf-ripgrep-navigate-with-bash-faster-than-ever-before/
"
" 23 -
" in a temporary directory, execute these shell commands:
"     touch file{1..3}; mkdir -p foo/{bar,baz}/{qux,norf}
"     tree -a | vipe
"
" look at the diagram. implement a mapping / command which would expand an
" abbreviation into this kind of diagram.
" for the abbreviation, we could take inspiration from the shell commands
" themselves. or sth else?
"
" a simple way of doing this would be to call just the `tree` command:
"     r !touch file{1..3}; mkdir -p foo/{bar,baz/qux}/{norf,abc}; tree -a
"
"     during the shell expansion `bar` and `baz/qux` are appended to `foo`
"     and `norf` and `abc` are appended to `foo/bar` and `foo/baz/qux`
"     so we end up with 4 (2*2) leaf directories + 4 intermediate directories
"     (foo, bar, baz, qux)
"
" but we would have to create a temporary directory, and temporarily `cd` to it
" to avoid polluting the current working directory.
" besides, we would have to protect all kind of special characters which could
" be present in the text we want to insert in the diagram.
"
" however, mkdir seems limited to produce a complex hierarchy.
" a better way would be to look at the syntax used by emmet to expand html
" tags. our mapping/command would parse a similar command to produce
" a hierarchy of items of an arbitrary complexity.
"
" also, have a look at the diagram in `:h syntax-loading`. very interesting.
" without this diagram, the explanations would be much more verbose, and less
" readable. implement a visual mapping, which would automatically draw the
" right diagram in front of the lines inside the selection (drawing `+`, `-`, `|`).
" ~/desktop/diagram
"
" also, install mappings to draw vertical diagrams instead of horizontal ones.
" have a look at our notes about the try conditional for an example where it
" would be useful.
"
" try this:
"
"         % api cpanminus
"         % sudo cpanm graph::easy
"
"         to uninstall later
"         % sudo cpanm --uninstall graph::easy
"
" write this in a file:
"
"         digraph {
"             start -> adsuck;
"             adsuck -> block;
"             block -> noop[label="yes"];
"             block -> unbound[label="no"];
"             noop -> serve_noop[label="yes"];
"             noop -> serve_empty[label="no"];
"         }
"
" visually select it, and type:
"
"         :'<,'>!graph-easy --as ascii
"                                      ^
"                                      don't add `%`
"                                      it would work, but if you have several digraph codes
"                                      in the current file, they will all be expanded, even
"                                      if you only select one in particular
"
" interesting links:
"         https://vi.stackexchange.com/a/541/13370
"         http://melp.nl/2013/08/flow-charts-in-code-enter-graphviz-and-the-dot-language/
"         https://github.com/wannesm/wmgraphviz.vim
"         man graph-easy
"
" update:
" this is really useful with vim-schlepp, and vim-draw.
" you create  the skeleton of  the diagram with  graph-easy, then tweak  it with
" vim-schlepp + vim-draw.
"
" also, remember we've  created the `:boxprettify` command. useful  to convert a
" raw ascii diagram, in a more polished one.
"
" 24 -
" look for mappings which would benefit from being made
" dot/semicolon/comma repeatable.
"
" 25 -
" :!  (bang) and  system() are not  interactive / show  ansi codes  (besides try
" `!cat`, `!restore-trash`)
"
"     if has('nvim')
"       cno  <expr>  !  getcmdtype() is# ':' && getcmdline() is# ''
"                   \ ?     '!tmux split-window -c '.getcwd().' '
"                   \ :     '!'
"     endif
"
" https://github.com/neovim/neovim/issues/1496
"
" 26 -
" when we try to paste a tmux buffer from insert mode (m-spc p), the indentation
" is increasingly wrong.
" the cause seems  to be 'autoindent'/'ai' which should  be temporarily disabled
" (and maybe temporarily enable 'paste'?).
"
" anyway, the  best solution is the  `tbone` plugin which provides  the commands
" `:tput` and `:tyank`, and gives a direct access to the tmux buffers.
" although, `:tput` isn't always accessible from a vim instance (think ultisnips
" docker) ...
"
" in `~/.tmux.conf`, we should rebind `pfx p` to temporarily disable 'ai'.
"
" edit:
" i've  removed   'autoindent'  from   vimrc. it  shouldn't   be  necessary. the
" indentation  should be  completely handled  by an  indent plugin.   if there's
" none, find an indent plugin. if it's wrong, find a better one.
"
" edit2:
" every popular vimrc which i'm watching sets 'ai', except justinmk's.
" should we reconsider 'ai'?
"
" edit3:
" i've restore 'ai'; let's see what happens.
"
" update:
" document the fact that the tmux buffers are especially useful when you work in
" a vim which wasn't compiled with the clipboard support (no `+` register).
"
" think docker ultisnips:
"
"     https://github.com/sirver/ultisnips/blob/master/contributing.md#running-using-docker
"     https://github.com/sirver/ultisnips/blob/master/contributing.md#reproducing-bugs
"
" 27 -
" protect all temporary change of option with `try|catch|endtry`.
" look for the pattern:
"
"         \v_save|save_|old_|_old
"
" do it in vimrc, myfuncs, plugins.
"
" for the replacement, use this construct:
"
"         preparations (like saving options)
"         try
"             do sth which can fail
"
"         catch
"             do sth if it fails
"             typically show error:
"
"                     echohl errormsg
"                     echom v:exception.' | '.v:throwpoint
"                     echohl none
"
"         finally
"             mandatory conclusion (like restoring options)
"         endtry
"
" 28 -
"
" re-read our snippet `op`, and refactor this section in our notes:
"
"         # mappings / abréviations
"       → ## opérateurs
"
" also:
" refactor all operators so that they remove  'unnamed' and 'unnamedplus'
" from 'cb', and set 'inclusive'
"
"         vim /\v%(opfunc|operatorfunc)\=\zs.*g\@/gj ~/.vim/**/*.vim ~/.vim/**/vim.snippets ~/.vim/vimrc
"         :cfilter! -other_plugins
"
" also:
"         catch
"             return lg#catch_error()
"
" also:
" what happens if you do:
"
"       op + v + motion
"
" i've just checked with `|gvj` (grep text from current position until next
" line, characterwise). and inside `op_grep()`, `a:type` is `char`, which is
" good. if it had been visual, we could have a problem, because our function
" would think we are operating from visual mode, instead of normal mode.
"
" to document.
"
" update:
" should we save/restore the visual marks, in all our plugins?
" yes: see what we did with the function called by the `dr` operator,
" and read the comments.
"
" should we yank with noautocmd to prevent our visual ring from saving
" a possible selection?
"
" 29 -
" create a mapping to populate command-line with `:ltag /`, then open the
" location window. ex:
"
        nno  <expr>  <c-g>t  <sid>ltag(1)
        fu! s:ltag(step) abort
            if a:step ==# 1
                augroup my_ltag
                    au!
                    " why the timer?{{{
                    "
                    " if we cancel, or the search fails to find anything,
                    " the fire-once autocmd will still be, wrongly, active.
                    " we should make sure to remove it with a timer, after
                    " a very short period of time.
                    "}}}
                    " still, syntax highlighting would work better.
                    " less hack, no timer.
                    au cmdlineleave : call timer_start(5, {-> execute("exe 'au! my_ltag' | aug! my_ltag", 'silent!')})
                    au filetype qf call s:ltag(2) | exe 'au! my_ltag' | aug! my_ltag
                augroup end
                return ':ltag / | lw'.repeat("\<left>", 5)
            elseif a:step ==# 2
                let pat = '|.\{-}|'
                " fixme:
                " it works if we press `gt`, which invokes this function.
                " but  if we  execute `:ltag`  manually, the  function won't  be
                " invoked, and the conceal won't be applied.
                " this brings an inconsistent user experience.
                " try to use a syntax highlighting file (inspiration: man plugin
                " in neovim).
                call qf#set_matches('vimrc:ltag', 'conceal', pat)
                call qf#create_matches()
            endif
        endfu
"
" update:
" it should probably be implemented as a cycle in `vim-cmdline`.
"
" also:
" play with `:tj / c-d`.
"
" it seems that `<space>ft` (fzf.vim) is identical to `:tj /`.
"
" 30 -
" shell function to grep a pattern and populate the qfl
" this one doesn't send the results to a vim server, and allows to pass
" arbitrary flags to grep
" https://www.reddit.com/r/vim/comments/6oj6gg/what_are_some_lesser_know_tips_and_tricks_in_vim/dki09wt/
" https://www.reddit.com/r/vim/comments/6oj6gg/what_are_some_lesser_know_tips_and_tricks_in_vim/dkiw87v/
"
" difference compared to our `nv()` shell function?
"
" 31 -
" read :h cscope (useful to list tags in qfl?)
" https://www.reddit.com/r/vim/comments/6p6uch/how_to_refactor_by_tags/dkn30bd/
"
" 32 -
" if we search a too complex pattern, `n` takes a long time to compute the nr
" of matches (total & current).
" the pb comes from this line:
"
"         let output = execute(a:range.'s///gen')
"
" it shows us a fondamental pb. how to prevent a command from taking too much
" time? here, we have a few solutions:
"
"         • try to guess by computing the nr of matches on a small range if it
"           goes beyond a certain threshold, we could report to the user that
"           there are too many matches
"
"           pb: most of the matches could be outside this small range
"
"         • refactor the code to use a while loop, and monitor the total time
"           taken after each iteration
"
"           pb: the while loop seems 6 times slower overall, compared to `s///gen`
"
" solution proposed by ingo:
"         :help catch-interrupt
"
" tweak the function so that we can interrupt it with c-c.
" don't use `echoerr` in the catch clause. it would raise an error (again).
" use `echo` (+ echohl if needed).
" ps: i've tried this solution but the message gets erased.
" to continue…
"
" 33 -
" use `:[c|l]bottom` in your jobs plugins (if they populate a qfl asynchronously)
"
" 34 -
" Re-implement these mappings to open the file you're editing on github.
" It could be handy when you want to see a commit you've just pushed.
"
"     nno <silent>  <space>og  V:<c-u>call <sid>open_current_file_in_github()<cr>
"     xno <silent>  <space>og  :<c-u>call <sid>open_current_file_in_github()<cr>
"
"     fu! s:open_current_file_in_github() abort
"       let file_dir = expand('%:h')
"       sil let git_root = system('cd ' . file_dir . '; git rev-parse --show-toplevel | tr -d "\n"')
"       let file_path = substitute(expand('%:p'), git_root . '/', '', '')
"       sil let branch = system('git symbolic-ref --short -q HEAD | tr -d "\n"')
"       sil let git_remote = system('cd ' . file_dir . '; git remote get-url origin')
"       let repo_path = matchstr(matchlist(git_remote, ':\(.*\)\.')[1], 'github\.com/\zs.*')
"       let url = 'https://github.com/' . repo_path . '/blob/' . branch . '/' . file_path
"       let first_line = getpos("'<")[1]
"       let url .= '#L' . first_line
"       let last_line = getpos("'>")[1]
"       if last_line != first_line | let url .= '-L' . last_line | endif
"       sil call system('xdg-open ' . url)
"     endfu
"
" Source:
"     https://www.reddit.com/r/vim/comments/9r3rcd/open_current_file_in_github/
"
" Update:
" `:Gbrowse` does sth similar.
"
"
" 35 -
" replace all occurrences of `norm ga` with appropriate code.
" do the same for other `norm` (ex: `norm gs`).
"
"         vim /\c\%(^\s*".*\|\<ono\>.*\)\@<!norm!\@!\>/gj ~/.vim/**/*.vim ~/.vim/vimrc
"         :cfilter! -other_plugins
"
" 36 -
" implement a global `:foldtoggle` command
"
" 37 -
" refactor all our functions which populate the qfl to offload work to a single
" function in `vim-qf`?
"
"         vim /set\%(qf\|loc\)list/gj ~/.vim/**/*.vim ~/.vim/vimrc
"
" 38 -
" restore  buffer-local  mappings, j  and  k,  if  they existed,  after  preview
" mappings teardown?
"
" 39 -
" the double invocation of `scroll_preview_mappings()` is neat.
" we don't create 2 functions, only 1.
" find where we should have done that. look for functions containing the keyword
" `maybe` or `later` (or look for aug\%[roup]!).
"
" 40 -
" https://github.com/chrisbra/vim_faq
"
" 41 -
" no need to check `if &bt  is# 'quickfix'` before applying conceal
" abort and/or try conditional are enough
" sure?
"
"         vim /if\s\+&bt\s\+is#\s\+'quickfix'/gj ~/.vim/**/*.vim ~/.vim/**/vim.snippets ~/.vim/vimrc
"
" 42 -
" https://github.com/justinmk/vim-dirvish/issues/62
" https://github.com/bounceme/remote-viewer/
" alternative:
" fuse/sshfs provides an abstraction at the filesystem layer (as opposed to some
" other "middleware"),  so that  any dumb local  navigator (like  dirvish) works
" without adding special-case support for scp, ftp, webdav, ..., netrw does.
"
" 43 -
" do we really need a timer to display a message?
"
"         vim /execute(.*echo/gj ~/.vim/**
"
" we haven't seriously taken into account `:redraw`.
"
" https://github.com/google/vim-searchindex/blob/28c509b9a6704620320ef74b902c064df61b731f/plugin/searchindex.vim#l187-l189
"
" make  more   tests,  take  into   account  all  relevant   parameters  (8*2=16
" environments), in vim and neovim:
"
"         • 'lz'
"         • :redraw
"         • <expr>
"         • timer
"
" once you're done:
"
"     :noa vim /timer_start(/gj ~/.vim/**/*.vim ~/.vim/**/vim.snippets ~/.vim/vimrc | cw
"
" look for all  the instances where we've  used a timer and where  we could have
" used a simple `:redraw`. replace the timer if it makes sense.
"
" note that in `vim-fex`, in `fex#print_metadata()`, we must use a `:redraw`,
" not a timer.
" otherwise,  the  first  part  of  the  message  is  correctly  displayed  (via
" `:echon`), but not the second one.
" this seems to indicate that a timer is not always the best solution to display
" a message.
" maybe we should use `:redraw` more often before an `:echo`.
"
" 44 -
"
" create mapping to send current line to terminal, and execute it
" use `g>` for the lhs?
"
"     g> + text object
"     g> on visual selection
"     g>> for line
"
" 45 -
" finish reviewing vim-math
" what insight can we gain from it?
"
" also:
" look at this:
"
"         https://github.com/sk1418/howmuch
"
" is there any functionality we could steal?
"
" 46 -
" finish reviewing ~/Dropbox/vim_plugins/pair_complete.vim
"
" 47 -
" we use `cml`, `cms`, in vimrc, myfuncs and in some of our plugins:
"
"         • iabbrev
"         • pair-complete
"         • titlecase
"
" it's  reliable  for programming  languages  where  the  cml must  be  repeated
" identically on every line of a  multi-line comment. what about the others (ex:
" c)?
"
" update:
" we should distinguish 2 problems.
" (un)commenting a line vs detecting whether a line is commented.
" we solved the 1st problem in `vim-comment`.
" for the 2nd one, try this expression:
"
"         synidattr(synidtrans(synid(line('.'), col('.'), 1)), 'name')  isnot#  'comment'
"
" 48 -
" it would be  convenient to have a  command which saves a  particular qfl/ll in
" `~/.viminfo`, and which could restore it when needed.
" Update: don't use viminfo (I don't trust this file)
"
" 49 -
" finish reviewing  the section in our  notes which deals with  string functions
" (match(), matchstr(),…); also talk about `matchstrpos()`
"
" finish reviewing indexage de chaîne
"
" 50 -
" check whether some commands would be better suited as mappings.
" and check whether some mappings would be better suited as commands.
"
" 51 -
"                                ┌ 3rd character of all `]o?` mappings
"         ┌──────────────────────┤
"         bcilnswacdfhilmnopqstvwz
"         echo map(range(65,90)+range(97,122), {i,v -> nr2char(v)})
"         echo filter(map(range(65,90)+range(97,122), {i,v -> nr2char(v)}), {i,v -> })
"              ^^^^^^^                                                    ^^^^^^^^^^^^
"              create a transformation to automatically add this
"              make it cycle between `filter()` and `map()`
"
" ~/.vim/plugged/vim-cmdline/autoload/cmdline.vim
" cmdline#transform() (bound to c-s)
"
" 52 -
" install autocmd listening to `bufreadpost */after/ftplugin/*.vim`
" which would install a buffer-local autocmd listening to `bufwritepost`
" which would give us a warning when we forget to undo a:
"
"         mapping/abbreviation/command/autocmd/variable
"
" or when we undo a non-existing …
"
" 53 -
" normalize underscore/hyphen in plug mappings, and function names in shell init files
"
" 54 -
" update the position of the mark in `vim-readline`
"
" mwe:
"
"     $ echo 'h|ello'
"              ^
"              cursor
"
"     press c-spc  (sets the mark right after the `h`)
"
"     $ |echo 'jjjjjjjjjjjjjjjjjjjhello'
"       ^      └─────────────────┤
"       │                        └ insert all of these
"       │
"       new cursor position
"
"     press c-x c-x  (exchange cursor and mark position)
"
" result:
" in bash:
"
"     $ echo 'j|jjjjjjjjjjjjjjjjjjhello'
"              ^
"              ✘
"
" in zsh:
"
"     $ echo 'j|jjjjjjjjjjjjjjjjjj|hello'
"                                 ^
"                                 ✔
"
" emulate `zsh` behavior.
"
" look for other mappings to implement, add them to a todo.
"
" 55 -
" should we add `:noa` every time we use `:wincmd`?
"
"
"     :vim /wincmd p\|call win_gotoid/gj ~/.vim/**/*.vim ~/.vim/vimrc
"     :cfilter! -not_my_plugins
"     :cfilter! -not_relevant
"     :cfilter! \<noa\>
"
" same question for `:[cl]open`, `:[cl]window`?
" why this 2nd question?
" `noa` was  useful in  `vim-interactive-lists` to  prevent the  original window
" from being  minimized when  it's a  middle horizontal viewport  (2nd of  3 for
" example).
" the issue, if there's one, may be with l[open|window] only.
"
" edit:
" i think  we should use  `:noa` whenever we temporarily  change the focus  to a
" window.
" also, you should try to avoid changing the focused window as much as possible.
" especially from an autocmd (can lead to hard-to-debug issues).
" if you have to,  then restore not only the currently  focused window, but also
" the previous one (so that `winnr('#')` and `wincmd p` are still reliable).
"
" update:
" maybe we should install a custom `:windo` command, and use it like so:
"
"     :123windo {cmd}
"
" `:windo` would try to cancel undesired effects.
" for example, it would restore the identity of the previous window.
" we would install it in `vim-lg`.
"
" update:
" use `lg#window#has_neighbor(dir,...)` as much as possible.
"
" it supports an optional argument standing for  the number of a window, so that
" we can  test the presence of  a window relative  to any window in  the current
" tabpage (not just the current one).
"
" 56 -
" check that whenever we use `wincmd p` we get to the right window.
" maybe we should use this instead:
"
"     let id = win_getid()
"     …
"     call win_gotoid(id)
"
" 57 -
" read all of this:
"     https://neovim.io/news/archive/
"
" 58 -
" read this:
" https://dev.to/idanarye/omnipytent-5g5l
" https://www.reddit.com/r/vim/comments/7kwlxc/omnipytent_plugin_explained/
" https://github.com/idanarye/vim-omnipytent
"
" 59 -
" read this (oop in viml):
" https://github.com/luchermitte/lh-vim-lib/blob/master/doc/oo.md
"
" 60 -
" replace `:silent!` with `:silent` whenever possible.
" there may be errors to fix which we are missing because they are silent.
" also, if you wonder whether a plugin/(auto)command/function is working
" as expected, and has no silent errors, use `:verbose` to increase
" the verbosity level.
"
" 61 -
" use syntax hl in `vim-qf` instead of complex mechanism using matches
" also, in `vim-qf`, fix the fixme in the autocmd `my_qf`
"
" 62 -
" add syntax hl in toc menu, and make content more relevant in help toc
"
" 63 -
" the toc  window may currently  be a little  too wide (see:  vim-qf, autoload/,
" qf#open()). we could  compute the longest line,  and set the width  of the toc
" window dynamically.
"
" 64 -
" move every function called from several scripts inside `vim-lg-lib`:
"
"     cmdline#reset_did_transform(
"     comment#object(
"     fold#md#sort#by_size(
"     fold#md#fde#stacked(
"     fold#md#fde#toggle(
"     fold#fdt#get(
"     qf#create_matches(
"     qf#open(
"     qf#set_matches(
"
" also, make  sure they  are self-contained. they must  not call  functions from
" one of our other plugins. if they do, move the latter inside `vim-lg-lib` too.
"
" 65 -
" implement a search ring, and install mappings to cycle through it
" useful to search for an old pattern without having to do `/ up …`
" (; and ,  would be more comfy)
"
" 66 -
" when you create a loclist, replace the  old one if its title is `breakdown` or
" `fix_me & to_do`.
" also, maybe create a mapping to show  the stack of location lists, and another
" to remove the current one.
"
" also,  if you  execute  `:wtf` several  times consecutively,  `vim-stacktrace`
" keeps recreating and adding the  same qfl. it shouldn't. it should replace the
" old one, or better leave it alone.
" to do so, it should remember the last qfl it produced, or the last `:messages`
" it parsed, or any information sufficient to know that there's no need to
" recreate a qfl.
"
" 67 -
"     spc fr    (:fzhistory)
"     escape
"     :tabnew
"
" a new tab page is correctly opened, but the focus stay in the same window,
" and the fzf buffer is replaced with the last visited buffer.
"
" 68 -
" create a submode to insert numbers more easily.
" ex:
"
"         ┌ enter “easy-number” submode
"     ┌───┤
"     c-g n u  →  1
"           i  →  2
"           o  →  3
"           j  →  4
"           k  →  5
"           l  →  6
"           ,  →  7
"           ;  →  8
"           :  →  9
"           !  →  0
"
" edit:
" maybe a submode is not the right concept, because of the timeout.
" maybe you should take inspiration from `vim-capslock`.
" create a mapping, which would toggle temporary mappings.
"
"     ino <expr><silent> <c-g>n  <sid>easy_number()
"
"     fu! s:easy_number() abort
"         if !empty(maparg('!', 'i'))
"             for l:key in ['!', 'u', 'i', 'o', 'j', 'k', 'l', ',', ';', ':']
"                 exe 'iunmap  <buffer>  '.l:key
"             endfor
"         else
"             let i = 0
"             for l:key in ['!', 'u', 'i', 'o', 'j', 'k', 'l', ',', ';', ':']
"                 exe 'ino  <buffer>  '.l:key.'  '.i
"                 let i += 1
"             endfor
"             augroup reset_easy_number
"                 au! * <buffer>
"                 au insertleave <buffer> call s:easy_number()
"                 \|                      au! reset_easy_number * <buffer>
"             augroup end
"         endif
"         return ''
"     endfu
"
" 69 -
" create a mapping to dump in the buffer information printed by a mapping
" prefixed with `-`. example: `-a`, `-p`
"
" maybe we should supercharge `c-r x` in insert mode?
"
" we should probably install some sort of wrapper around all `-x` mappings.
" like what we did to repeat motions.
" the wrapper would save the last `-x` mapping used, and `c-r x` would
" check this info to know what to dump.
"
" after dumping the info, it would delete it, the next time we execute
" an ex command to let us dump the output of the latter (via a fire-once
" autocmd listening to `cmdlineleave :`).
"
"  -8
"  -a
"  -f
"  -p
"
" update:
" try this:
"       <c-r>=execute('norm -a', 'silent!')<cr>
"
" 70 -
"
"     $ vim
"     :e /tmp/file
"     $ vim (a 2nd instance)
"     :try | e /tmp/file | catch | call lg#catch_error() | endtry
"
" if the file is already loaded in another instance, it will raise the error:
"         :h e325
"
" but the error won't be catched because vim prompts us with a question to know
" what we want to do (edit, quit, ...).
" worse, the question is not visible.
"
" solution: for the moment, press `e` to choose to edit the file.
"
" but this begs the question. how to deal with an error prompting us
" with a question? how to catch it properly?
"
" Update:
" we have the same issue in `~/.vim/plugged/vim-lg-lib/autoload/lg/window.vim`
"
"         if tabpagenr('$') ==# 1 && winnr('$') ==# 1
"             qall!
"                 ^
"                 we have to add a bang, to avoid an error message,
"                 when we press `spc q` to leave a vim instance
"                 with only one window and one unnamed and modified buffer.
"                 (although maybe we should use `:qall` without bang, and press
"                 `spc q`)
"
"                 if we wanted to use `:qall`, and catch a possible error:
"
"                     try
"                         qall
"                     catch
"                         return lg#catch_error()
"                     endtry
"
"                 we wouldn't see the error message (until we press enter?).
"
" Update:
" In  this particular  case  (there are  others?),  the solution  is  to use  an
" autocmd listening  to `SwapExists`,  and use `v:swapchoice`  to make  a choice
" automatically.
"
" Or, add the `A` flag to 'shm' to completely ignore the message.
"
" 71 -
" :h quickref
"
" 72 -
" play with (or document):
"
"    • 'filewinid' (location list property)
"    • 'user_data' entry in completion item
"    • 'varsofttabstop', 'vartabstop'
"    • :h matchadd(), new `window` key in optional dictionary
"    • :swapname
"    • :unl[et] ${env-name} (:h :unlet-$)
"    • appendbufline()
"
"    • argc() + argv()
"      in Vim, they can now access the global arglist and the local arglist of another window
"             https://github.com/vim/vim/releases/tag/v8.1.0493
"
"    • DiffUpdated
"    • api: buffer updates; https://github.com/neovim/neovim/commit/f85cbea725b4d21412dc0ddfd07239307b3b63a4
"    • cmdlinechanged
"    • deletebufline()
"    • diffupdate
"    • dirchanged
"    • exitpre
"    • getcompletion('*', 'arglist')   +   com! -complete=arglist ...
"    • getcwd(-1) return the global directory
"    • gettagstack(), settagstack()
"    • prompt-buffer
"    • reg_recording() + reg_executing()
"    • sign_define()
"    • sign_getdefined()
"    • sign_getplaced()
"    • sign_place()
"    • sign_undefined()
"    • sign_unplace()
"    • term_setansicolors(), term_getansicolors(), g:term_ansi_colors
"    • term_setsize()
"    • textchangedp
"    • trim()
"    • winlayout()
"
" 73 -
" in `vim-window`, don't do this:
"
"     let changelist = split(execute('changes'), '\n')
"     let b:my_change_position = index(changelist, matchstr(changelist, '^>'))
"
" instead do this:
"
"     let changelist = get(getchangelist('%'), 0, [])
"     let b:my_change_position = get(getchangelist('%'), 1, -1)
"
" requires the  new `getchangelist()` function,  which atm is not  implemented in
" neovim. wait for neovim to catch up.
"
" 74 -
" `vim-save`  is  really   small. move  it  in  vimrc,  or   in  another  plugin
" (vim-toggle-settings).
"
" 75 -
" prevent vim-session from checking swap files.
" annoying when a session crashed, and we can't restore a session.
" or disable swapfiles entirely:
"
"     set noswapfile
"
" 76 -
" In  neovim there's  a plugin  to open  a file  from a  terminal buffer  in the
" current neovim instance. But what about vim?
"
"     https://www.reddit.com/r/vim/comments/83ve6g/how_to_open_file_in_current_vim_instance_from/
"
" 77 -
" we have an issue with mappings which contain c-j (and c-m?) and which are made
" repeatable. for an example, look at `z c-j`.
" it doesn't work the first time it's invoked. but it works fine when you repeat
" it, with z, and z;.
" the issue is in the mapping:
"
"         n  z<nl>       * <snr>109_move('z<nl>')
"
" the newline probably breaks prematurely the invocation of the function.
" we could tweak the code to protect such a special character with `<lt>`.
" but then we would need to translate `<c-j>` manually.
"
" 78 -
" read:
"
"     :h syntax.txt     (not that big once you remove part 4: :h syn-file-remarks
"                        you're not supposed to read entirely anyway, only the ones
"                        matching the types of files you use frequently;
"                        to get a list:    :h ft-*-syn c-d)
"     :h sign.txt
"     :h tagsrch.txt
"
"     :h channel.txt
"
"     :h textprop.txt
"     :h diff.txt
"     :h terminal.txt
"     :h recover.txt
"     :h tips.txt
"     :h if_lua.txt
"     :h if_pyth.txt
"
" 79 -
" study ~/Dropbox/vim_plugins/fastfold.vim
"
" 80 -
" in ~/Dropbox/wiki/vim/viml.md, look for the pattern `funcref()`.
" there are 2 codes side-by-side.
" they are separated with `┊` characters.
" if you press `+sip` on the code, only the one on the left is sourced.
"
" this is neat.
" try to develop this mechanism.
" for example, we could have a mapping which toggles which part is sourced,
" the one on the left or the one on the right.
"
" also, when we  source the code on the  right, in a line ending with  `┊ "`, we
" could make `vim-source` replace the double quote  with the code on the left of
" `┊`.
"
"
" 81 -
" feature requests:
"
"      • a function to detect the pager is active, to customize the mappings
"        interacting with the pager
"
"        would it be enough?
"
"      • :prof dump and :prof stop
"         https://github.com/neovim/neovim/pull/2427
"
"      • being able to customize `c-k` when a dictionary completion is active
"        (same thing for other completions: c-t, c-d, c-l, ...)
"
"      • a function to get the owner/group of a file
"
"      • adding an option to `getfsize()` to get a human readable result
"
" 82 -
" if we press  c-g by accident on  the command-line, and we move  forward in the
" cycle, we should be able to undo and recover the previous command with c-_.
"
" also, we should have multiple tabstops (not just one).
" useful for a command like:
"
"         noa vim //gj `find . -type f -cmin -60` | cw
"                 ^                           ^
"                 tabstop 1                   tabstop 2
"
" also:
"
"     c-g f
"         → :verb filter // map
"         ✔
"
"     insert `foo`
"         → :verb filter /foo/ map
"         ✔
"
"     c-g
"         → :noa vim //gj ~/.vim/**/*.vim ~/.vim/**/vim.snippets ~/.vim/vimrc | cw
"         ✘
"         we should get the next command in the original (!= default) cycle:
"
"                 :verb filter // ab
"
" 83 -
" To document.
" If neovim is unable to suggest suggestions to fix spelling errors,
" start it like this:
"
"         $ nvim -nu norc
"
" write a word with a spelling error:
"
"         helzo
"
" then execute `:set spell`.
" IT should make neovim download some missing files (i don't know where).
" for more info:
"
"     https://github.com/neovim/neovim/issues/7694
"     https://github.com/neovim/neovim/issues/7189
"
" Also, for debugging purpose, try `:spellinfo`.
"
" 84 -
" Maybe we could install a wrapper command  (:filter) which would do the job for
" the commands which are not supported.
" See `:h  :index`, and  search for  all the commands  which could  benefit from
" `:filter`:
"
"         :args
"         :autocmd
"         :augroup
"         :changes
"         :clist (:llist)
"         :function
"         :ilist (:dlist, :isearch?, :dsearch?)
"         :history
"         :marks
"         :reg
"         :tags
"
" also, create a complete cycle (c-g f).
"
" 85 -
"
"     :vim /^>\|^\%u00a0/gj ~/Dropbox/wiki/**/*.md
"
" in our notes, we sometimes use `>` or a non-breaking space at the beginning of
" a line to quote some text, or apply some style.
" check whether everything works as expected.
" also, we shouldn't need to insert a non-breaking space, it's a hack.
" find another way to get the same result.
"
" 86 -
"
" in   `vim-qf`,  maybe   we  could   reduce  the   number  of   invocations  to
" `s:setqflist()`:
"
"         call s:setqflist(list, action)
"         call s:setqflist([], 'a', {'title': 'hello'})
"         →
"         call s:setqflist([], action, {'items': list, 'title': 'hello'})
"
" in fact,  maybe we could  simplify the code  much more, because  using 'items'
" doesn't alter the title. so, maybe there's no need to save/restore the latter:
"
"         call s:setqflist([], action, {'items': list})
"
" 87 -
" how to filter  a custom text-object without the command-line not being redrawn?
" mwe:
"         !ie spc
"         ![m spc
"         ...
"
" we could try sth like this:
"
"         ono  <silent>  ie  :<c-u>exe 'norm vie'.(v:operator is# '!' ? '<space>' : '')<cr>
"
" but, why does the issue occur with `![m`, but not with `![z`?
"
" update:
" it probably has sth to do with these functions:
"
"    • fold#motion#go()     (✔)   ~/.vim/plugged/vim-fold/autoload/fold.vim:33
"    • lg#motion#regex#go() (✘)   ~/.vim/plugged/vim-lg-lib/autoload/lg/motion/regex.vim:1
"
" update:
" it has to do with the `<silent>` argument in the mapping.
" we need it in all modes except in operator-pending mode.
" alternatively, we could include at the end of `lg#motion#regex#go()`:
"
"         exe 'norm! '.line('.').'g'
"
" it would not make the cursor move, but it would make the command-line redrawn.
" mwe:
"
"         map  <silent>  ]g  :call search('pat')<cr>
"             !]g → command-line not redrawn
"
"         map  <silent>  ]g  :call search('pat') <bar> exe 'norm! '.line('.').'g'<cr>
"             !]g → command-line redrawn
"
" it seems `vim-textobj-user` doesn't suffer from this issue:
"
"         " unmap pre-existing `o_ie` mapping
"         call textobj#user#plugin('entire_buffer', {
"         \   'code': {
"         \     'pattern': ['\%^.', '.\%$'],
"         \     'select-a': 'ae',
"         \     'select-i': 'ie',
"         \   },
"         \ })
"
" you  should  try   to  better  understand  this  issue   when  you  assimilate
" `vim-textobj-user`, and  fix it every  time you defined  a text object  in the
" past.
"
" 88 -
" document `$ paste` as a filter:
"
"         https://vi.stackexchange.com/a/16096/17270
"
" also, make some cleaning in our mappings:
"
"    • x_gj      join lines
"    • x_gc-j    join lines without inserting/removing spaces
"    • x_mj      join two blocks
"    • x_mc-j    join two blocks in reverse order
"
" are they consistent?
" could we make them easier to remember?
"
" 89 -
" implement a mapping/command to extract the lines which are present in a block,
" but not in the other.
" `:inabutnotinb` is too cumbersome.
"
" 90 -
"
"     $ shell_cmd | vim +'setf dirvish' -
"
" if i press `x` several times on a  file in a dirvish buffer, the file is added
" several times in the arglist: it should not.
" also, `q` doesn't work and there's no conceal.
"
" solution:
"     $ shell_cmd | vim +'call dirvish#open("")' -
"
"
" there's no `b:undo_ftplugin`: there should be.
" Update: too hard; it breaks the code (some autoloaded function
" needs `b:dirvish` for example)
"
"
" use `cmdlineleave` instead of remapping `/` and `?`.
" this way the anchor at the end is never visible (noise, distracting).
" hide it behind an option for a pr.
"
" update:
" two issues:
"
"    1. you can't prevent the initial search (the one without `\ze`)
"
"    2. you can't make the autocmd local to a buffer;
"    you can only inspect `get(b:, 'current_syntax', '')` and compare it to 'dirvish'
"    but the autocmd will still be global.
"
" 91 -
" we should remove `cop` mapping in `vim-help`.
" it's not consistent with how we use the preview window in other plugins.
" instead, install these mappings:
"
"    • p preview tag under cursor
"    • } preview next tag
"    • { preview previous tag
"
" 92 -
" should we enable  'ttyfast'? it's useless with current terminal,  but could be
" useful in a future one. useless in neovim, because it's always enabled there.
"
" 93 -
" sometimes, when we  move in the qfl while  the qf window is open  we don't see
" where we are in the qfl.
" why doesn't vim  echo anything on the  command-line, like it does  when the qf
" window is closed?
"
" update:
" the fact that we prefix a lot of our commands with `:noa` has an effect on the
" issue:
"
"         noa vim /pattern/j $VIMRUNTIME/**/*.vim | cw
"             → no indicator in the statusline because of `:noa`
"
" 94 -
" try to remove as many `virtcol()` as possible everywhere.
" same thing for `\%v`.
" they don't mean what we thought.
" if `virtcol('.')` evaluates to `123`, it doesn't mean:
"
" >   the next character is the 123th on the line
"
" but:
"
" >   the next character occupies the 123th column on the line
"
" `virtcol()` and `\%v` are influenced by some options ('wrap', 'linebreak', ...).
"
" although, i  guess it's ok  to use  them when you're  sure your lines  are not
" wrapped.
"
" 95 -
" every time we populate a qfl from a script, we should save the command we used
" with the 'context' qf property.
" we could use it  to refresh a qfl, using a custom  mapping which would inspect
" the value of 'context'.
" the mapping would re-execute the command and  replace the old qfl with the new
" one.
"
" 96 -
"
" remove `\v` (very magic in regex) everywhere.
"
" 97 -
" try to avoid `:s`, prefer `setline()` and `substitute()`.
"
"     noa vim /keep[jp]/gj ~/.vim/**/*.vim ~/.vim/**/vim.snippets ~/.vim/vimrc | cw
"
" 98 -
" develop a design to quickly handle a temp special buffer:
"
"    • layout
"
"    • local settings & mappings
"    think about using {, }, (, ), and maybe [[, ]]
"
"    • syntax highlighting
"    • filetype detection
"    • automatic population (persistent after `:e`)
"    • proper path/name
"    • handle multiple invocations (there should be always only 1 (updated) window)
"
" if you want the buffer to be  reloadable, do not populate it directly from the
" function called by a mapping.
" it should be populated from an autocmd (maybe listening to bufnewfile).
" if the autocmd needs some additional info, make it inspect the name of the buffer,
" and use the latter to pass the info.
" look at what we did with `:tree` for inspiration.
"
" update:
" if you don't need to interact with the temp buffer, only read it, make it use
" a preview window:
"
"     let &l:pvw = 1
"
" update:
"
" open a tree buffer, then press `--`.
"
"     dirvish: invalid directory: '/tmp/vu4npgy/1/tree_explorer::/home/user'
"
" we've made the same error in other places:
"
"     noa vim /tempname().'\//gj ~/.vim/**/*.vim ~/.vim/**/vim.snippets ~/.vim/vimrc | cw
"
" should we emit `bufwritepre`? does it make sense considering we set `bt=nofile`?
"
" the missing directory should have been created.
" it probably has not because `bufwritepre`  (which is listened to by an autocmd
" in the group `make_missing_dir`) has not been fired.
"
" it doesn't make sense to view the contents of the current directory.
" from a buffer associated to no file, there's no current directory.
"
" update:
" once we've come up with a design, formalize it somewhere.
" atm, maybe you should  do it in our notes; however, in  the future, you should
" probably do it in a set of snippets/templates/...
" also, maybe you should use `vim-projectionist` to enforce a design.
"
" update:
"
"     :vim /setl.*bt=nofile/gj ~/.vim/**/*.vim ~/.vim/**/vim.snippets ~/.vim/vimrc
"
" visit all matches. bring consistency in the  way we create a temporary buffer,
" including how we set the geometry of the window.
" also look at our snippet.
"
" 99 -
" maybe extract cycles from `vim-cmdline` (if there's enough code);
" it would make the maintenance easier (for debugging and adding new features)
"
" also, try to use `textchangedi` to implement sth similar to `complete()` in
" ultisnips. it would be useful when there're too many similar commands in a cycle:
"
"     :verb filter // [map|ab|%#|com|old|chi|mess|scr|ls]
"     :verb filter // m[ap|ess]
"     :verb filter // mess
"
" here we would install a temporary autocmd when we enter the cycle which would
" inspect the end of the command-line.
" we would need to  change the signature of the function we  call to install the
" cycle, to have a way to let it  know that we want all candidates dumped on the
" command-line at once and a form of completion.
"
" 100 -
" gf, c-w f, c-w gf should also be able to parse a column number.
" it would be useful in the qf window.
" see here for inspiration:
"
"     https://github.com/wsdjeg/vim-fetch
"
" we could write a wrapper around these normal commands which would return
" the keys pressed, and start a timer which would execute `:norm` to position
" the cursor on the right column, if a column has been detected after the path.
"
" see also this:
"
"     https://github.com/kana/vim-gf-user/blob/master/doc/gf-user.txt
"
" also, they should be able to parse a reference link in a markdown buffer:
"
"     [description][123]
"     ...
"     [123]: link
"
" 101 -
" finish implementing `!t` (timer info)
"
" add syntax highlighting, additional info, mappings, ...
" also, create a mapping to interactively (un)pause/stop a timer.
"
" also, do the same for matches (`getmatches()` + `matcharg()`).
" use `! c-m` for the lhs of the mapping?
"          ^
"          getmatches
"
" or, supercharge `!s`, so that when there's no syntax item under the cursor, it
" falls back on the matches.
" also, do the same for these functions:
"
"     getbufinfo()		get a list with buffer information
"     gettabinfo()		get a list with tab page information
"     getwininfo()		get a list with window information
"     ch_info()                 get channel information (find the equivalent in neovim)
"     job_info()                get information about a job (find the equivalent in neovim)
"
" btw:
" the 'lnum'  and 'windows' key in  the output of getbufinfo(...)[...]  are very
" interesting.
"
" 102 -
" check which mappings could be supercharged using `v:count`:
"
"     nno  <silent>  cd  :<c-u>call func(v:count)<cr>
"     fu! func(cnt) abort
"         echo a:cnt ? 'hello' : 'world'
"     endfu
"
" and check which mappings could benefit from being passed a count.
" see what we did with `!w` (:wtf), and `spc t` (:tabnew).
" basically,  any  mapping which  calls  an  ex  command accepting  a  numerical
" argument, or a bang, could be passed the latter via `v:count`.
"
" 103 -
" currently, `:freekeys` ignores free sequences beginning with `m`, `'` and `@`.
" this is because it thinks it would introduce a timeout with some of our custom
" mappings.
" in reality, there would no timeout, because `m`, `'` and `@` mappings are special:
" they ask for an argument.
" check whether we have other similar special mappings causing `:freekeys` to ignore
" whole families of mappings:
"
"     verb filter /^.$/ map
"     g/last set from/d_
"     g/^<plug>/d_
"
" how to handle the issue?
" either  tweak the  code  of `vim-freekeys`,  or take  the  habit of  executing
" `:freekeys -nomapcheck` (we've added a `-k` mapping for that).
"
" 104 -
" https://github.com/ardagnir/athame
" https://github.com/ardagnir/athame/issues/52
"
" > full vim for your shell (bash, zsh, gdb, python, etc)
"
" could be used to expand ultisnips snippets in the shell.
"
" 105 -
" in dirvish/fex, maybe  we should use `--`  and `++` instead of `h`  and `l` to
" move in the hierarchy.
" issue:
" it would break consistency with `ranger`.
" we would need to rebind these ranger mappings (found by pressing `?` then `k`):
"
"     h move left=1
"     l move right=1
"
" 106 -
" extract the code dedicated to templates from `vim-unix`.
" make it able to evaluate viml (i.e. dynamic templates).
"
" 107 -
" rethink the following mappings:
"
"    • gt, gt (could be better used to move the current tabpage, instead of >t, <t)
"    but what would we use to populate the location list with to_do's and fix_me's?
"
"    • zj (could be used to join a window to a tabpage, instead of c-n; symmetry with zt)
"
" 108 -
" in python files, we  can use multi-line comments with a  pair of triple double
" quotes.
" but they aren't properly concealed in a fold title, nor in the unfolded buffer.
"
" also, should we use them more often?
" review the comments in `~/.vim/plugged/vim-snippets/pythonx/snippet_helpers.py:442`.
"
" also, finish restructuring our notes in `vim-snippets`. too many scattered files.
"
" read:
" https://google.github.io/styleguide/pyguide.html?showone=comments#comments
" https://jeffknupp.com/blog/2016/12/09/how-python-linters-will-save-your-large-python-project/
"
" https://pylint.readthedocs.io/en/latest/
" https://pycodestyle.readthedocs.io/en/latest/
" http://www.pydocstyle.org/en/latest/
"
" learn how to configure, use, integrate the following linters:
"
"    • pylint
"    • pycodestyle
"    • pydocstyle
"
" this command populates a default config file for `pylint`:
"
"     $ pylint --generate-rcfile >>~/.pylintrc
"
" 109 -
"     :vert term [++cols=20]
"
" wrong terminal height (big command-line).
"
" 110 -
" once neovim has `reg_recording()`, use it in all `q` mappings:
"
"     noa vim /nno.*\<q\>/gj ~/.vim/**/*.vim ~/.vim/**/*.snippets ~/.vim/vimrc | cw
"
" so that we can end a recording without closing the window.
"
" 111 -
" we should use more abbreviations.
" review the triggers:
"
"    • are they well chosen?
"    • should you remove some of them?
"    • should you add more?
"
"         use `:wordfrequency`, but if you find a frequent word (like 'result'),
"         it doesn't necessarily mean you should create an abbreviation just for
"         it;
"
"         maybe it's frequently  used in a group of words  (like 'as a result');
"         look for it  in your file, and  see in which context  it's used before
"         creating the abbreviation
"
" maybe eliminate french.
" move the functions in a dedicated file.
" implement  a   `-A`  mapping   showing  the   available  abbreviations   in  a
" sidebar/cheatsheet. show only the less well known at any given time.
"
" 112 -
" atm, `:fzfiles` doesn't search hidden files/directories.
" solution:
"
"     let $fzf_default_command = 'ag --hidden --ignore .git -g ""'
"
" see also:
"
"     https://github.com/junegunn/fzf.vim/issues/226
"
" 113 -
" try to make some existing mappings smarter by reacting differently
" when we're at the more prompt (see `:h mode()`, `rm` mode).
"
" 114 -
" should we  remap '@' so  that when we  replay a macro  the `esc` key  is never
" interpreted as a part of a function-like (f1, arrow, ...) key?
"
"         set noesckeys
"         @macro
"         set esckeys
"
" pro:
" it would fix this kind of issue:
"
"         https://vi.stackexchange.com/a/17193/17449
"
" con:
" we would need to be sure that 'esckeys' is re-enabled.
" also,  it would prevent  to use function-like keys  during the recording  of a
" macro.
"
" 115 -
" i think there's  no need to escape (so that the visual  marks are set) to know
" where the visual selection begins/ends.
" you can use `getpos('v')`, and `line('.')`:
"
"         xno  <silent><expr>  <c-a>  func()
"         fu! func() abort
"             let lnums = [getpos('v')[1], line('.')]
"             echom 'the visual selection starts at line '.min(lnums).' and ends at line '.max(lnums)
"         endfu
"
" try to use this technique in your plugin(s) instead of escaping.
" unless they really need to update the visual marks.
"
" 116 -
" document  the fact  that if  a message  is erased  right after  being printed,
" there's no need to invoke a timer, a simple `:redraw` may be enough.
"
"     " ✘
"     call timer_start(0, {-> execute('pwd', '')})
"
"     " ✔
"     redraw
"     pwd
"
" see `:h :echo-redraw`.
"
" 117 -
" search for `[ spc`, `spc ]`, `{ spc`, `spc }`, `^\s*\\` everywhere.
" refactor the style.
"     noa vim /\[ \| \]\|{ \| }\|^\s*\\/gj ~/.vim/**/*.vim ~/.vim/**/*.snippets ~/.vim/vimrc | cw
"
" 118 -
" Search for `g@` everywhere.
" Do you need to save and restore the unnamed register, and the options every time?
" Should  we refactor the snippets  so that it  allows us to remove  those parts
" (including the ex command)?
"
" Have you saved and restored the visual marks?
"
" Do you need to save and restore v:register every time?
" Do you need to save and restore v:count every time?
"
" Have you used `:s`, while you should have used `setline()`?
"
" You should simplify the mappings, so that we call only one function,
" before pressing `g@`.
" The latter should save some info if needed, and set 'opfunc'.
"
" The repetition of an operation in visual mode is not consistent
" with what Vim does:
"
"    • press `~` on a visual selection
"    • move the cursor on another line
"    • press .
"
" Vim has recomputed a new visual selection with the same geometry
" than the previous one.
" That's not what your operators do.
" Study how `vim-operator-user` solves this issue (I think it solves
" the issue by pressing `gvg@`; that is `g@` should be pressed from
" visual mode for the repetition to work as expected).
"
" 119 -
" all your commands should print a usage message when executed without arguments
" or with  `--help`, or  `-h` (similar to  what our shell  function does  with a
" heredoc).
"
" if there's too much info to print,  you could separate them on different pages
" by using a `--help {keyword}` argument.
"
" 120 -
" eliminate `lg#reg#save()`, `lg#reg#restore()` whenever possible.
" we don't need to save/restore @+ anymore.
"
" 121 -
" when  is  it   better  to  use  `$xdg_runtime_dir`  instead   of  `/tmp`  (via
" `tempname()`)?
" https://unix.stackexchange.com/a/316166/289772
"
" 122 -
" be  consistent  in  how  you  chose  the  priority  of  matches  created  with
" `matchadd()`.
"
" 123 -
" saving an option, changing it, then restoring it via a timer is a bad idea.
" check where you did it.
" remove the timer.
"
" also, every time you've temporarily reset an option, make sure you did it
" in a try conditional, and restore it in the finally clause
" (for example, we didn't in vim-breakdown)
"
" 124 -
"
" Check how plugin authors implement a scratch buffer.
" Which options do they set? For which purpose exactly?
" Look for `bt=nofile` or `buftype=nofile`.
" Read:
"     :h special-buffers
"     :h new-buftype
"     :h 'bt
"
" Refactor  your code  every  time  you implemented  a  scratch  buffer, to  fix
" possible bugs,  and to be  consistent in  the options you  set as well  as the
" order in which you set them.
"
" 125 -
" Be consistent in how you extract the comment leader.
" Vimgrep everywhere for `cml`.
"
" Update:
" We should probably define functions in our library (lg-lib), to:
"
"    • extract the comment leader
"    • get a pattern to detect whether the current line is commented
"    • return the commented version of a line (before pasting it somewhere)
"
" 126 -
" We have 4 plugins which use `repeat#set()`:
"
"     vim-abolish
"
"     vim-easy-align
"
"     vim-sneak
"
"     vim-speeddating
"
" Try to get rid of the call to the function, either by:
"
"    • submitting a bug report/PR
"    • re-implementing the plugin
"
" 127 -
" Try to replace as many `:s` commands as possible with `setline()`:
"
"     noa vim !s\([/:;@]\).\{-}\1!gj ~/.vim/**/*.vim ~/.vim/**/*.snippets ~/.vim/vimrc | cw
"     Cfilter! -other_plugins -commented -tmp
"     Cfilter! ^\s*\%(let\|call\|echo\|return\|if\|unlet!\=\|&&\)\s
"
" 128 -
" Every  time you open a  window, be aware that  an error may be  raised because
" you're in the command-line window.
" You may want to catch that error to avoid a stack trace.
"
" 129 -
" Watch out for this anti-pattern:
"
"     " assume that `var` can only have 3 values ['foo', 'bar', 'baz']
"     echo var is# 'foo'
"         \ ?     1
"         \ : var is# 'bar'
"         \ ?     2
"         \ :     3
"
" You should rewrite the code like so:
"
"     echo {'foo': 1, 'bar': 2, 'baz': 3}[var]
"
" It's better because:
"
"   • more concise/readable
"   • mention explicitly the third value 'baz'
"   (before it was implicit/not mentioned at all)
"   • easier to expand later if `var` can have more values
"
" 130 -
" Recently, when we try to push a commit and press enter after our username,
" the terminal writes `^M` instead of a linefeed.
" Next time it happens, try:
"
"     # check settings (`icrnl` should not be prefixed by `-`)
"     $ stty -a
"
"     # fix tty
"     $ stty icrnl
"
"     https://askubuntu.com/a/454663/867754
"
" Find what's causing the issue.
" Is it something we do in Vim?
"
" 131 -
" Add  spaces  around  all  concatenation  operators: it  makes  the  code  more
" readable?
"
" 132 -
" Remove all `==#`, `!=#`, `==?`, `!=?`.
" Replace them with `==`, `!=`.
" The `#` and `?` is useless now.
" In the past,  we used them to make  sure not to forget them  when doing string
" comparison.
" But we don't do string comparison with `==` and `!=` anymore.
" We use `is` and `isnot` now.
"
"     noa vim /\%(\s[!=]=\|\s[><]\)\zs[#?]/gj ~/.vim/**/*.vim ~/.vim/**/*.snippets ~/.vim/template/** ~/.vim/vimrc | cw
"
" Update:
" Yeah, but what if we have an expression evaluated as a number, which sometimes
" is evaluated as a string.
" Wouldn't we be happy to have a strict comparison in this case?
"
" 133 -
" Remove `&l:` when it's not necessary?
"
" 134 -
" Use full name of commands?
"
" 135 -
" Switch from 4 spaces to 2 spaces for indentation?
"
" 136 -
" We often have errors when we import the contents of a file with `:r`,
" because the current buffer is not modifiable.
" Maybe we should always bail out in those cases...
"
" 137 -
" It doesn't make sense for `C-g v` to search in $VIMRUNTIME.
" It should look into `/usr/share/zsh/`.
" `C-g v` should inspect some buffer-local variables to determine
" the cycle of directories in which `:vimgrep` should search.
"
" 138 -
" This mapping works in Vim, but not in Neovim:
"     cno  <expr>  <c-d>  timer_start(0, {-> feedkeys("\<lt>del>", 'int')})[-1]
"                                                      ├───┘
"                                                      └ yeah, you really need that
"                                                       (to prevent "<del>" from deleting the next quote
"                                                        when the mapping is parsed?)
"
" Because of this `c_^d` didn't work in Neovim.
" It works now, because I've refactored the mapping to avoid `<expr>`.
" But still, report it on Neovim's bug tracker.
" Btw, it looks similar to another issue we opened.
"
" 139 -
"
"     % hash | vipe
"
"     press `gf` on a path
"         → it takes several seconds, and the cpu load increases
"           ✘
"
" The issue comes from 'set path=.,**' and from our current directory,
" when the latter has many subdirectories like `~`.
"
" MWE:
"
"     vim -Nu NONE \
"       +'set path=.,**' \
"       +"set inex=substitute(v:fname,'.*=','','')" \
"       <(hash)
"
"     press `gf` on a path: it's slow
"
"     vim -Nu NONE \
"       +'cd ~/.vim/plugged/vim-awk' \
"       +'set path=.,**' \
"       +"set inex=substitute(v:fname,'.*=','','')" \
"       <(hash)
"     press `gf` on a path: it's quick
"
" We need to make `gf` smarter.
" When it sees a directory such as `~`, it should not search in it.
" Or, we should stop using such a broad 'path'... (vim-apathy to the rescue?)
"
" 140 -
" `[ SPC`  and `] SPC`  are not reliable  when we're on  a line inside  a closed
" fold.
" Maybe  you should  use other  keys to  handle folds,  so that  you can  decide
" yourself if you want Vim to add an empty line or an empty fold.
" Currently, I don't think we have an easy algo to teach Vim how to decide itself.
"
" 141 -
"
" What's the use case of the command attributes `-addr=quickfix` and `-addr=other`?
"
" The commit `8.1.0560`:
"
"     https://github.com/vim/vim/releases/tag/v8.1.0560
"
" has introduced the command attribute `-addr=other`.
"
" 142 -
" Read this:
"
"     https://gist.github.com/yegappan/3b50ec9ea86ad4511d3a213ee39f1ee0
" >     Updating a quickfix/location list asynchronously without interfering with another plugin
"
" 143 -
"
"     $ vim -Nu NONE
"     :exe 'helpgrep vim' | exe 'helpgrep text' | exe 'helpgrep wont_be_found'
"     :chi
"
"         No entries
"
" Shouldn't the last command print the quickfix stack?
" Why does it tell me that the last quickfix list is empty?
"
" 144 -
" Could  we use  Vim packages  to eliminate  the separation  of plugins'  config
" between `~/.vim/plugin` and `~/.vim/after/plugin/`?
"
" > What  I like  about packadd  is  that **you  can actually  put the  before**
" > **and  after  config**  and  the  loading of  the  plugin  **in  a  single**
" > **file**.  That's because packadd loads the plugin right when it's called as
" > apposed to most plugin managers that collect the list of all plugins to load
" > before loading  them.  (For  that to  work plugins need  to be  installed in
" > a  pack/**/opt  directory  i.e.  when  using  the  minpac  package  manager:
" > minpac#add(url, {'type': 'opt'}))
"
" > Oh that's  a neat idea. I  think at  the moment though  I prefer to  see all
" > external plugins that will be loaded  in the one place. I use :packadd! (the
" > ! version) which adds the plugins to  the runtime path but doesn't load them
" > immediately. Also, that  way the plugins are  loaded when they expect  to be
" > loaded (ie. in the usual place in the startup order).
"
" Source:
" https://www.reddit.com/r/vim/comments/a5ngap/debugging_your_vim_config_vimways_1224/eboufag/
" https://www.reddit.com/r/vim/comments/a5ngap/debugging_your_vim_config_vimways_1224/ebow7d5/
"
" 145 -
" Whenever you used `system()`, `systemlist()`, or  `:!` to run a shell command,
" and it contained a  filename, make sure you used the  filename modo `:p`, `:S`
" and `--`  to end the optional  arguments (useful in case  your filename begins
" with a hyphen).
"
" 146 -
" Read: https://vimways.org/2018/vims-social-life/
"
" 147 -
" Supercharge `]e` and `[e` to move a fold when the cursor is on a line inside a
" closed fold.
" Maybe do the same with `J` and `K` in visual mode.
"
" Btw:
" I think we shouldn't use the keys  `]f` and `[f` to promote/demote a fold, but
" instead `H` and `L`.
"
" 148 -
" Finish reviewing/explaining `do Syntax` inside `s:fix_display()`.



let s:syled_comments_filetypes = [
    \ 'awk',
    \ 'conf',
    \ 'dircolors',
    \ 'gitconfig',
    \ 'lua',
    \ 'readline',
    \ 'sh',
    \ 'snippets',
    \ 'tex',
    \ 'tmux',
    \ 'vim',
    \ 'xkb',
    \ 'zsh',
    \ ]
augroup syled_comments
    au!

    au FileType * if index(s:syled_comments_filetypes, expand('<amatch>')) >= 0
        \ |     call lg#styled_comment#fold()
        \ |     call lg#styled_comment#undo_ftplugin()
        \ | endif

    au Syntax * if index(s:syled_comments_filetypes, expand('<amatch>')) >= 0
        \ |     call lg#styled_comment#syntax()
        \ |     call lg#styled_comment#highlight()
        \ | endif
augroup END



augroup my_man_no_showbreak
    au!
    au FileType man setl showbreak=
augroup END




" sessions to finish:
"
"          1. sandwich
"          2. ultisnips
"          3. markdown
"          4. tag
"          5. arglist (improve our arglist mappings)
"          6. breakdown
"          7. paragraph (master `$ par`)
"          8. tree
"          9. keyboard
"          10. systemd
"          11. cron
"          12. swap
"          13. emmet
"          14. config
"          15. qf_issue (finish the last two questions)
"          16. completion
"          17. profiling
"          18. debug
"          19. try
"          20. async
"          21. unix
"          22. package
"          23. cwd
"          24. unix
"
" Once finished, get back to studying the terminal and latex.



augroup quick_and_dirty_settings
    au!
    au BufReadPost * call s:quick_and_dirty_settings()
augroup END

fu! s:quick_and_dirty_settings() abort
    if getline(1) isnot# 'QnD'
        return
    endif

    call cursor(1,1)
    let end = search('^QnD_END$')
    if !end
        sil! norm! g`.
    endif

    let settings = getline(2, end - 1)
    let b:quick_and_dirty_settings = tempname()
    call writefile(settings, b:quick_and_dirty_settings)
    augroup apply_quick_and_dirty_settings
        au! * <buffer>
        au BufWinEnter <buffer> exe 'so '.b:quick_and_dirty_settings
    augroup END

    sil! norm! g`.
endfu



" inorea  <expr>  aa  <sid>painful_chars('angle')
" cnorea  <expr>  aa  <sid>painful_chars('angle')

" inorea  <expr>  cc  <sid>painful_chars('curly')
" cnorea  <expr>  cc  <sid>painful_chars('curly')

" inorea  <expr>  rr  <sid>painful_chars('round')
" cnorea  <expr>  rr  <sid>painful_chars('round')

" inorea  <expr>  ss  <sid>painful_chars('square')
" cnorea  <expr>  ss  <sid>painful_chars('square')

" inorea  <expr>  tt  <sid>painful_chars('tick')
" cnorea  <expr>  tt  <sid>painful_chars('tick')

" fu! s:painful_chars(char) abort
"     let seq = {
"     \           'angle':  '<>',
"     \           'curly':  '{}',
"     \           'round':  '()',
"     \           'square': '[]',
"     \           'tick':   '``',
"     \}
"     if !has_key(seq, a:char)
"         return ''
"     endif
"     call feedkeys(seq[a:char]."\<left>", 'in')
"     call timer_start(0, {-> feedkeys("\<bs>", 'in')})
"     return ''
" endfu


augroup save_and_restore_last_qfl
    au!
    au VimLeavePre * call s:save_last_qfl()
    au VimEnter    * call s:restore_last_qfl()
augroup END

fu! s:save_last_qfl() abort
    let counter = 0
    "                ┌ the size of the qf stack is limited to 10
    "                │
    while counter <= 10
        " TODO: once Neovim supports the 'size' property, remove `len(getqflist())`.
        let size = !has('nvim')
            \ ?     get(getqflist({'size': 0}), 'size', 0)
            \ :     len(getqflist())

        " Saving and restoring a long qfl takes too much time.
        " And if the qfl is empty, we don't  want to look for another qfl in the
        " stack.
        if size > 9999 || size == 0
            unlet! g:MY_LAST_QFL
            return
        endif

        if get(getqflist({'title': 1}), 'title', '') =~# '^\s*:hub\s\+push\s*$'
            if get(getqflist({'nr': 0}), 'nr', 0) > 1
                col
            else
                return
            endif
        endif
        let counter += 1
    endwhile

    " TODO: Find a MWE showing how `fnamemodify()` is necessary.
    " Why `fnamemodify()`?{{{
    "
    " I think  that without,  sometimes, we  had entries in  a qfl  which didn't
    " match any existing file:
    "
    "         call map(qfl, {i,v -> extend(v, {'filename': bufname(v.bufnr)})})
    "}}}
    let qfl = getqflist()
    call map(qfl,
        \    {i,v -> extend(v,
        \        {'filename': fnamemodify(bufname(remove(v, 'bufnr')), ':p')})})
    let g:MY_LAST_QFL = {'qfl': qfl,
        \ 'title': get(getqflist({'title': 1}), 'title', ':setqflist()')}
endfu

fu! s:restore_last_qfl() abort
    " If there's already a qfl on the stack, or if there's no qfl to restore, don't try to restore anything.
    " How could there already be a qfl on the stack?{{{
    "
    "     $ grep -RHIinos network /etc
    "     $ vim -q <(!!)
    "
    "     $ grep -RHIinos network /etc | vim -q /dev/stdin
    "
    "     $ grep -RHIinos network /etc >/tmp/log
    "     $ vim -q /tmp/log
    "
    "     $ vim +'vimgrep /pat/ %' file
    "
    "     $ vim -S /tmp/efm.vim
    "}}}
    " Why not restoring the qfl if there's already one on the stack?{{{
    "
    " Too confusing.
    " You would expect a certain a qfl, but get a different one.
    " You may  lose a lot of  time/energy before remembering you  have this code
    " which restores an old qfl.
    " This is  especially true if the  two qfl which  end on the stack  are very
    " similar, which happens when you're refining an 'efm'.
    "}}}
    if !has('nvim') && getqflist({'size':0}).size || !empty(getqflist())
    \ || empty(get(get(g:, 'MY_LAST_QFL', {}), 'qfl', []))
        return
    endif

    if has_key(g:MY_LAST_QFL, 'qfl')
        call setqflist(g:MY_LAST_QFL.qfl)
    endif
    if has_key(g:MY_LAST_QFL, 'title')
        call setqflist([], 'a', {'title': g:MY_LAST_QFL.title})
    endif
endfu



" ino <c-g>c <c-r>=string(eval(input('Calculate: ')))<cr>
" ino <c-g>c <c-r>=eval(input('Calculate: '))<cr>


" don't use `<space>g`, I press it by accident too often
nno  <silent>  <space>G  :<c-u>let g:my_goyo_without_syntax_hl = 1
                        \ <bar> exe 'Goyo'.(!exists('#goyo') ? ' 110' : '!')<cr>
                        " \ <bar> norm coz<cr>

nno  <silent>  <space><c-g>  :<c-u>let g:my_goyo_without_syntax_hl = 0
                            \ <bar> exe 'Goyo'.(!exists('#goyo') ? ' 110' : '!')<cr>

fu! s:goyo_enter() abort
    sil !tmux set status off
    " FIXME:
    " If we have 2 panes in the same window, and Vim is one of them, when we
    " start goyo mode, we only see half of the screen. We probably need to
    " resize the Tmux pane from the plugin, earlier.
    sil !tmux list-panes -F '\#F' | grep -q Z || tmux resize-pane -Z
    let s:cul_save = &l:cul
    norm ]oL
    set scrolloff=999
    set noshowcmd

    let  s:goyo_cocu_save = &l:cocu
    let  s:goyo_cole_save = &l:cole
    setl cocu=nc cole=3

    " FIXME:
    " need to find another way to change the shape of the cursor in Neovim
    if !has('nvim')
        let &t_EI = "\e[4 q"
        exe "norm! r\e"
    endif

    let pos = getcurpos()
    " The new window created by `:tab sp` inherits the window-local options of
    " the original window. But `:tab sp` doesn't fire `BufWinEnter` so we lose
    " our position in the changelist.
    "
    " FIXME: We should  use the function `s:restore_change_position()`  but it's
    " local to `vim-window`.
    sil! exe 'norm! '.(exists('b:my_change_position') ? '99g;' : '99g,')
        \ .(b:my_change_position - 1) .'g,'
    call setpos('.', pos)

    if get(g:, 'my_goyo_without_syntax_hl', 1)
        let syntax_groups = [
            \ 'Conditional',
            \ 'Delimiter',
            \ 'Function',
            \ 'Identifier',
            \ 'MatchParen',
            \ 'Number',
            \ 'Operator',
            \ 'PreProc',
            \ 'Special',
            \ 'Statement',
            \ 'String',
            \ 'Type',
            \ 'snipSnippet',
            \ ]

        for group in syntax_groups
            exe 'hi '.group.' term=NONE cterm=NONE ctermfg=NONE ctermbg=NONE gui=NONE guifg=NONE guibg=NONE'
        endfor
    endif
    Limelight
endfu

fu! s:goyo_leave() abort
    sil !tmux set status on
    sil !tmux list-panes -F '\#F' | grep -q Z && tmux resize-pane -Z
    set  showcmd
    exe 'norm '.(s:cul_save ? '[' : ']').'oL'
    set  scrolloff=3

    let &l:cocu = s:goyo_cocu_save
    let &l:cole = s:goyo_cole_save
    unlet! s:goyo_cocu_save s:goyo_cole_save

    let &t_EI = "\e[2 q"

    exe "norm! r\e"

    exe 'colo '.g:colors_name
    Limelight!
endfu

augroup my_goyo
    au!
    " FIXME:
    " If we use `nested`, `:NoMatchParen` doesn't work.
    " It doesn't work, even if we type the command later, while in goyo mode.
    " Why?
    " Should we get rid of `nested` in the 2nd autocmd (GoyoLeave)?
    " Why do we need `nested` anyway?

    au User GoyoEnter        call s:goyo_enter()
    au User GoyoLeave nested call s:goyo_leave()
augroup END

nno  <silent>  coj  :<c-u>call <sid>nofrils()<cr>

fu! s:nofrils() abort
    if stridx(execute('hi Conditional'), 'cleared') != -1
        exe 'colo ' . g:colors_name
        return
    endif

    let syntax_groups = [
    \ 'Conditional',
    \ 'Delimiter',
    \ 'Function',
    \ 'Identifier',
    \ 'MatchParen',
    \ 'Number',
    \ 'Operator',
    \ 'PreProc',
    \ 'Special',
    \ 'Statement',
    \ 'String',
    \ 'Type',
    \ ]
    for group in syntax_groups
        exe 'hi clear ' . group
    endfor
endfu


" let g:nums = split(": one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen")
" let g:tens = split(": ten twenty thirty fourty fifty sixty seventy eighty ninety")

" fu! Read_number(n) abort
"     let n = a:n
"
" "                        ┌── quotient
" "                        │                                              ┌── remainder
" "                        │                                              │
"     " n/1000             how many thousands in n                  ; the remain is n%1000
"     " (n%1000)/100       how many hundreds in the previous remain ; the new remain is (n%1000)%100
"     " (n%1000)%100/10    how many tens     in what remains        ; the new remain is ((n%1000)%100)%10
"     if n >= 1000
"         return  g:nums[n/1000].' thousand '
"             \ . g:nums[(n%1000)/100].' hundred '
"             \ . g:tens[(n%1000)%100/10].' '
"             \ . g:nums[((n%1000)%100)%10]
"
"     " n/100              how many hundreds in n               ; the remain is n%100
"     " (n%100)/10         how many tens in the previous remain ; the new remain is (n%100)%10
"     elseif n >= 100
"         return g:nums[n/100].' hundred '
"             \ . g:tens[(n%100)/10].' '
"             \ . g:nums[(n%100)%10]
"
"     " n/10               how many tens in n                   ; the remain is n%10
"     elseif n >= 20
"         return g:tens[n/10].' '.
"              \ g:nums[n%10]
"
"     else
"         return g:nums[n]
"     endif
" endfu



" we can't be locked inside an infinite loop, because after first iteration,
" we go from `n` to `n%1000` (which is < 1000). Then to `n%100` (< 100), then
" to `n%10` (<9), at which point the function doesn't call itself anymore.
" This proves that, provided the nr is < 20000, the function can't be called more
" than 4 times.
" The code breaks at 20000, because `20000/1000 = 20`, and g:nums[20] doesn't
" exist: "twenty" is not in g:nums.

" fu! Read_number(n) abort
"     let n = a:n
"
"     " if n >= 1000000
"     "     return g:nums[n/1000000].' million '.Read_number(n%1000000)
"     " elseif n >= 1000
"     if n >= 1000
"         return g:nums[n/1000].' thousand '.Read_number(n%1000)
"         " return (n/1000 <= 9 ? g:nums[n/1000] : Read_number(n/1000)).' thousand '.Read_number(n%1000)
"     elseif n >= 100
"         return g:nums[n/100].' hundred '.Read_number(n%100)
"     elseif n >= 20
"         return g:tens[n/10].' '.Read_number(n%10)
"     else
"         return (n !=# 0 ? g:nums[n] : '')
"     endif
" endfu



" call fzf#run({'source': map(range(1, bufnr('$')), { i,v -> bufname(v) }),
"             \ 'sink': 'e', 'down': '30%'})



" ino <c-g>d <c-r>=<sid>diagram_complete()<cr>
"
" fu! s:diagram_complete() abort
"     let previous_line = getline(line('.')-1)
"     let new_line      = substitute(previous_line, '\v%(└|┌).*', '', '')
"     if stridx(previous_line, '┌') !=# -1
"         let new_line .= '│'
"     endif
"     let new_line = substitute(new_line, '[^└┌│'.split(&l:cms, '%s')[0].']', ' ', 'g')
"     call setline('.', new_line)
"     return repeat("\<Right>", col('$') - col('.'))
" endfu

