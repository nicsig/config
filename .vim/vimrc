vim9script noclear

if exists('loaded') | finish | endif
var loaded = true

# Options 1 {{{1

# Why this setting?{{{
#
# When we use the GUI, we don't want `$VIMRUNTIME/menu.vim` to be sourced.
# We won't use the menu.  It makes Vim start around 50ms slower.
# https://www.reddit.com/r/vim/comments/5l939k/recommendation_deinvim_as_a_plugin_manager/dbu74zd/
#
# The default value is `aegimrLtT`.
# We could also let `'go'` unchanged, and write this instead:
#
#     g:did_install_default_menus = 1
#     g:did_install_syntax_menu = 1
#
# In this case, we would keep the menu bar but avoid loading the default menus.
# For more info, see `:h menu.vim`.
#}}}
# Why here, before the plugins, and not after, with the other options?{{{
#
# From `:h 'go-M`:
#
#    > Note that  this flag  must be added  in the .vimrc  file, before  switching on
#    > syntax  or filetype  recognition (...;  the  `:syntax on`  and `:filetype  on`
#    > commands load the menu too). `:filetype on` and `:syntax on` source menu.vim.
#}}}
set guioptions=M
# In the GUI, let us interrupt an external process by pressing `C-c`.{{{
#
# For more info, see:
# `:h go-!`
# https://github.com/vim/vim/issues/6565#issuecomment-665783322
#}}}
set guioptions+=!

# Plugins {{{1
# Disable plugins {{{2

# We never use these plugins:{{{
#
#    - getscript
#    - logipat
#    - vimball
#
# The less code, the fewer bugs.
# Besides, they install some custom commands which pollute tab completion on the
# command-line.
#}}}
g:loaded_getscriptPlugin = 1
g:loaded_logiPat = 1

# interface + autoload
g:loaded_vimballPlugin = 1
g:loaded_vimball = 1

# How to disable netrw?{{{
#
#     # no interface
#     g:loaded_netrwPlugin = 1
#
#     # no autoload/
#     g:loaded_netrw = 1
#
# See `:h netrw-noload`.
#}}}
#   Why would it be a bad idea?{{{
#
# Some third-party plugins  might rely on netrw,  and I don't want  to lose time
# debugging them.
#
# For example, without netrw, the  `:Gbrowse` command provided by `vim-fugitive`
# and `vim-rhubarb` doesn't work.
#
# ---
#
# netrw also lets you edit a remote file located at an arbitrary url.
#
# For example, if you press `Zf` on this url:
# https://salsa.debian.org/printing-team/cups/raw/debian/master/cups/utf8demo.txt
#
# It will open the `utf8demo.txt` file in a new split.
#
# Same thing with this file:
# ftp://ftp.vim.org/pub/vim/patches/8.1/README
#}}}

# vim-plug:  installation {{{2

# We install vim-plug if it's not already.
#
# To know whether vim-plug is installed or not, we check whether this file exists:
#
#     ~/.vim/autoload/plug.vim

if glob('~/.vim/autoload/plug.vim')->empty()
    sil system('curl -fLo ~/.vim/autoload/plug.vim --create-dirs'
        .. 'https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim')
    au VimEnter * PlugInstall | so $MYVIMRC
endif

# Disable shallow cloning.
#
# We want the full copy of a repo, to see all the commits history.
# Useful  to understand  why  a particular  change was  introduced  in a  plugin
# without having to go to github.  Cost more bandwidth though.

g:plug_shallow = 0

# vim-plug:  usage  {{{2

# Plugins must be declared after this line.
# They will be downloaded inside `~/.vim/plugged/`.
plug#begin('~/.vim/plugged')
# Don't remove the quotes around the keys of the dictionaries passed to `:Plug`.{{{
#
# We can't use the Vim9 syntax with  `:Plug`, because the latter is defined in a
# legacy context (in a legacy function in `~/.vim/autoload/plug.vim`).
#}}}

# To Assimilate:
Plug 'lacygoill/vim-movesel'
Plug 'lacygoill/vim-abolish', {'branch': 'assimil'}
Plug 'lacygoill/asyncmake', {'branch': 'assimil'}
Plug 'lacygoill/vim-cheat', {'branch': 'assimil'}
Plug 'lacygoill/vim-cwd'
Plug 'lacygoill/vim-debug'
Plug 'junegunn/vim-easy-align'
Plug 'lacygoill/vim-exchange'
Plug 'lacygoill/vim-fex'
Plug 'tpope/vim-fugitive'
# You can pass more arguments to the fzf installer:
#     $ ~/.fzf/install --help
Plug 'junegunn/fzf', {'dir': '~/.fzf', 'do': './install --all --no-bash'}
Plug 'junegunn/fzf.vim'
Plug 'lacygoill/goyo.vim', {'branch': 'assimil'}
Plug 'lacygoill/vim-graph'
# TODO: remove `vim-gutentags`{{{
#
# Use git hooks instead.
# Less code, more control, occasion to better understand git.
#
# https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration
# https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks
# https://git-scm.com/docs/githooks
#
# https://tbaggery.com/2011/08/08/effortless-ctags-with-git.html
# https://github.com/tpope/tpope/tree/master/.git_template
# https://github.com/tpope/tpope/blob/master/.gitconfig
#
# Update:
# A file watcher (like `entr(1)`) may be even better.
# http://eradman.com/entrproject/
# See:
#
#     ~/bin/entr-reload-browser
#     ~/bin/entr-watch
#
# Try:
#
#     $ ( ls ~/wiki/web/practice/htdocs/*.html | entr entr-reload-browser Firefox &! )
#     $ vim ~/wiki/web/practice/htdocs/index.html
#     open the file in firefox too, then edit the file in Vim, then watch the page in firefox
#
# Problem:
# Your tags will be generated only in git projects.
# Not in projects using other VCS systems (`.hg/`, `.bzr/`, ...).
#
# Also:
# Use `entr(1)`  to automatically rename  files whose names contain  spaces, and
# replace them with underscores.
# Don't do that everywhere; just in some specific directories like `~/Downloads/`.
# The purpose  is to  make it  easier for `fasd(1)`  to log  files we  open with
# `mpv(1)`, `zathura(1)`, ...
# Indeed, by default, fasd ignore files  with spaces, unless you quote the name,
# but we always forget to quote it.
#
# See also this Vim plugin:
# https://github.com/mattn/vim-filewatcher
#}}}
Plug 'ludovicchabant/vim-gutentags'
Plug 'tweekmonster/helpful.vim'
Plug 'lacygoill/limelight.vim', {'branch': 'assimil'}
Plug 'foxik/vim-makejob'
Plug 'lacygoill/vim-man'
Plug 'lacygoill/vim-markdown'
Plug 'andymass/vim-matchup'
Plug 'lacygoill/vim-quickhl', {'branch': 'assimil'}
Plug 'tpope/vim-rhubarb'
Plug 'junegunn/seoul256.vim'
Plug 'justinmk/vim-sneak'
Plug 'wellle/targets.vim'
Plug 'lacygoill/vim-tmux', {'branch': 'assimil'}
Plug 'lacygoill/vim-tmuxify', {'branch': 'assimil'}
# Alternative: https://github.com/vim/vim/pull/3220#issuecomment-538651011
Plug 'lacygoill/vim-tradewinds', {'branch': 'assimil'}
Plug 'lacygoill/vim-unix'

# Done:
Plug 'lacygoill/vim-awk'
Plug 'lacygoill/vim-brackets'
Plug 'lacygoill/vim-breakdown'
Plug 'lacygoill/vim-bullet-list'
Plug 'lacygoill/vim-capslock'
Plug 'lacygoill/vim-cmdline'
Plug 'lacygoill/vim-column-object'
Plug 'lacygoill/vim-comment'
Plug 'lacygoill/vim-completion'
Plug 'lacygoill/vim-cookbook'
Plug 'lacygoill/vim-doc'
Plug 'lacygoill/vim-draw'
Plug 'lacygoill/vim-fold'
Plug 'lacygoill/vim-freekeys'
Plug 'lacygoill/vim-fuzzy'
Plug 'lacygoill/vim-git'
Plug 'lacygoill/vim-gx'
Plug 'lacygoill/vim-help'
Plug 'lacygoill/vim-hydra'
Plug 'lacygoill/vim-iabbrev'
Plug 'lacygoill/vim-interactive-lists'
Plug 'lacygoill/vim-jagged-block'
Plug 'lacygoill/vim-latex'
Plug 'lacygoill/vim-lg-lib'
Plug 'lacygoill/vim-logevents'
Plug 'lacygoill/vim-math'
Plug 'lacygoill/vim-par'
Plug 'lacygoill/vim-qf'
Plug 'lacygoill/vim-readline'
Plug 'lacygoill/vim-reorder'
Plug 'lacygoill/vim-repeat', {'branch': 'lg'}
Plug 'lacygoill/vim-repmap'
Plug 'lacygoill/vim-save'
Plug 'lacygoill/vim-search'
Plug 'lacygoill/vim-session'
Plug 'lacygoill/vim-sh'
Plug 'lacygoill/vim-snippets'
Plug 'lacygoill/vim-source'
Plug 'lacygoill/vim-stacktrace'
Plug 'lacygoill/vim-statusline'
Plug 'lacygoill/vim-submode'
Plug 'lacygoill/vim-terminal'
Plug 'lacygoill/vim-titlecase'
Plug 'lacygoill/vim-toggle-settings'
Plug 'lacygoill/vim-unichar'
Plug 'machakann/vim-Verdin'
Plug 'lacygoill/vim-vim'
Plug 'lacygoill/vim-virtual-text'
Plug 'lacygoill/vim-window'
Plug 'lacygoill/vim-xkb'

# Read Doc:
Plug 'justinmk/vim-dirvish'
Plug 'mattn/emmet-vim'
Plug 'machakann/vim-sandwich'
Plug 'SirVer/ultisnips'
Plug 'lervag/vimtex'

# Other:
Plug 'mbbill/undotree'
Plug 'chrisbra/unicode.vim'

# Some functions installing an interface are  too slow to be called during Vim's
# startup.  We delay them.
def DelaySlowCall()
    au! DelaySlowCall
    aug! DelaySlowCall

    # source `autoload/toggle_settings.vim`
    runtime autoload/toggle_settings.vim
    runtime! autoload/slow_call/*.vim
enddef

augroup DelaySlowCall | au!
    # Do *not* use a simple timer:{{{
    #
    #     au VimEnter * timer_start(1000, () =>
    #         \     execute('runtime autoload/toggle_settings.vim | runtime! autoload/slow_call/*.vim')
    #         \ )
    #
    # It could cause issues, for example, if you enter insert mode quickly (i.e.
    # before  the  callback),  and  some  custom  code  of  yours  rely  on  the
    # lazy-loaded interface.
    #
    # If you  still have issues because  you execute some normal  command before
    # the lazy-loaded  interface has  been installed, maybe  try to  add another
    # event to the autocmd.
    #}}}
    # Before adding an event to the list, make sure it doesn't increase Vim's startup time.{{{
    #
    # In particular, avoid `SafeState`, `VimEnter`, `BufEnter`.
    #
    # ---
    #
    # When you check with `--startuptime`, don't make Vim execute `:q` automatically:
    #
    #                                                ✘
    #                                                vv
    #     $ rm /tmp/log ; vim --startuptime /tmp/log +q && vim /tmp/log
    #
    # It could give numbers which are much lower than what you'll experience.
    # It  depends on  the events  you  listen to;  e.g.  if you  only listen  to
    # `CursorMoved`,  the  numbers  are  much  lower  when  you  make  Vim  quit
    # automatically, compared to when you quit manually.
    #
    # So, make sure to quit manually:
    #
    #     $ rm /tmp/log ; vim --startuptime /tmp/log
    #     :q
    #     $ vim /tmp/log
    #}}}
    var events: list<string> =<< trim END
        CursorHold
        InsertEnter
        WinEnter
        CmdWinEnter
        BufWritePost
        QuickFixCmdPost
        TextYankPost
        TextChanged
    END
    exe 'au ' .. join(events, ',') .. ' * DelaySlowCall()'
    # Do *not* call the function when we enter debug mode.
    # It could raise spurious errors when we debug Vim (`$ vim -D`).
    au CmdlineEnter :,/,\?,@ DelaySlowCall()
augroup END

plug#end()
# }}}1
# Imports {{{1

import {
    Catch,
    FixIndent,
    FuncComplete,
    IsVim9,
    Win_getid,
    } from 'lg.vim'

import MapMeta from 'lg/map.vim'

import {
    Fold,
    UndoFtplugin,
    Syntax,
    } from 'lg/styled_comment.vim'

# Options 2 {{{1
# Encoding {{{2
# Why should you leave this section at the top of our options configurations.{{{
#
# If for some  reason (shell environment), 'encoding' = 'latin1',  and we use an
# exotic character in our vimrc, it will raise an error.  As an example, see the
# value we give to 'listchars'.
# We need  to make  sure that Vim  will use  'utf-8' as an  encoding as  soon as
# possible.   Note that  the  real important  option to  avoid  an error  during
# startup, isn't 'termencoding', but 'encoding'.
#}}}

# Sets the character encoding used inside Vim.{{{
#
# It applies  to text in  the buffers,  registers, Strings in  expressions, text
# stored in the viminfo file, etc.
# It sets the kind of characters which Vim can work with.
# It  also   automatically  enables   saner  encoding  detection   settings  for
# 'fileencodings':
#
# https://vi.stackexchange.com/a/17326/17449
#}}}
# To avoid errors, we could also write:{{{
#
#     scriptencoding utf-8
#
# This would tell Vim to convert the following lines in our vimrc to utf-8.
# But setting `'encoding'`  seems to have a broader scope,  and hence be better,
# as we  want every file sourced  after the vimrc  to be read using  the `utf-8`
# encoding (ex: filetype plugins).
#}}}
set encoding=utf-8

# Encoding used for the terminal.  This specifies what character
# encoding the keyboard produces and the display will understand.
set termencoding=utf-8

# Ftplugins + Syntax {{{2

# Commented because we don't need this anymore.{{{
#
# `vim-plug` already does it for us.
# We keep this  section in case it might  be necessary if one day  we change our
# plugin manager.
#
# From: https://github.com/junegunn/vim-plug/wiki/faq
#
#    > vim-plug does not require any extra statement other than plug#begin()
#    > and plug#end(). You can remove filetype off, filetype plugin indent on
#    > and syntax on from your .vimrc as they are automatically handled by
#    > plug#begin() and plug#end().
#
# See also: https://github.com/junegunn/vim-plug/issues/83
#}}}
#     filetype plugin indent on
#     syntax enable

# Styled Comments {{{2

# The position of this section is important.{{{
#
# It should be processed *after* the syntax mechanism has been enabled.
# That is, after `:syntax enable` or after `vim-plug` has done its job.
# Otherwise, the syntax elements it installs would be cleared.
#}}}
def StyledComments()
    # Why do you include `help`?{{{
    #
    # We sometimes  lose the  conceal in a  help window, when  the help  file is
    # already displayed in another window.
    # Including `help` in this list fixes the issue, because `'cole'` is applied
    # from an autocmd listening to `BufWinEnter`.
    #}}}
    STYLED_COMMENTS_FILETYPES =<< trim END
        awk
        c
        cheat
        conf
        css
        desktop
        dircolors
        gitconfig
        help
        html
        lua
        nroff
        python
        readline
        sed
        sh
        snippets
        systemd
        tex
        tmux
        vim
        xdefaults
        xkb
        zsh
    END
    augroup StyledComments | au!
        au FileType * if index(STYLED_COMMENTS_FILETYPES, expand('<amatch>')) >= 0
            |     sil! Fold()
            |     sil! UndoFtplugin()
            | endif
        au Syntax * if index(STYLED_COMMENTS_FILETYPES, expand('<amatch>')) >= 0
            |     sil! Syntax()
            | endif
        # Purpose:{{{
        #
        # We (or a plugin) may  temporarily disable the syntax highlighting globally
        # with `:syn off`, then restore it with `:syn on`.
        # In  that case,  the position  of the  autocmd which  installs the  default
        # syntax  groups is  moved *after*  our  custom autocmd  which installs  the
        # syntax groups related to comments.
        #
        # Because of this new order, the default autocmd undoes our custom one.
        # We need to re-install our custom autocmd *after* the default one.
        #}}}
        au SourcePost $VIMRUNTIME/syntax/syntax.vim StyledComments()
            | getwininfo()->mapnew((_, v: dict<any>) => win_execute(v.winid, 'do StyledComments Syntax'))
    augroup END
enddef
var STYLED_COMMENTS_FILETYPES: list<string>
StyledComments()

# Gui {{{2

if has('gui_running')
    set guifont=DejaVu\ Sans\ Mono\ 20
endif

# Environment "{{{2

# See `~/wiki/shell/environment.md` for an explanation as to why we do that.
setenv('MANSECT', $MYMANSECT)

# TODO: We should probably remove this assignment.{{{
#
# To create *reliable* links inside a wiki, we should use tags:
# https://stackoverflow.com/q/25742396
#
# Indeed, with  regular links (filepaths),  if we rename  a file, or  change its
# location, we need to refactor all links towards the latter.
# With tags,  we would just  need to re-generate the  tags file with  an autocmd
# listening to `BufWritePost` or sth like that.
#
# The goal  would be to  have tags, like  in help files,  on which we  can press
# `C-]` to automatically jump to an arbitrary location inside the wiki.
# This would also allow us to leverage all built-in commands/functions dedicated
# to tags.
#
# See also:
#
# https://maximewack.com/post/tagbar/
# https://github.com/vimwiki/utils/blob/master/vwtags.py
# https://gist.github.com/MaximeWack/cdbdcd373d68d1fe5b3aca22e3dcfe46
# https://gist.github.com/MaximeWack/388c393b7db290dd732f0a2d403118c5
#
# https://github.com/majutsushi/tagbar
# https://github.com/majutsushi/tagbar/wiki#markdown
# https://github.com/jszakmeister/markdown2ctags
# https://github.com/lvht/tagbar-markdown
#
# http://docs.ctags.io/en/latest/extending.html
# https://gist.github.com/romainl/085b4db4a26a06ec7e16
# https://gist.github.com/romainl/27c1c29462a8c6c868f1a9bf244bc71d
# https://www.reddit.com/r/vim/comments/4d2fos/if_you_use_tags_whats_your_workflow_like/
# https://jdhao.github.io/2019/10/15/tagbar_markdown_setup/
#
# Update:
#
# Try this:
#
#     $ cat <<'EOF' >~/.config/ctags/markdown.ctags
#     --langdef=markdown
#     --langmap=markdown:.md
#     --regex-markdown=/|(.*)|/\1/h,heading,headings/
#     EOF
#
#     $ cd ~/wiki/vim/ && ctags -R .
#
# Source: https://stackoverflow.com/a/25742823/9780968
#
# Write `| foobar |` in one of your notes, and one line below write `foobar`.
# Press `C-]` on `foobar`: the cursor jumps onto `| foobar |`.
# But it doesn't work when `foobar` is above `| foobar |`, nor across files...
#
# Update: It doesn't seem to work anymore.  `ctags(1)` complains with:
#
#     ctags: Language "markdown" already defined~
#}}}
# Used in our notes when we create links between files, in a wiki on a topic.
setenv('MY_WIKI', $HOME .. '/wiki')

if !isdirectory($XDG_RUNTIME_DIR .. '/vim')
    # `0o` is necessary  for the octal to decimal conversion  which is no longer
    # automatic in Vim9.
    mkdir($XDG_RUNTIME_DIR .. '/vim', 'p', 0o700)
endif
setenv('XDG_RUNTIME_VIM', $XDG_RUNTIME_DIR .. '/vim')
# For more info about `$XDG_RUNTIME_DIR` and `/run`:
#
# https://standards.freedesktop.org/basedir-spec/latest/ar01s03.html
# https://unix.stackexchange.com/a/316166/289772

# backspace {{{2

# Allow BS, Del, C-w, C-u to delete:
#
#             ┌ whitespace (autoindent)
#             │      ┌ end of line (join line)
#             │      │   ┌ allow backspacing over the start of insert;
#             │      │   │  CTRL-W and CTRL-U do not stop at the start of insert
#             │      │   │
set backspace=indent,eol,nostop

# clipboard {{{2
# Do *not* tweak this option!
#    Why could I be tempted to change the value of this option?{{{
#
# When you use a pasting command,  and you don't specify from which register you
# want the text to be pulled, Vim uses the `"` register.
# So, if you want to copy some text from a Vim buffer to Firefox, you'll need to
# explicitly mention the name of the `+` register:
#
#     "+yy
#
# Same thing if you want to paste in  a Vim buffer, some text you've just copied
# in Firefox:
#
#     "+p
#
# It would be convenient to just press `yy` and `p`, and Vim would automatically
# use the clipboard register, instead of the unnamed one.
# That's what 'cb' is for.
#}}}
#    How should I change it?{{{
#
#     set clipboard^=unnamedplus
#
# 'cb' contains a  comma-separated list of values.
# Each stands  for a register.
# `unnamedplus` stands for the clipboard register.
#
# Do *not* execute this:
#
#     set clipboard+=unnamedplus
#
# It would *ap*pend the value to the list; you want to *pre*pend it.
#}}}
#    Technically, what happens if I do it?{{{
#
# The clipboard register will now have  a similar behavior (although not exactly
# identical) than the one of the unnamed:
#
#    - it will contain the text of the last changed register (like `"`)
#
#    -  ... except  if  the  last changed  register  was  changed by  a  command
#      containing its explicit name:
#
#         "ayy
#
#      This  is different from `"`,  which always copy  the text of the  last changed
#      register.
#
# If you copy some text in Firefox,  it goes into `+` (regardless of 'cb').  But
# because  of the  new value  of 'cb',  `p` will  automatically paste  `+` (last
# copied text in Firefox).
#
# If you copy some  text in a Vim buffer, it goes into  `0`.  The latter becomes
# the last modified register, and thus  `+` will duplicate its contents (because
# of `'cb'`).
#}}}
#    What pitfalls should I be aware of?{{{
#
# 1. It pollutes the clipboard selection after every yank, delete, change.
#
# 2. It alters the clipboard selection when inserting a character from select mode.
#
# 3. It may break a plugin which forgets to temporarily reset 'cb' to its default value.
#
# 4. It forces you to temporarily reset 'cb' whenever you write a custom operator which yanks some text.
#    (because a good operator should have as fewer side-effects as possible)
#
# For `2.`, see: https://vi.stackexchange.com/a/22127/17449
#}}}

# TODO: It would be nice to set the option like this:{{{
#
#     set cb=autoselect,exclude:.*
#                       ^--------^
#
# Because it would slightly reduce startup time.
# For more info, see: https://stackoverflow.com/a/17719528/9780968
# As well as `:h -X` and `:h 'cb`.
#
# ---
#
# The issue is that it prevents  us from using `--servername` (`v:servername` is
# empty even if you start Vim with `--servername FOO`).
# As  a result,  `vim-session`  won't  load the  last  session automatically  on
# startup, because of this guard:
#
#     if v:servername != 'VIM'
#         return
#     endif
#
# And we can't send files remotely with `--remote` and friends.
# And we can't access the `+` clipboard.
#
# Update: We could invoke  `remote_startserver()` to start a  server *after* the
# startup and fix most of these issues...
#}}}

# color scheme {{{2

# Be sure to enable `'termguicolors'` *before* sourcing the color scheme.
# We need to inspect the value of  the option to decide how to properly set some
# custom HGs.

# Atm, the only terminals which support true  color on my machine are st, xterm,
# konsole, gnome-terminal and a recent version of urxvt (compiled from source).
# Note that for gnome-terminal to have its TERM set to `gnome-256color`, you need to configure it like so:{{{
#
#     Edit
#     > Profile Preferences
#     > Command
#     > tick "Run a custom command instead of my shell"
#     > inside the "Custom command" field, write "/usr/bin/env TERM=gnome-256color /usr/bin/zsh"
#}}}
# Warning: We include `tmux` as a terminal type in which `'tgc'` can be set, but that's wrong.{{{
#
# We could be running tmux in a terminal which doesn't support true colors.
# To identify the type of the outer terminal, you could inspect:
#
#     :echo system('tmux display -p "#{client_termname}"')
#
# Unfortunately, `system()` would add too much time during startup.
#
# Anyway, in practice, I doubt this will be an issue.
# Most terminals support true colors; and even if we test one which doesn't from
# time to time, we won't be running tmux inside.
#}}}
if map(['gnome', 'konsole', 'rxvt-unicode', 'st', 'tmux', 'xterm'],
        (_, v: string): string => v .. '-256color'
      )->index(&term) >= 0
    # xfce4-terminal lies about its identity
    # and doesn't support true color on Ubuntu 16.04
    && $COLORTERM != 'xfce4-terminal'
    set termguicolors
    if !has('gui_running')
        # If  `&term`   is  not   'xterm',  `'t_8f'`   and  `'t_8b'`   won't  be
        # automatically set; we need to do it manually.
        # See: `:h xterm-true-color`.
        &t_8f = "\e[38;2;%lu;%lu;%lum"
        &t_8b = "\e[48;2;%lu;%lu;%lum"
    endif
endif

augroup MyColorScheme | au!
    au ColorScheme * colorscheme#customize()

    # What's the issue fixed by this autocommand?{{{
    #
    #     $ cat <<'EOF' >/tmp/markdown.snippets
    #     snippet foo ""
    #         text preceded by 4 leading spaces (!= 1 tab)
    #     endsnippet
    #     EOF
    #
    #     $ vim /tmp/markdown.snippets
    #     ]ol (change lightness)
    #
    # The leading spaces are not highlighted anymore (✘).
    #}}}
    # Where does the issue come from?{{{
    #
    # The `snipLeadingSpaces` HG is cleared when we change the color scheme, because of `:hi clear`:
    #
    #     ~/.vim/plugged/seoul256.vim/colors/seoul256.vim:201
    #
    # More generally, any HG whose attributes  are defined in a syntax plugin is
    # cleared; but the issue doesn't affect linked HGs:
    #
    #     " ✔
    #     :hi [def] link SomeGroup OtherGroup
    #     :hi clear
    #
    #     " ✘
    #     :hi SomeGroup term=... ctermfg=...
    #     :hi clear
    #}}}
    au ColorScheme * ReinstallClearedHg()
augroup END

def ReinstallClearedHg()
    # Why don't you simply run `:do Syntax`?{{{
    #
    # Suppose you have two windows, one with a python buffer, and the other with
    # an html buffer.
    # You change the color scheme while in the python buffer.
    # The HGs whose attributes are defined in `$VIMRUNTIME/syntax/html.vim` will
    # be cleared.
    # But since you're  in a python buffer, `:do Syntax`  will reload the python
    # syntax plugin, while you need to reload the html syntax plugin.
    #}}}
    # Why don't you manually re-install every cleared HG?{{{
    #
    # It would create duplication.
    # Some HGs would be installed from a syntax plugin, and from this file.
    # If one day their definition is updated  in the syntax plugin, we would have an
    # inconsistency.
    #
    # Besides, we would be constantly chasing new cleared HGs, and even then, we
    # could miss some of them; it's not reliable.
    #}}}
    # Which alternative could I use?{{{
    #
    #     :doautoall syntax
    #
    # But it's too slow when we have a lot of buffers.
    #}}}

    # What does this code do?{{{
    #
    # It iterates over all visible windows.
    # For each  of them,  if it  has never  seen the  filetype of  the displayed
    # buffer, it reloads its syntax plugin.
    #}}}
    # If I have several buffers with the same filetype, don't I need to fire `Syntax` for each of them?{{{
    #
    # No.
    # To re-install the cleared HGs, you just need to reload the syntax plugin once.
    #}}}
    var seen: dict<number>
    for info in getwininfo()
        var ft: string = getbufvar(info.bufnr, '&ft')
        if !has_key(seen, ft)
            seen[ft] = 1
            if ft != ''
                win_execute(info.winid, 'do Syntax')
            endif
        endif
    endfor
enddef

# In a console, we want a readable color scheme.
if $DISPLAY == ''
    colo morning
else
    # What's the purpose of this call?{{{
    #
    # We want to memorize somewhere the  last version of the color scheme we
    # used (atm it's expressed by an ANSI code: 233 ... 239, 252 ... 256).
    #}}}
    # Is there an alternative?{{{
    #
    # Yes.
    # We could use viminfo.
    #
    # Note that  when the vimrc  is read, the viminfo  hasn't been read  yet (:h
    # startup),  so if  you decide  to  use viminfo,  you'll have  to delay  the
    # loading of the color scheme until VimEnter:
    #
    #      au VimEnter * ++nested colorscheme#set()
    #                  │
    #                  └ the autocmds need to nest, so that when we set the color scheme,
    #                    `ColorScheme` is fired, and our customizations are sourced
    #
    # Also, you'll need to use a variable name in uppercase.
    #}}}
    # Why don't you use the alternative?{{{
    #
    # The alternative  requires that we delay  the sourcing of the  color scheme
    # until  VimEnter.  Besides,  the color  scheme executes  `:hi clear`  which
    # removes any custom HG we may have defined.
    #
    # So, if we delay the color scheme, we must redefine all our custom HGs.
    #
    # But, we can't know in advance all the custom HGs currently defined.
    # It depends on the files which have been read during Vim startup.
    #
    # For example, if  we start Vim to  read a markdown file,  the htmlItalic HG
    # will have been installed to apply the italic style on the text between two
    # asterisks.  We need to avoid clearing it right after Vim has been started.
    #}}}
    au MyColorScheme VimLeavePre * colorscheme#saveLastVersion()

    # try to restore the exact version of the last color scheme used
    var last_color_file: string = $HOME .. '/.vim/colors/my/last_version.vim'
    if filereadable(last_color_file)
        exe 'so ' .. last_color_file
    endif
    colorscheme#set()
endif

# cmd  mode  ruler{{{2

# When we  move the cursor  (hjkl wbe ...)  and Vim consumes a  lot of cpu  / is
# slow, it can be for 2 reasons:
#
#    - we're inside a deep nested fold:  solution → open folds (zR)
#    - `'showcmd'` is enabled:             solution → disable it

# Even  though it  can have  an impact  on performance,  we enable  `'showcmd'`,
# because sometimes it's useful  to see what we type.  Also,  it's useful to see
# the number of lines inside the visual selection.
set showcmd

# displaying the mode creates noise; and it can erase a message output by `:echo`
set noshowmode

# When  `'stl'` is  empty, Vim  displays the  current line  address, and  column
# number, in the statusline.  This region is called the “ruler bar“ (`:h ruler`).
#
# Even though we should never see it, disable it explicitly.
set noruler

# cms {{{2

# Without the  guard, when  you reload  the vimrc, the  fold titles  display the
# comment leader.
set commentstring=

# cpoptions {{{2

# When we type  `:r some_file` or `:'<,'>w some_file`, I  don't want `some_file`
# to become the alternate file of the current window.
# Update: It's commented.  Did we change our mind?
# set cpo-=aA

# Don't ignore escaped parentheses when using the text-object `ib`.{{{
#
# If we hit `dib` while the cursor is on 'O' in the following text:
#
#     (hello \(fOo) world)
#
# We get:
#
#     () world)
#
# For the moment, we prefer that Vim doesn't ignore escaped parentheses:
#
# So instead we get:
#
#     (hello \() world)
#}}}
set cpoptions+=M

# the nr column (`'nu'`,  `'rnu'`) will be taken into account  to decide when to
# wrap long lines
set cpoptions+=n

# allow us to redo a yank command with the dot command
set cpoptions+=y

# When appending to a register, put a line break before the appended text.
set cpoptions+=>

# cursor {{{2

# Variables {{{

#     ┌ Control Sequence
#     │
const CS_BLOCK: string = "\e[2 q"
const CS_UNDERLINE: string = "\e[4 q"
const CS_LINE: string = "\e[6 q"

const CS_BLINKING_BLOCK: string = "\e[0 q"
const CS_BLINKING_UNDERLINE: string = "\e[3 q"
const CS_BLINKING_LINE: string = "\e[5 q"

const SHAPE_NORMAL: string = 'BLOCK' # █
const SHAPE_REPLACE: string = 'UNDERLINE' # _
const SHAPE_INSERT: string = 'LINE' # |
#}}}
def SetCursor() #{{{
    # In console, no escape sequence we're going to use is supported (probably).{{{
    #
    # Worse, if you include `CSI 2 SP q` in `'t_te'`, and you start Vim inside tmux,
    # when you quit Vim, the sequence keeps being sent to the terminal regularly.
    # So, you get a phantom `q` printed here and there.
    #}}}
    # TODO: Try to support the linux console: https://unix.stackexchange.com/q/55423/289772
    if $DISPLAY == '' || $COLORTERM == 'xfce4-terminal'
        return
    endif

    # Purpose:{{{
    #
    # Change the cursor shape by sending some control sequences.
    #
    # They  are only  supported by  some terminals,  and terminal  multiplexers,
    # including st, urxvt and tmux.  But not by xfce4-terminal.
    #
    # We  must make  sure that  we're in  a terminal  which will  understand the
    # control sequences.
    #
    # Source:
    # https://raw.githubusercontent.com/jszakmeister/vim-togglecursor/master/plugin/togglecursor.vim
    # https://github.com/jszakmeister/vim-togglecursor/blob/master/doc/togglecursor.txt
    #}}}
    # Write the gui case first.{{{
    #
    # We may start the GUI from tmux (e.g. `gf` in copy-mode).
    # When that happens, `&term` has the value `tmux-256color` inside the GUI.
    # With this value, if you write the `&term =~ ...` case before the gui case,
    # 'gcr' would be wrongly handled by the former instead of the latter.
    #}}}
    if has('gui_running')
        # No blinking cursor in the GUI.
        # Where did you get this value?{{{
        #
        # It's  the  default  value;  we've just  included  `blinkon0`  in  each
        # argument-list, to disable the default blinking.
        #}}}
        &gcr = 'n-v-c:block-Cursor/lCursor-blinkon0'
            .. ',ve:ver35-Cursor-blinkon0'
            .. ',o:hor50-Cursor-blinkon0'
            .. ',i-ci:ver25-Cursor/lCursor-blinkon0'
            .. ',r-cr:hor20-Cursor/lCursor-blinkon0'
            .. ',sm:block-Cursor-blinkon0'
    elseif &term =~ '^\%(rxvt-unicode\|st\|tmux\|xterm\)-256color$'
        # For more info, see `:h termcap-cursor-shape`

        #  ┌ End Insert or replace mode
        #  │
        &t_EI = eval('CS_' .. SHAPE_NORMAL)
        #  ┌ Start Insert
        #  │
        &t_SI = eval('CS_' .. SHAPE_INSERT)
        #  ┌ Start Replace
        #  │
        &t_SR = eval('CS_' .. SHAPE_REPLACE)

        # Make sure the cursor has whatever shape we want right away:
        &t_ti = eval('CS_' .. SHAPE_NORMAL) .. &t_ti
        # Is it really necessary?{{{
        #
        # It depends.
        # We probably  have some plugins  which trigger  a leave insert  mode event,
        # which sends the sequence `&t_EI` to the terminal.  For this reason, atm we
        # don't need to set 't_ti'.
        #
        # But without any config, we need `&t_ti` to be correctly set.
        #}}}

        # We prepend a sequence to restore the shape of the cursor as a block.
        # Prepending instead of appending works better with tmux, according to the
        # original plugin author.
        &t_te = "\e[2 q" .. &t_te
    endif
enddef
#}}}

# Do *not* call this function from an autocmd listening to `VimEnter`.{{{
#
# It might be too late for some sequence stored in `&t_ti` to take effect.
# It's better to call it directly when this file is sourced.
#}}}
SetCursor()

# diffopt {{{2

# Do *not* ignore whitespace, with `iwhiteall`.{{{
#
# It would ignore significant differences.
# For example, in a shell script, this is wrong:
#
#     if [ $? -gt 0]; then
#                  ^
#                  there should be a space
#
# If we have 2 files, one with the error, the other without, we want to see this
# difference.
#
# ---
#
# Do not  ignore trailing whitespace with  `iwhite` either; if they  can somehow
# alter the behavior  of a program, and  we're comparing 2 versions  of the same
# program, one with trailing whitespace on some line, the other without trailing
# whitespace, we need to see this difference to understand what's happening.
#
# ---
#
# If you need to temporarily ignore whitespace differences, use our `co SPC` mapping.
#}}}

# the “patience” algorithm gives more readable diffs
# Why isn't patience the default?{{{
#
# The default algorithm is “myers”.
#
# 1. patience is slower:
#
#     https://marc.info/?l=git&m=133103975225142&w=2
#
# 2. besides:
#
#    > Myers has  been the universal  default diff  algorithm for so  long that
#    > enabling an alternative algorithm by default in a low-level component of
#    > our world (Git, Vim, etc.) could cause issues down the line.
#
# Source: https://www.reddit.com/r/vim/comments/a26phr/the_power_of_diff_vimways_124/eavzmke/
#}}}
set diffopt+=algorithm:patience

# only 3 lines of context above/below a changed line (instead of 6)
set diffopt+=context:3

# use only 1 column for the foldcolumn, instead of 2 (vertical space is precious)
set diffopt+=foldcolumn:1

# follow the 'wrap' option and leave as it is
set diffopt+=followwrap

# turn off diff mode automatically for a buffer which becomes hidden
set diffopt+=hiddenoff

# Use the indent heuristic for the  internal diff library, because it gives more
# readable diffs.
set diffopt+=indent-heuristic
# For more info, see:
# https://vimways.org/2018/the-power-of-diff/

# start diff mode with vertical splits (unless explicitly specified otherwise)
set diffopt+=vertical

# display {{{2

# When the last  line of the window  doesn't fit on the screen,  Vim replaces it
# with character  `@`.  We want Vim  to show us as  much text as possible  from the
# last line and, only when there  isn't anymore room, replace the remaining text
# with `@`.

set display+=lastline

# emoji {{{2

# May fix various issues when editing a line containing some emojis.{{{
#
# See: https://www.youtube.com/watch?v=F91VWOelFNE&t=174s
#
# If you still  have issues in tmux,  you may need to recompile  the latter with
# `--enable-utf8proc`.  Unfortunately, we  have an old `utf8proc`  atm (old OS),
# so we don't do it for now.  See our todo in `~/bin/upp`.
#}}}
set noemoji

# fillchars {{{2

# Replace ugly  separators (`|`)  used for vertical  splits, with  prettier utf8
# characters, to get a continuous line.
set fillchars=vert:┃

# pad end of title lines with spaces instead of hyphens
&fillchars ..= ',fold: '

# don't print a tilde at the start of the lines after the last buffer line
&fillchars ..= ',eob: '

# flp "{{{2

#                  ┌ recognize numbered lists
#                  ├──────┐
&g:flp = '\m^\s*\%(\d\+[.)]\|[-*+]\)\s\+'
#                            ├───┘
#                            └ recognize unordered lists

augroup MyDefaultFormatlistpat | au!
    # We've configured the global value of 'flp'.
    # Do the same for its local value in ANY filetype.
    au FileType * &l:flp = &g:flp
augroup END

# Is 'flp' used automatically? {{{
#
# No, you also need to include the `n` flag inside 'fo' (we did in `vim-par`).
# This tells Vim to use 'flp' to recognize lists when we use `gw`.
#}}}
# What's the effect?{{{
#
# Some text:
#
#     1. some very long line some very long line some very long line some very long line
#     2. another very long line another very long line another very long line another line
#
# Press `gwip` WITHOUT `n` inside 'fo':
#
#         1. some very long line some very long line some very long line some very
#     long line 2. another very long line another very long line another very long
#     line another line
#
# Press `gwip` WITH `n` inside 'fo', and the right pattern in 'flp':
#
#     1. some very long line some very long line some very long line some very
#        long line
#     2. another very long line another very long line another very long line
#        another line
# }}}
# Why use `&g:` instead of `setg`? {{{
#
# With `:setg`, you have to double  the backslashes because the value is wrapped
# inside a non-literal string.
#
# Also, you have to add an extra backslash for every pipe character
# (alternation), because one is removed by Vim to toggle its special meaning
# (command separator).
#
# So:    2 backslashes for metacharacters (atoms, quantifiers, ...)
#        3 backslashes for pipes
# }}}
# After pressing `gwip` in a list, how are the lines indented?{{{
#
# The indent of the text after the list header is used for the next line.
#}}}
# Compared to tpope ftplugin, our pattern is simpler. {{{
#
# He has added a third branch to describe a footnote.  Sth looking like this:
#
#     ^[abc]:
#
# https://github.com/tpope/vim-markdown/commit/14977fb9df2984067780cd452e51909cf567ee9d
# We don't know how it's useful, so we didn't copy it.
# The title of the commit is:
#
#     Indent the footnotes also.
# }}}
# Don't conflate the `n` flag in 'fo' with the one in 'com'. {{{
#
# There's zero link between the two.  This could confuse you:
#
#     setl com=f:-
#     &l:flp = ''
#
#             - some very long line some very long line some very long line some very long line
#             - another very long line another very long line another very long line another line
#
#     gwip
#             - some very long line some very long line some very long line some
#               very long line
#             - another very long line another very long line another very long
#               line another line
#
# It worked.  Vim  formatted the list as  we wanted.  But it's a  side effect of
# `-` being recognized as a comment leader, and using the `f` flag.
# For a numbered list,  you have to add the `n` flag in  `'fo'`, and include the
# right pattern in `'flp'`.  Why?
# Because you can't use a pattern inside `'com'`, only literal strings.
# }}}

# folding {{{2

# When starting  to edit another buffer  in a window, always  start editing with
# all  folds closed.   Technically, this  global option  sets the  initial local
# value of `'foldlevel'` in any window.
set foldlevelstart=0

# do *not* open folds when jumping with "(", "{", "[[", "[{", etc.
set foldopen-=block

# Close a fold even if it doesn't contain any line.
# Useful in our faq notes.
set foldminlines=0

# ft_ignore_pat {{{2

# Purpose:{{{
#
# We don't want `$VIMRUNTIME/filetype.vim` to set  the filetype of a `.log` file
# to `conf` simply because one of its first lines begin with a `#`.
#
# Indeed we often fold some log files using lines beginning with `#`.
#
# ---
#
# Similarly, we don't want a pseudo file in `/proc` – containing the output of a
# shell command – to be highlighted as a conf file just because one of its first
# lines start with a `#`:
#
#     $ vim <(echo "line 1\n# line 2\nline3")
#}}}
# Where did you find the beginning of the value?{{{
#
#     $VIMRUNTIME/filetype.vim:40
#}}}
g:ft_ignore_pat = '\.\%(Z\|gz\|bz2\|zip\|tgz\|log\)$\|^/proc/'
#                                             ^-^     ^-----^

# :grep {{{2

# Define rg as the program to call when using the Ex commands: `:[l]grep[add]`.
# Don't write `2>/dev/null`.{{{
#
# It's useless here because of the default value of `'shellpipe'`:
#
#     shellpipe=2>&1| tee
#               ^--^
#
# The errors would be still parsed as invalid entries in your qfl.
#}}}
set grepprg=rg

# Define how the output of rg must be parsed:
#
#               ┌ filename
#               │  ┌ line nr
#               │  │  ┌ column nr
#               │  │  │  ┌ error message
#               │  │  │  │
set grepformat=%f:%l:%c:%m,%f:%l:%m
#   │
#   └ default value:  `%f:%l:%m,%f:%l%m,%f  %l%m`

# hidden {{{2

# Hide a buffer when it's abandoned (instead of unloading it)

set hidden

# history {{{2

# Remember up to 1000 past commands / search patterns.
set history=1000

# includeexpr (gf) {{{2

&includeexpr = expand('<SID>') .. 'Inex()'

def Inex(): string
    var line: string = getline('.')

    # the path could contain an environment variable surrounded by curly brackets
    # What's the purpose of the second branch?{{{
    #
    # Handle the case where the cursor is on the environment variable name:
    #
    #     ${HOME}/bin/README.md
    #      ^----^
    #}}}
    #   The third branch?{{{
    #
    # Handle the case where the cursor is on `$`:
    #
    #     ${HOME}/bin/README.md
    #     ^
    #}}}
    var pat: string = '\m\C${\f\+}' .. '\V' .. v:fname .. '\m'
        .. '\|${\V' .. v:fname .. '}\f\+'
        .. '\|\%' .. col('.') .. 'c${\f\+}\f\+'
    var cursor_after: string = '\m\%(.*\%' .. col('.') .. 'c\)\@='
    var cursor_before: string = '\m\%(\%' .. col('.') .. 'c.*\)\@<='
    var pat1: string = cursor_after .. pat .. cursor_before
    var pat2: string = cursor_after .. '=\f\+' .. cursor_before
    if line =~ pat
        pat1 = matchstr(line, pat1)
        var env: string = matchstr(pat1, '\w\+')
        return substitute(pat1, '${' .. env .. '}', eval('$' .. env), '')

    # for lines such as `set option=path`, Vim tries to open `option=path` instead of `path`
    elseif line =~ pat2
        return matchstr(line, pat2)[1 :]
    # for lines such as `./relative/path/to/file`{{{
    #
    # especially useful when the buffer has been populated by sth like:
    #
    #     $ find -name '*.rs' | vipe
    #}}}
    elseif line =~ '^\./'
        return substitute(v:fname, '^\./', '', '')
    endif

    return v:fname
enddef

# indentation {{{2

set autoindent
set expandtab
# Why don't you set 'ts'?{{{
#
# It would mess the alignment in help files, where tabs are used with a width of
# 8 cells.  Besides, `'ts'` is *not* used when `'expandtab'` is set.
#}}}

# What's the effect of 'shiftround'?{{{
#
# When you press:
#
#    - `{count}>>`
#    - `{count}<<`
#    - `>{motion}`
#    - `<{motion}`
#
# ... on indented lines, if `'sr'` is enabled, the new level of indentation will
# be a multiple of `&sw`.
#}}}
#   Do *not* set it by default!{{{
#
# It may  cause an unexpected  result when we  indent a paragraph  (`>ip`), some
# lines of which have an indentation level which is not a multiple of `&sw`.
#
#     $ vim -Nu NONE +"set sr sw=4|pu=['foo', '  bar', 'baz']"
#     " press:  >ip
#     " result:
#
#         foo~
#         bar~
#         baz~
#
#     " expected:
#
#         foo~
#           bar~
#         baz~
#
# The relative indentation between them has been lost.
# They now all have the same  indentation level, while before `bar` had a bigger
# indentation level.
#}}}

# What's the effect of 'sw'?{{{
#
# It controls the number of spaces added/removed when you press:
#
#    - `{count}>>`
#    - `{count}<<`
#    - `>{motion}`
#    - `<{motion}`
#}}}
set shiftwidth=4

# When we press  `Tab` or `BS` in front  of a line, we want  to add/remove `&sw`
# spaces (and not `&ts` or `&sts`).
set smarttab

# By  default, (when  `smarttab` is  off), 'sts'  controls how  many spaces  are
# added/removed when we press `Tab` or `BS`.
#
#               ┌ disable 'sts'; use 'sw' instead
#               │
set softtabstop=-1

# The way we've configured 'smarttab' and 'sts', we can now modify how tabs
# are handled by Vim, in all contexts, with a single option: 'sw'.

# is_bash {{{2

# By default, Vim uses the Bourne shell syntax.
# We prefer to use `bash`.
#
# Indeed, most  of the time,  we'll use `bash`,  and some bash  constructs don't
# exist in Bourne shell, like commands substitutions (`$(...)`).
# These bashisms are considered as errors if `b:current_syntax` is `sh`.
#
# For more info, read `:h sh.vim`.
g:is_bash = 1

# It's not needed when a shell script has a shebang containing `bash`.
# But it's  useful when we've just  created a shell file,  because initially Vim
# may not  be able  to deduce the  right shelltype (no  typical filename  and no
# shebang yet).


# For more info, see this:
# https://github.com/neovim/neovim/issues/5559
# https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=848663

# invisible characters {{{2

# We define which glyph Vim must use to display certain special characters:
#
#    ┌────────────────────────┬───────────────────────────────┐
#    │ tab                    │ > or <> or <-> or <--> or ... │
#    ├────────────────────────┼───────────────────────────────┤
#    │ end of line            │ ¬                             │
#    ├────────────────────────┼───────────────────────────────┤
#    │ scroll unwrapped lines │ » «                           │
#    ├────────────────────────┼───────────────────────────────┤
#    │ no-break space         │ ∅                             │
#    ├────────────────────────┼───────────────────────────────┤
#    │ leading space          │ │                             │
#    └────────────────────────┴───────────────────────────────┘

set listchars=tab:<->,eol:¬,precedes:«,extends:»,nbsp:∅,lead:│

# lazyredraw {{{2
# What does it do?{{{
#
# Prevent the screen  from being redrawn while executing  commands which haven't
# been typed (e.g.: macros, registers).
# Also, postpone the update of the window title.
#}}}
# Why do you set it?{{{
#
# - Because of the previous description.
#
# - Setting this option prevents the screen from flickering when we use a custom
#   mapping which makes the cursor move far from its initial position, then
#   come back (e.g. `*`).
#
# - junegunn, tpope, justinmk, blueyed,  mhinz ... they all  set this option.
#}}}
# Is there any pitfall?{{{
#
# Yes.
# Because  of this  option, sometimes,  we may  need to  execute `:redraw`  in a
# (function called by a) mapping.
#}}}
set lz

# showmatch {{{2

# don't show matching brackets;
# it makes the cursor jumps unexpectedly which is too distracting
set noshowmatch
# Note that if you set the option in the future, you may face an issue (github #4867).{{{
#
# You may fix it if you:
#
#    - reset `'showcmd'`
#    - reset `'showmatch'`
#    - set `'matchtime'` to 0
#    - empty `'indentexpr'`
#    - replace `normal! ^` with sth like:
#
#         if getline('.') =~ '^\s*$'
#             call cursor('.', col('$'))
#         else
#             call search('^\s*\zs\S', 'bc', line('.'))
#         endif
#
#      in `$VIMRUNTIME/indent/html.vim` (function `HtmlIndent()`)
#
# Or you could install this autocmd which resets `'showmatch'` in html buffers:
#
#     augroup DisableShowmatchInHtmlFiles | au!
#         au BufEnter,WinEnter * &showmatch = &ft != 'html'
#     augroup END
#}}}

# modelines {{{2

# If 'modeline' is set, and the value of 'modelines' is greater than 0, then Vim
# will search inside  the first/last `&mls` lines of the  buffer and execute any
# `:set` commands it finds.

# This allows easy file-specific configuration.
# But we don't like that, for security reasons.

set nomodeline
set modelines=0

# mouse {{{2

# Enable mouse usage (all modes)

set mouse=a

# nrformats {{{2

# when using the `C-a` and `C-x` commands, don't treat the numbers as octal
# E.g.:
#     `C-a` on 007
#     010  ✘~
#     `C-a` on 007
#     008  ✔~
set nrformats-=octal

# ignore a negative sign; makes the commands more intuitive when dealing with dates/zipcodes/...
set nrformats+=unsigned

# path {{{2

# Where should `:find` and `gf` look for a file?
# Why the numeric suffix after `**`?{{{
#
# It adds a limit on the recursion of `**`.
#
# At the moment, we have this file in our filesystem:
#
#     ~/.vim/plugged/vimtex/autoload/unite/sources/vimtex.vim
#
# Suppose our  current working directory  in Vim is  `~/.vim`, and this  path is
# written in a file:
#
#     sources/vimtex.vim
#
# As you can see, between the path of the cwd and this path, 4 directories are missing:
#
#     ~/.vim/plugged/vimtex/autoload/unite/sources/vimtex.vim
#            ^----------------------------^
#
# So, if you write `3` after `**`, you won't be able to open `sources/vimtex.vim`
# in a new split, by pressing `C-w f`.
# But you will if you write `4` instead of `3`.
#
# The bigger the number,  the more directories Vim will have to  look into for a
# path, when you press `gf`, `C-w f`, ... or when you run `:find`, `:sfind`, ...
# and the more time it may take to find a file.
# This is especially annoying  when the file path can't be  found; Vim will have
# to look into  *all* subdirectories of the  cwd, up to the  given depth, before
# realizing it's not there.
#
# Inspiration: https://begriffs.com/posts/2019-07-19-history-use-vim.html#include-and-path
#
#    > The `**`  with a  number like `**3`  bounds the depth  of the  search in
#    > subdirectories. It’s wise  to add  depth bounds where  you can  to avoid
#    > identifier searches that lock up.
#}}}
set path=.,**5
#        │ │
#        │ └ and in the working directory recursively
#        └ look in the directory of the current buffer, non-recursively

# Its default value was:
#
#     .,/usr/include,,
#     │ │            │
#     │ │            └ empty value = working directory
#     │ └ /usr/include directory
#     └ directory of the current buffer

# Idea: You could also include the item `.git/..;`.{{{
#
# It  describes the  parent  directory  of `.git/`,  the  latter being  searched
# recursively upward in the file system; IOW,  it describes the root of your git
# project.
#
# We don't need it atm, because we have  something better: we set the cwd to the
# root directory of a git project, so `**5` looks not only in the project's root
# directory, but  recursively down into  it.  Still, it  could be useful  in the
# future...
#}}}

# scroll {{{2

# display at least 3 lines above/below the cursor
set scrolloff=3

# display at least 3 columns before/after the cursor
# when scrolling horizontally an unwrapped long line
set sidescrolloff=3

# minimum nr of columns to scroll horizontally
set sidescroll=5

# if we  scroll horizontally  on a very  long line while  we have  several bound
# windows, replicate the scroll across all of them
set scrollopt+=hor

# shortmess {{{2

# What does it do?{{{
#
# Prevent Vim  from printing the "ATTENTION" message when  an existing swap file
# is found.
#}}}
# If I edit a file in a second Vim instance, will the change be reflected in the first?{{{
#
# Yes, it should whenever `CursorHold` is fired.
# Because, in `vim-xterm`, we have:
#
#    - a custom autocmd executing `:checktime`
#
#        it will check whether the file has been changed
#        outside the current Vim instance
#
#    - set 'autoread'
#
#        it will automatically reload the file if the file has been changed
#        outside the current Vim instance
#}}}
# What happens if I edit a file in a 2nd Vim instance, get back to the 1st, and change it before `CursorHold`?{{{
#
# In theory, Vim should warn you:
#
#     WARNING: The file has been changed since reading it!!!
#     Do you really want to write to it (y/n)?
#
# If you  don't want to lose the  changes from the 2nd Vim  instance, you should
# answer no.
# Then, wait for CursorHold, or execute `:checktime`.
#
# In practice, there  should be no such message, because,  in vim-xterm, we have
# an autocmd listening  to `FocusGained` and `FocusLost` which  reloads the file
# if it has been changed outside the current Vim instance.
#}}}
# Why don't you enable the flag anymore?{{{
#
# We deal with the "ATTENTION" message with an autocmd listening to `SwapExists`.
#}}}
# set shm+=A

# enable all sort of abbreviations
set shortmess+=a

# Don't print |ins-completion-menu| messages.  For example:
#
#    - "-- XXX completion (YYY)"
#    - "match 1 of 2"
#    - "The only match"
#    - "Pattern not found"
#    - "Back at original"
set shortmess+=c

# don't print the file info when editing a file, as if `:silent` was used
set shortmess+=F

# When starting Vim without any argument, we enter into an unnamed buffer
# displaying a long message; hide this message.
set shortmess+=I

# don't print "search hit BOTTOM, continuing at TOP"
set shortmess+=s

# don't print "written" or "[w]" when writing a file
set shortmess+=W

# signcolumn {{{2

# We want a margin between the left of the screen and the text.

# Why an autocmd?{{{
#
# Suppose you preview a file in a popup.
# In that popup, `'scl'` – like all  window-local options – will be reset to
# its default value, which is `auto`.
#
# Now, at the same time, you start editing the same file in a regular window.
# In the latter, the value will *also* be set to `auto`, which means that if
# your buffer doesn't contain any sign, the sign column won't be visible; we
# want it to be *always* visible.
#}}}
augroup SetSigncolumn | au!
    au BufWinEnter * if win_gettype() == 'popup' | setl scl=yes | endif
    # We don't want `'signcolumn'` to be enabled in a terminal buffer.{{{
    #
    # Otherwise, it's disabled when we're in terminal-job mode, and enabled when
    # we enter terminal-normal mode.  This makes all the text move one character
    # forward/backward, which is distracting.
    #}}}
    au TerminalWinOpen * setl scl=no
augroup END

# Isn't the autocmd enough?{{{
#
# `BufWinEnter` is not always fired; e.g.  it's not fired when you display a
# dirvish buffer  in a  window.  In  such a case,  it's good  to have  set a
# global value which all windows should inherit.
#}}}
set signcolumn=yes

# spelloptions {{{2

#     set spo= | echo spellbadword('TheCamelWord')
#     ['TheCamelWord', 'bad']~
#
#     set spo=camel | echo spellbadword('TheCamelWord')
#     ['', '']~
#
#                                                typo
#                                                v
#     set spo=camel | echo spellbadword('TheCamelzWord')
#     ['Camelz', 'bad']~
set spelloptions=camel

# startofline {{{2

# Some commands move the cursor to the first non-blank of the line:
#
#         c-d, c-u, c-b, c-f, G, H, M, L, gg, :123, :+    (motions)
#         dd, <<, >>                                      (operators)
#         c-^, :bnext, :bprevious
#
# We prefer the cursor to stay on the same column as before.
set nostartofline

# switchbuf {{{2
#         How to configure 'swb'?{{{

# You give it a list of values.  Example:
#
#     set switchbuf=useopen,usetab
#}}}
#         What does it do?{{{

# If you  try to open a  split to display  a loaded buffer with  `:sbuffer`, Vim
# will first check  whether the buffer is  already displayed in a  window of the
# current tab page (`useopen`), or in another tab page (`usetab`).
# And if  it finds one,  instead of  creating a split,  it will simply  give the
# focus to this window.
#}}}
#         Which commands honor 'swb'?{{{

# quickfix commands, when jumping to errors (`:cc`, `:cn`, `cp`, etc.).
# All buffer related split commands: `:sbuffer`, `:sbnext`, `:sbrewind`...
#}}}
#         Which pitfalls can it create?{{{

# When  you move  in the  qfl quickly,  the focus  can change  from a  window to
# another and it's distracting.
# Besides, once the focus has changed, if you advance further in the qf list, it
# can make you lose the buffer which was opened in the window.
#}}}
#         Are there workarounds?{{{

# You could temporarily reset `'swb'` while:
#
#    - the qf window is opened; in a qf filetype plugin:
#
#         if !exists('swb_save')
#             var swb_save: string = &swb
#             set swb=
#         endif
#
#         au BufWinLeave <buffer> &swb = swb_save ?? &swb | swb_save = ''
#
#    - when you execute some commands / mappings
#
#      you would need to create wrapper around default normal commands
#      with a try conditional, and a finally clause, to empty 'swb'
#      and/or,
#      you would need to install an autocmd listening to CmdlineLeave,
#      to set 'swb' only when you use some Ex commands
#
# You could install unimpaired-like mappings to toggle the value of `'swb'`.
#}}}
#         Why don't you set it?{{{
#
#    - Too many issues.
#    - We don't need it atm.
#    - To give the focus to an already displayed buffer, there are alternatives:
#
#         :FzWindows  (<space>fw)
#         :drop       (:drop ~/**/*some_file)
#}}}
#}}}2
# synmaxcol {{{2

# don't syntax-highlight long lines
set synmaxcol=250
#             │
#             └ weight in bytes
#               any character prefixed by a string heavier than that
#               will NOT be syntax highlighted
# }}}2

# t_ {{{2
if !has('gui_running')
# BD BE PS PE {{{3

# What's the bracketed paste mode?{{{
#
# A  special  mode in  which  the  terminal surrounds  a  pasted  text with  the
# sequences `Esc [ 200 ~` and `Esc [ 201 ~`.
#}}}
#   How is it useful?{{{
#
# Thanks to these sequences, the application  which receives the text knows that
# it was  not typed  by the  user, but pasted,  and that  it should  disable the
# interpretation of what it considers to be special characters.
#
# MWE:
#
#     $ vim -Nu NONE +'let @+ = "clipboard\e:echom \"malicious code injected\"\ri"' +startinsert
#     C-S-v
#     Esc
#     :mess
#     malicious code injected~
#
# In this  example, the escape,  colon and  carriage return were  interpreted as
# "enter normal mode", "enter command-line mode", and "run command".
#
# As you can see,  this can be dangerous, because if you  don't pay attention to
# what you've copied, Vim may run an unexpected command.
#
# Other MWE:
#
#     $ vim -Nu NONE +'let @+ = "Level 1\n    Level 2\n    Level 2\nLevel 1"' +'setl ai' +startinsert
#     C-S-v
#     Level 1~
#         Level 2~
#             Level 2~
#             Level 1~
#
# Notice how the indentation of some lines is increasingly wrong.
# This is because when you enter a new line, if `'ai'` is set, Vim automatically
# autoindents the new line.
#}}}
#   Is it 100% reliable?{{{
#
# No, unfortunately.
#
# The protection  offered by  the bracketed  paste mode can  be bypassed  if the
# pasted text contains `\e[201~`; the latter will end the bracketed mode prematurely.
# This works  because, before sending the  text to the application,  some (all?)
# terminals do not properly filter escape sequences before adding their own.
#
# See the second example on this page:
# https://thejh.net/misc/website-terminal-copy-paste
#
# ---
#
# Also, the  bracketed paste mode does  not prevent Vim from  auto-indenting the
# text when inserting the contents of a register with `C-r`.
#
# MWE:
#
#     $ vim -Nu NONE +'set ai' +':let @a = "Level 1\n    Level 2\n    Level 2\nLevel 1"'
#     i C-r a
#
# If `'paste'` is reset, you'll get:
#
#     Level 1~
#         Level 2~
#             Level 2~
#             Level 1~
#
# If `'paste'` is set, you'll get:
#
#     Level 1~
#         Level 2~
#         Level 2~
#     Level 1~
#
# You can avoid the issue by pasting from normal mode (`"ap`), or inserting with
# `C-r C-o` or `C-r C-p`.
#}}}
#   How many software layers need to support this mode for it to work properly?{{{
#
# The terminal and the application which is running in the foreground.
#
# You probably don't need to configure the  terminal; it just needs to be recent
# enough.   Except  for  tmux, which  is  a  special  case.   When you  use  the
# `paste-buffer` command, you must pass it the `-p` option.
#
# And  note that  whether the  foreground  application needs  to be  configured,
# depends on its default configuration.
# For example, zsh automatically sets the parameter `zle_bracketed_paste`:
#
#    > This two-element array  contains the terminal escape  sequences for enabling
#    > and  disabling  the  feature. These  escape sequences  are  used  to  enable
#    > bracketed paste when ZLE is active and disable it at other times.  Unsetting
#    > the  parameter has  the  effect  of ensuring  that  bracketed paste  remains
#    > disabled.
#
# Which enables the bracketed paste mode.
# But if you unset the parameter, you disable the mode.
# So, it's just a choice from the devs to enable the mode by default.
# Note that you can see the current value of the parameter by running:
#
#     $ typeset zle_bracketed_paste
#
# See: `man zshparam /zle_bracketed_paste`
#
# OTOH, for bash, you need to set the readline variable `enable-bracketed-paste`.
# It is not set by default.
#}}}

#   How to make the terminal enter/leave this mode while Vim is running?{{{
#
# Set the options `'t_BE'` and `'t_BD'`, with the values `CSI ? 2004 h`
# and `CSI ? 2004 l`.
# These sequences are documented at `CSI ? Pm h/;/Ps = 2 0 0 4`
# and `CSI ? Pm l/;/Ps = 2 0 0 4`.
#
# When the terminal enters raw mode,  Vim sends to it `&t_BE` (Bracketed paste Enable).
# And when the terminal leaves raw mode, Vim sends `&t_BD`.
# So,  if  these options  are  properly  set,  the terminal  will  automatically
# enable/disable the bracketed paste mode whenever it enters/leaves raw mode.
# IOW, the raw and bracketed paste modes will be synchronized.
#
# You also need  to set the options  `'t_PS'` and `'t_PE'` with  the values
# `CSI 200 ~` and `CSI 201 ~`. Probably  to let Vim know which sequences it must
# interpret as the beginning/end of a pasted text.
#
# For more info, see `:h xterm-bracketed-paste`.
#
#    > When the 't_BE' option is set then  't_BE' will be sent to the terminal when
#    > entering "raw"  mode and 't_BD'  when leaving  "raw" mode.  The  terminal is
#    > then  expected to  put 't_PS'  before pasted  text and  't_PE' after  pasted
#    > text.  This  way Vim can separate  text that is pasted  from characters that
#    > are typed.  The pasted text is handled  like when the middle mouse button is
#    > used, it is inserted literally and not interpreted as commands.
#}}}
#     Now you're talking about yet another mode!  What's this raw mode?{{{
#
# A mode in which the terminal driver doesn't interpret the characters it receives.
#
#    > The  terminal can  be placed  into  "raw" mode  where the  characters are  not
#    > processed by the terminal driver, but are sent straight through (it can be set
#    > that INTR and QUIT characters  are still processed). This allows programs like
#    > emacs and vi to use the entire screen more easily.
#
# Source: https://unix.stackexchange.com/a/21760/289772
#
# See also `:h raw-terminal-mode`.
#}}}
#       When Vim is running, is the terminal in raw mode?{{{
#
# I think it depends.
#
# Most of the time, it must be, so  that Vim can receive all the keys pressed by
# the user, and interpret them however it wants.
# Among other things, this allows the user to remap `C-c`, `C-u`, `C-d`, ...
# which otherwise would be interpreted by the line discipline of the terminal:
#
#     $ stty -a | grep 'intr\|kill'
#     intr = ^C; quit = <undef>; erase = ^?; kill = ^U; eof = ^D; eol = <undef>;~
#            ^^                                     ^^        ^^
#
# However, sometimes, Vim temporarily switches to cooked mode.
# This allows  the user to end  an external process started  with `system()`, by
# pressing `C-c`.
#}}}
#       What's the relationship between raw mode and bracketed paste mode?{{{
#
# I don't think there's one.
# I  think  they  are  orthogonal,  i.e. the  terminal  can  enable/disable  one
# independently of the other's state.
#}}}

# Why can't we enable the bracketed paste mode for the whole Vim session?{{{
#
# Why this dance: enter raw mode → enable bracketed paste
#                 leave raw mode → disable bracketed paste
#
# Instead of:     enter Vim → enable bracketed paste
#                 leave Vim → restore bracketed paste as it was before Vim was started
#
# Theory:
# Remember that you can start an external process from Vim (e.g. via `system()`).
# While Vim is running, the foreground process may not be Vim, and it may or may
# not want the terminal to be in bracketed paste mode.
# I think  that's why  Vim disables  the bracketed paste  mode when  leaving raw
# mode;  so that  the foreground  process does  not receive  sequences which  it
# doesn't understand.
#
# See: https://github.com/vim/vim/issues/1638
#}}}

# Why `&t_BE == ''`?{{{
#
# Because Vim  already sets these options  for some terminals (e.g.  xterm), but
# not all.
# In particular, it fails to set them for st, and for any terminal in tmux.
# Presumably because it  only recognizes a few terminals (via  `&term`) which it
# knows how to configure.
#}}}
if &t_BE == ''
    &t_BE = "\e[?2004h"
    &t_BD = "\e[?2004l"
    &t_PS = "\e[200~"
    &t_PE = "\e[201~"
endif

# RV {{{3

# Clearing this option may avoid weird bugs in xterm:
# https://github.com/vim/vim/issues/4836
# https://github.com/vim/vim/issues/6206
# https://github.com/vim/vim/issues/2581
if &term =~ 'xterm'
    set t_RV=
endif

# Ts, Te {{{3

# necessary when `&term` is not `xterm` to be able to apply the strikethrough attribute to text:{{{
#
#     $ vim -Nu NONE +'hi MyStrikeThrough cterm=strikethrough'
#     :hi MyStrikeThrough
#}}}
&t_Ts = "\e[9m"
&t_Te = "\e[29m"

# fd, fe {{{3

# Let's make sure that `FocusGained` and `FocusLost` work in xterm+tmux.
# See: `:h xterm-focus-event`.
if &term =~ 'tmux' && !!getenv('XTERM_VERSION') && &t_fd == ''
    exe "set t_fd=\e[?1004l"
    exe "set t_fe=\e[?1004h"
endif

# kB {{{3

if &term =~ '^st\%(-256color\)$'
    # `<S-Tab>` may not work in st, because Vim may not set `t_kB`.{{{
    #
    # Right now, for st, we use the terminfo description from the ncurses developer.
    # It turns out that it cancels the `kcbt` capability:
    #
    #     st-256color|stterm-256color|simpleterm with 256 colors,
    #             ccc@,
    #             initc@, oc@, use=xterm+256color, use=st,
    #                                              ^----^
    #     st|stterm| simpleterm,
    #             use=st-0.7,
    #             ^--------^
    #     st-0.7|simpleterm 0.7,
    #             ccc,
    #             dim=\E[2m,
    #             initc=\E]4;%p1%d;rgb\:%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*
    #                   %{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X\E\\,
    #             kcbt@, kent@, oc=\E]104\007,
    #             ^---^
    #
    # As a result, Vim does not set `t_kB` when `&term` is `st`.
    #}}}
    exe "set t_kB=\e[Z"
endif

# ut {{{3

# We don't really need this atm.
# It's only useful if you start Vim inside `xterm-kitty` (and outside tmux).
if &term =~ '-256color$\|^xterm-kitty$'
    # Disable Background Color  Erase (BCE) so that color  schemes render properly
    # when inside 256-color tmux and GNU screen.
    # See: http://snk.tuxfamily.org/log/vim-256color-bce.html
    set t_ut=
endif
#}}}3
endif
# }}}2
# tags {{{2

# When searching the tags file, ignore the case unless an upper case letter is used.
set tagcase=smart

# What's the default value? {{{
#
#     ./tags,./TAGS,tags,TAGS
#
# Explanation:
#
#    ┌────────┬──────────────────────────────────────────────────────────────────┐
#    │ ./tags │ file in the directory of the CURRENT FILE and whose name is tags │
#    ├────────┼──────────────────────────────────────────────────────────────────┤
#    │ tags   │ file in the WORKING DIRECTORY             and whose name is tags │
#    └────────┴──────────────────────────────────────────────────────────────────┘
#}}}
# What's the effect of our new value `./tags;`?{{{
#
# `;` tells Vim to look *up* recursively.
# It's the opposite of `**` which looks *down* recursively.
# You could also include the value `tags;`:
#
#     set tags=./tags;,tags;
#
# Explanation:
#
#    ┌─────────┬──────────────────────────────────────────────────────────────┐
#    │ ./tags; │ file in the directory of the CURRENT FILE, then              │
#    │         │ in its parent directory, then in the parent of the parent    │
#    │         │ and so on, recursively                                       │
#    ├─────────┼──────────────────────────────────────────────────────────────┤
#    │ tags;   │ file in the WORKING DIRECTORY, then in its parent directory, │
#    │         │ then in the parent of the parent and so on, recursively      │
#    └─────────┴──────────────────────────────────────────────────────────────┘
#
# The value of `'tags'` influences commands such as `:tj` and `:ltag`.
# It also influences tag completion (`:h i^x^]`), which looks for matches in the
# tags files whose paths are stored in the value of `'tags'`.
#}}}
set tags=./tags;
# Why could a command such as `:tj` or `:ltag` include some irrelevant tags? {{{
#
# It's probably due to the combination of two factors:
#
#    - vim-gutentags is enabled
#
#    - you have a tags file in a big directory containing many different
#      projects
#
#      For example,  you may have  executed `$ ctags  -R` by accident  in a
#      wrong directory, such as `~/.vim` or `~/.vim/plugged`.
#
#      Or maybe it  was executed by `vim-gutentags`  because you accidentally
#      created  a git  repo (via  something like  `git {add|commit|push}`),
#      where you shouldn't have.
#
# `vim-gutentags`  appends the  global  value of  `'tags'`  to the  buffer-local
# value, for buffers inside a git repo.
#
# So, if  `./tags;` and/or `tags;`  is inside the  global value of  `'tags'`, it
# will also end up in the local value.
# And thus, when  you'll be working on a project,  like the `vim-session` plugin
# for example, here's the kind of local value that `'tags'` will contain:
#
#     tags=~/.vim/plugged/vim-session/tags,./tags;,tags;
#                                                ^     ^
# Because  of  the  semicolons, Vim  may  include  a  wrong  tags file  such  as
# `~/.vim/tags`.  If that happens, you'll end up with way too many tags.
#}}}
# What to do if that happens? {{{
#
# -  Try  to configure  `vim-gutentags` and  prevent it  from including  the
#    global value of `'tags'` inside the local one.
#
# -  Remove wrong tags files (`rm(1)`), and make sure there's no `.git/`
#    directory outside a valid  repository.
#    Otherwise, `vim-gutentags` may recreate a tags file.
#}}}
# TODO: Find a  way to configure gutentags  so that it never  appends the global
# value of `'tags'` to the local value.

# In our vimrc file, we want the ability to jump from the call of a function
# defined in `myfuncs.vim`, to its definition, with `C-]`.
augroup TagsVimrc | au!
    au BufReadPost $MYVIMRC setl tags=$HOME/.vim/autoload/tags
    # update the tags file whenever we write `myfuncs.vim`
    au BufWritePost $HOME/.vim/autoload/myfuncs.vim
        \ system('ctags -f $HOME/.vim/autoload/tags $HOME/.vim/autoload/myfuncs.vim')

    # Don't source the zshrc automatically.{{{
    #
    # This would work:
    #
    #     au! BufWritePost .zshrc sil system('source ' .. expand('<afile>:p:S'))
    #
    # But I'm concerned that after editing the zshrc and doing some experiments,
    # we end up in a shell  whose state is really weird, producing hard-to-debug
    # issues.
    # If that happens, we may have an issue in Vim.
    # We'll restart Vim, and the issue will probably persist.
    # But we won't necessarily think about starting Vim from a new shell.
    # We often work in Vim from the same shell for hours.
    #
    # I don't like that.
    # Leave the shell alone.
    # We already have the habit to open a new shell whenever we edit the zshrc anyway.
    #
    # Fucking the vimrc is ok, because we have a mapping to restart Vim.
    # Fucking the zshrc is *not* ok, because we don't have any such mapping.
    # At best, we can open a new shell, but not reset the current one.
    #}}}
augroup END

# temporary files:  undo, swap, backup {{{2

# FIXME:
# Review all this section.
# Finish  implementing proper  backup (you  probably don't  want to  backup huge
# files though, nor temporary files; it would quickly take too much space).
# Read files in `backup` session.
#
# ---
#
# Read these:
# https://www.zachpfeffer.com/single-post/Practice-Recovering-a-File-in-Vim
# https://begriffs.com/posts/2019-07-19-history-use-vim.html#backups-and-undo
#
# ---
#
# Try to expose the info given by `swapinfo()` via a custom command.
# Maybe it could open a scratch buffer to display the info.

# TODO: The undo/backup files are never removed by Vim, and they can take a lot of space over time.{{{
#
# You probably want to remove:
#
#    - the ones which were written for files in `/tmp/` or `/run/` (`/etc`? `/usr`? `/var`?):
#
#         $ find ~/.vim/tmp/undo -path '*/%run%*' -print0 | xargs -0 rm
#         $ find ~/.vim/tmp/undo -path '*/%tmp%*' -print0 | xargs -0 rm
#
#    - the ones written for a pdf:
#
#         $ find ~/.vim/tmp/undo -name '*.pdf' -print0 | xargs -0 rm
#
#    - the ones written for a file which has not been modified since a long time (3 months?)
#
#    - the ones written for a file which doesn't exist anymore
#
#      For example if this undo file exists:
#
#         ~/.vim/tmp/undo/%path%to%file
#
#      But `/path/to/file` does not exist anymore, then we should remove the undo file.
#
#    - the ones written for a file which takes more than 20 megs
#      Atm, my biggest "valid" undo file takes 5 megs.
#      The ones above are not valid (pdfs, non-existing files, ...).
#
# Find a way to run the right shell commands (sth like `$ find ... -exec rm ... +`)
# automatically via a cron job once a week/month.
#
# ---
#
# Maybe we should disable `'undofile'` in certain directories (not sure I want that).
# Or, enable `'undofile'` only in our home (not sure I want that either).
# Note that you can prevent the creation of backup files for a given directory with:
#
#     set backupskip+=/some/dir/*
#
# ---
#
# Read this: https://vi.stackexchange.com/a/53/13370
#}}}

if !isdirectory($HOME .. '/.vim')
    mkdir($HOME .. '/.vim', '', 0o700)
endif

# Put all swap files in `~/.vim/tmp/swap/`.{{{
#
# The default value is:
#
#     .,~/tmp,/var/tmp,/tmp
#     ^
#
# With this  value, if you  edit a file,  the swap file  will be created  in the
# parent directory of the file.
# IOW, your  swap files will be  scattered across your whole  filesystem; that's
# untidy, especially when Vim crashes, and the swap files persist.
#}}}
# Why the trailing double slash?{{{
#
# It's  useful if  you edit  two  files with  the  same name,  but in  different
# directories.
# Suppose you edit `/tmp/dir1/file` and `/tmp/dir2/file`.
#
# Without the trailing double slash, both swap files would have the same name.
# The last one to be created would probably overwrite the previous one.
#
# With the trailing double slash, the name  of each swap file is unique, because
# it includes  the full  path to the  file it's associated  to; the  slashes are
# replaced by percent signs.
# From `:h 'dir`:
#
#    > For Unix and Win32, if a directory ends in two path separators "//", the
#    > swap file name will be built from the complete path to the file with all
#    > path separators substituted to percent  '%' signs. This will ensure file
#    > name uniqueness in the preserve directory.
#}}}
set directory=$HOME/.vim/tmp/swap//

# make sure the swap directory exists
if !isdirectory(&directory)
    mkdir(&directory, 'p', 0o700)
endif

# enable persistent undo
set undofile

# choose location of undo files
set undodir=$HOME/.vim/tmp/undo

# If you lose the undo history after  a buffer reload (or write), you might want
# to increase  the value of  this option.  But beware  that it causes  the whole
# buffer to  be stored  in memory,  which in turn  causes Vim  to have  a larger
# memory footprint.
set undoreload=10000

# make sure the undo directory exists
if !isdirectory(&undodir)
    mkdir(&undodir, 'p', 0o700)
endif

set backup

# See `:h backup-table` to understand when Vim creates a backup file.
set backupdir=~/.vim/tmp/backup//
set backupskip+=/run/*

# make sure the backup directory exists
if !isdirectory(&backupdir)
    mkdir(&backupdir, 'p', 0o700)
endif

# timeout {{{2

# enable a timeout for mappings
set timeout

# same thing for key codes
set ttimeout

# set the timeout for mappings to 3s
set timeoutlen=3000

# ... and 6 ms for key codes.
# Previously we used 50ms, but 6 is the max value to prevent this error:{{{
#
#    1. insert sth wrong
#    2. hit escape
#    3. hit u (undo)    →    M-u: uppercase next word
#
# Vim recognizes `M-u` as `Esc + u`, because of this line in vim-readline:
#
#     exe "set <m-u>=\eu"
#
# So, if we press `Esc` then `u` in less than `&ttimeoutlen` ms, Vim thinks that
# we've pressed `M-u`.   To avoid this kind of misunderstanding,  we need to set
# `'ttimeoutlen'` as low as possible.
#}}}
#   What other issue does this fix?{{{
#
# The default value of `'ttimeoutlen'` is -1.
# It means that it copies the value of `'timeoutlen'`, which we've set to 3s.
# Now suppose that you're in insert mode, and want to get back to normal mode by
# pressing `Esc`: you'll have to wait 3s.
#
# Why?
# Because  some special  keys (e.g. F1,  F2, ...,  left, right,  ...) produce  a
# sequence of terminal key codes beginning with `Esc`.
# So, Vim has to  wait `'ttimeoutlen'` ms to know whether  the `Esc` was pressed
# manually or it was part of some sequence of terminal key codes.
#}}}
#   What issue(s) can this cause?{{{
#
# If Vim is running on a remote machine, a low value could be insufficient for a
# key code to reach the latter.
#
# For example,  if we press `M-u`  and our local  machine sends `Esc +  u`, more
# than `&ttimeoutlen` ms could elapse  between `Esc` reaching the remote machine
# and `u`.  In  that case, Vim will  think we pressed `Esc` then  `u` instead of
# `M-u`.
#
# ---
#
# With a low value, the contents of a recording is weird:
#
#     $ vim -Nu NONE +'set ttimeoutlen=6'
#     qqq
#     qq A Esc q
#     :echo @q
#     A^[<80><fd>a~
#
# It makes reading  the contents of a register, and  `/tmp/.vimkeys` harder than
# it should be.
#
# Note that it disappears below a certain threshold which can vary (≈ 300ms?).
#
# See: https://github.com/vim/vim/issues/4725
#}}}
set ttimeoutlen=6

# ttymouse {{{2

# This option may help when you need to interact with Vim with your mouse.{{{
#
# In  particular, it  may help  resizing a  tmux pane  where Vim  is running  by
# dragging its status line: http://superuser.com/a/550482
#
# It may also help clicking after the 223rd column.
#
# ---
#
# The best value seems to be `sgr`.
# From `:h 'ttym`:
#
#    > The "sgr"  value will be set  if Vim detects Mac  Terminal.app, iTerm2 or
#    > mintty, and when the xterm version is 277 **or higher**.
#
# It's the value used by Vim when it detects a recent xterm.
#}}}
set ttymouse=sgr

# updatetime {{{2

#              ┌ our current chosen value
#              │  if you change it, do the same in:
#              │
#              │          ~/.vim/plugged/vim-readline/autoload/readline.vim
#              │
#              │  function:
#              │
#              │          `readline#do_not_break_macro_replay()`
#              │
set updatetime=2000

# viminfo {{{2

# useful to save variables such as `g:MY_VAR`
set viminfo+=!

# virtualedit {{{2

# In visual-block mode, let us move the cursor on a cell where there's no character:
#
#    - in the middle of a tab
#    - beyond the last char on a line
#
# Useful to select a rectangle out of irregular (different lengths) lines.
set ve=block
# Do *not* make the constant name start with an uppercase character.{{{
#
# It would cause all sorts of issues because of the `!` flag which we include in `'viminfo'`.
#
# Don't  try to  be  smart and  install  a `VimLeavePre`  autocmd  to unlet  the
# variable (it wouldn't always work; e.g. when debugging a crash).
# Don't try a  `VimEnter` autocmd to delay `:lockvar` either;  I'm sure we would
# end up finding some other edge case where it fails.
#}}}
const g:_ORIG_VIRTUALEDIT = &ve
augroup HoistVe | au!
    # TODO: The `[ve=onemore]` flag is visible when selecting some text and pressing `sa`.{{{
    #
    # It should not be visible.
    #
    # The only solution I can see right now, is to send a PR to the vim-sandwich
    # dev, which prefixes `:set` with `:noa`.
    #}}}
    au User MyFlags statusline#hoist('global',
        \ '%{&ve isnot# "' .. &ve .. '" && mode(1) ==# "n" ? "[ve=" .. &ve .. "]" : ""}', 8,
        \ expand('<sfile>:p') .. ':' .. expand('<sflnum>'))
    au OptionSet virtualedit timer_start(0, () => execute('redrawt'))
augroup END

# wildignore(case) {{{2

# Why tweaking `'wildignore'`?{{{
#
# Some files can't be edited by Vim.
# Or they should not be edited.
#
# We never want to see them:
#
#    - in a dirvish listing
#    - on the command-line after a tab completion
#    - in the output of `expand()`, `glob()`, `globpath()`
#}}}
set wildignore&vim

# Warning:
# Do *not* add `*/.git/*` to `'wig'`!{{{
#
# It breaks the `:drop` command which we use in `Tapi_drop()`:
#
#     $ vim +term
#     $ cd /tmp && git clone https://github.com/junegunn/fzf && cd fzf
#     $ sed -i '1d' LICENSE && git add . && git commit -v
#     Error detected while processing function Tapi_drop:~
#     line   14:~
#     E479: No match~
#
# That's because `:drop` honors `'wildignore'`, which  makes it fail to open any
# file whose path is matched by the option.
#
# ---
#
# There  are  other  commands/functions  which  might  honor  the  option  (like
# `expand()` when  using a  backtick expression),  and which  might unexpectedly
# fail to give the right result when you include `*/.git/*`.
#
# ---
#
# Besides, justinmk and tpope explicitly recommend to *not* include `*/.git/*`:
# https://www.reddit.com/r/vim/comments/626no2/vim_without_nerd_tree_or_ctrlp/dfkbm97/
# https://github.com/tpope/vim-fugitive/issues/121#issuecomment-38720847
#}}}

# lock files (example: `~/.gksu.lock`)
set wildignore+=*.lock

# vim temporary files
set wildignore+=*.bak,*.sw[a-p],*~

# latex temporary files
set wildignore+=*.aux,*.fdb_latexmk,*.fls,*/auxiliary/*,*/build/*

# password databases
set wildignore+=*.kdb,*.kdbx

# media files (music, pictures, ...)
set wildignore+=*.gif,*.jpeg,*.jpg,*.mp3,*.mp4,*.png

# python objects/cache
set wildignore+=*.pyc,*/__pycache__/*

# undo files
#
#                                    ┌ `*` can match any string/path
#                                    │ (including as many `/` as you want, but not a dot)
#                                    │
&wildignore ..= ',' .. &undodir .. '/*'
&wildignore ..= ',' .. &undodir .. '/*.*'
&wildignore ..= ',' .. &undodir .. '/*.*.*,'
#                                    │
#                                    └ `*` can't match a dot, and the path of an
#                                      undofile often contains 1 or 2 dots

# Why don't you ignore archives?{{{
#
#     set wildignore+=*[^0-9].gz,*.rar,*.tar.*,*.zip
#                      ├────┘
#                      └ don't ignore man pages in `/usr/share/man/man1/`
#
# Some system files are stored in archives, logs for example.
# When we inspect  the contents of a  directory in dirvish, we want  to see them
# (whether we can open them or not).
# Besides, usually, they can be read in Vim.
# Example:
#
#     /usr/share/keymaps/i386/azerty/azerty.kmap.gz
#}}}

set wildignore+=tags

# Tab completion should be case-insensitive.
# If we type `:e bar Tab`, and a file `Bar` exists, we should get:
#
#     :e Bar
set wildignorecase

# wildmenu  wildchar(m) {{{2

# enable wildmenu
set wildmenu

# The value of 'wildmode' is a comma-separated list of (up to 4) parts.
# Each  part   defines  what   happens  when  we   press  Tab   (&wildchar)  the
# 1st/2nd/3rd/4th time.
set wildmode=full

# What's 'wildchar'?{{{
#
# The  key to  press for  Vim to  start a  wildcard expansion  (which opens  the
# wildmenu).
#}}}
#   'wildcharm'?{{{
#
# The key to press for Vim to start a wildcard expansion, from:
#
#    - the recording of a macro
#    - the rhs of a mapping
#}}}

# What does `set wildcharm=9` imply?{{{
#
# When you want  Vim to start a wildcard  expansion, in the rhs of  a mapping or
# while recording a macro, you must use Tab.
#}}}
# Which pitfall should I be aware of?{{{
#
# Suppose your recording contains Tab characters.
# While on the command-line, *any* one  of them will start a wildcard expansion.
# It may have unexpected results.
# For a real example, run:
#
#     :so $VIMRUNTIME/syntax/hitest.vim
#
# (Taken from `:h hitest.vim`)
# It will raise `E475`, and the dumped highlight groups won't be highlighted.
# This is because of these commands:
#
#     % yank a
#     @a
#
# They run the  contents of the buffer  as Ex commands, and  the latter contains
# Tab characters.
# Each Tab character makes Vim start a  wildcard expansion, but in the buffer it
# was just used to separate some texts.  It was not supposed to expand anything.
#}}}
#   What could I do to avoid it?{{{
#
#     set wildcharm=26
#}}}
#     Why don't you do it?{{{
#
# Having to remember to press `C-z` during a recording is cumbersome.
# You'll definitely forget about it,  then get unexpected results when replaying
# some macro.
#
# ---
#
# If you  change `'wcm'`, among other  things, in `vim-readline` you'll  need to
# replace this mapping:
#
#     cno <m-n> <down>
#
# With:
#
#     cno <m-n> <cmd>call feedkeys("\<lt>down>", 'in' .. (reg_recording()->empty() ? 't' : ''))<cr>
#}}}
set wildchar=9
set wildcharm=9

# winaltkeys {{{2

# Disable `alt + {char}` key bindings used in the GUI to access some menu entries.
# They could shadow some of our custom mappings using the meta modifier key.

set winaltkeys=no

# word / line wrapping {{{2

# don't wrap long lines by default
set nowrap

# a soft-wrapped line should be displayed with the same level of indentation as the first one
set breakindent
set breakindentopt=min:40,sbr
#                  │      │
#                  │      └ display the 'showbreak' character *before* the indentation
#                  │        this helps keeping all the start of lines aligned
#                  │
#                  └ make sure a soft-wrapped line contains at least 40 characters
#                    shift it to the right if necessary

# soft-wrap long lines at a character in 'breakat' (punctuation, math
# operators, tab, @) rather than at the last character that fits on the screen
set linebreak

# Problem: Moving vertically in a huge wrapped line (with `gj`, `gk`) makes Vim lag.
# Solution: Disable `'breakindent'` and `'linebreak'` when one of the first lines is too long.
augroup FastLongWrappedLines | au!
    # We need `WinEnter` because the contents of a file can change.{{{
    #
    # Ideally, we should listen to `TextChanged*`, but that looks too frequent.
    # `WinEnter` should be a good enough replacement.
    #}}}
    # We also need `BufWinEnter`, because `WinEnter` is fired too early the first time.{{{
    #
    # For example:
    #
    #     $ vim
    #     :e file_with_huge_wrapped_line
    #
    #     $ vim
    #     " run some code
    #     " press:  !d  (to dump debugging variables; one of them containing a huge list/dictionary)
    #}}}
    au WinEnter,BufWinEnter * FastLongWrappedLines()
    :def FastLongWrappedLines()
        # We only inspect the first 10  lines, otherwise the expression could be
        # too costly on a huge file.
        if getline(1, 10)
            ->mapnew((_, v: string): number => strchars(v, true))
            ->max() > 1000
            setl nobreakindent nolinebreak
        else
            setl breakindent linebreak
        endif
    enddef
augroup END

# allow to soft-wrap after ) ] }
set breakat+=)]}

# Alternatives:
#
#     &showbreak = '↳ '
#     &showbreak = '››› '
&showbreak = '↪ '

# allow `h` and `l` motion to move across lines
set whichwrap=h,l
# }}}1
# Mappings {{{1
# New {{{2

def RememberNewMappings(some_lhs: list<list<string>>)
    for lhs in some_lhs
        exe 'nno ' .. lhs[0] .. ' <cmd>call <sid>ReminderNewMapping(' .. string(lhs[1]) .. ')<cr>'
    endfor
enddef

def ReminderNewMapping(new_lhs: string)
    echohl WarningMsg
    echo 'Press ' .. new_lhs .. '    [3 times to make it stick faster]'
    echohl NONE
enddef

RememberNewMappings([
    ['-e', '!e'],
    ['zs', '!s'],
    ])

# Free {{{2

# A key can be used as a prefix iff one of these conditions is true:
#
#    - it's useless for you (ex: U)
#    - it's used as a prefix by default (ex: Z)
#
# This means that you can NOT use `!` as a good prefix.
# Not useless, and not a prefix by default, so it would lead to too many issues.
#
# Still, you may  occasionally use a key sequence `!{char}`.   But do NOT infer,
# that `!` can be  used as a prefix associated with a meaning,  to build a whole
# family of mappings.
# There would be times  when it wouldn't work, and then you  would have to build
# mappings which  do not follow  the same scheme (shell  command → !).  It would
# bring inconsistencies.


# When you find a new prefix, if it has a default meaning, disable it:
#
#     nno <pfx> <nop>
#
# Do *not* do it here from the vimrc.
# Do it from `~/.vim/after/plugin/nop.vim`: it's more reliable.
# See the first comment there for an explanation.


#    - C-q is not used in insert mode (except for exiting a completion menu)
#      we could supercharge  it to do something  else when we aren't  in a completion
#      menu
#
#    - C-z has been disabled in visual mode
#
#      in insert mode, we use it as an “easier-to-type“ C-x C-p
#
#    - gh, gH, g C-h, gl, v_C-g
#
#    - @# has been mapped to g8, so g8 is free
#
#    - gy, gz
#
#    - PageUp PageDown
#
#    - S-Tab (not Tab, because it would also affect C-i used for moving
#      inside the jumplist)
#
#    - C-_
#
#    - search for 'not used' in the window opened by `:viu`

# Leader {{{2

# If we install a  plugin which defines mappings using the  leader key, we don't
# want any clash with one of our existing mapping.  So, we assign to `mapleader`
# a garbage key.

# As an  example, this strategy is  useful to avoid the  `unicode.vim` plugin to
# introduce lag when  we hit `<space>u`.  Indeed this plugin  installs a mapping
# whose lhs is `<leader>un` (`:h <plug>(UnicodeSwapCompleteName)`).

# Other benefit:
#
#     :no <leader>
#     →
#     displays all mappings installed by third-party plugins
#     in normal / visual / operator-pending mode

# Warning: Do *not* use `\<s-f5>`.{{{
#
# It would cause a weird issue:
#
#     $ vim --clean --cmd 'let mapleader = "\<s-f5>"' ~/Vcs/gdb-9.2/gdb/testsuite/gdb.ada/bp_c_mixed_case/foo_h731_021.adb
#
# I think it comes from the fact that the internal by representation of `<s-f5>`
# ends with a newline or carriage return:
#
#     :echo "\<s-f5>"
#}}}
g:mapleader = "\<s-f10>"

# same thing for localleader
g:maplocalleader = "\<s-f11>"

# Command-Line {{{2
# C-r C-h       fuzzy search history {{{3

# Why not `C-r C-r`?{{{
#
# Already taken (`:h c^r^r`).
#}}}
# Why not C-r C-r C-r ?{{{
#
# Would cause a timeout when we press C-r C-r to insert a register literally.
#}}}
cno <c-r><c-h> <cmd>exe getcmdtype() =~ '[/?]' ? 'FzHistory/' : 'FzHistory:'<cr>

# C-r C-l       insert current line {{{3

cno <c-r><c-l> <c-r><c-r>=<sid>InsertCurrentLine()<cr>
def InsertCurrentLine(): string
    var cml: string
    if IsVim9()
        cml = '#'
    else
        cml = matchstr(&l:cms, '\S*\ze\s*%s')
    endif
    cml = '\%(\V' .. escape(cml, '\') .. '\m\)\='
    return getline('.')->substitute('^\s*' .. cml .. '\s*:\=', '', '')
enddef

# C-r `          insert codespan {{{3

cno <c-r>` <c-r><c-r>=<sid>InsertCodespan()<cr>
def InsertCodespan(): string
    var line: string = getline('.')
    var col: number = col('.')
    var pat: string = '.*`\zs.*\%' .. col .. 'c.\{-}\ze`\|\%' .. col .. 'c`\zs.\{-}\ze`'
    var codespan: string = matchstr(line, pat)
    return substitute(codespan, '^:', '', '')
enddef
# }}}2
# Insert {{{2

# Most of these mappings take care of not breaking the undo sequence (`:h i^gU`).
# It means we can repeat an edition with the dot command, even if we use them.
# If you add another mapping, try to not break the undo sequence.  Thanks.

# C-g             (prefix) {{{3
# C-h {{{4

# Sometimes, we want to do this:{{{
#
# ┌ exceeding amount of whitespace
# ├──────┐
#         some text
#     ↓
# some text
#│
#└ compacted whitespace
#}}}
# Also, sometimes we want to do this:{{{
#
# ┌ exceeding amount of whitespace
# ├─────┐
#        " some text
#     ↓
# " some text
# │
# └ compacted whitespace
#}}}

# This  mapping  tries  to  perform  both edits,  depending  on  the  amount  of
# whitespace between the comment leader and the rest of the text.
ino <c-g><c-h> <cmd>call <sid>CompactWhitespace()<cr>

def CompactWhitespace()
    if empty(&l:cms)
        return
    endif

    var cml: string
    if &ft == 'vim'
        cml = '["#]'
    else
        cml = '\V' .. matchstr(&l:cms, '\S*\ze\s*%s')->escape('\') .. '\m'
    endif

    var pat: string
    var rep: string
    if getline('.') =~ cml .. '\s\s' && &filetype != 'markdown'
        pat = '\s*' .. cml .. '\zs\s\+'
        rep = ' '
    else
        pat = '^\s*\ze\S'
        rep = ''
    endif

    getline('.')->substitute(pat, rep, '')->setline('.')
enddef
# }}}3
# C-m             more granular undo {{{3

# Make `C-m` break the undo sequence.{{{
#
# When  we write  a paragraph  then press  `u` to  undo, Vim  removes the  whole
# paragraph.  We  want it to  remove only the last  line.  Then the  one before,
# etc.
# To get a more granular undo, we need to press `c-g u` every time we press `C-m`.
# This will break the undo sequence into smaller undo sequences.
# Every time  we press `c-g  u`, the current state  of the buffer  is accessible
# with `u`/`c-r`.
#
# See: `:h i_ctrl-g_u`
#}}}

def CtrlM(): string
    if pumvisible()
        # If you change the code, make sure not to introduce a regression.{{{
        #
        # The code should be able to do this:
        #
        # Write `bug_` in a markdown buffer.
        # Press `Tab` to complete.
        # Select `bug_vim` in the pum.
        # Press `Enter`: the snippet should be expanded immediately.
        #
        # Expand the `vimrc` snippet.
        # Press `C-h` when you are at a tabstop containing a file path.
        # Insert a space.
        # Insert `/h`.
        # Press `C-g Tab` to complete the path.
        # Press `Enter`:  `/h` should be  completed with `/home`,  *and* another
        # completion should have been performed.
        #
        # In a file with only 2 lines "unexpected", and "une", pressing
        # `C-x C-n Enter` should complete "une" into "unexpected".
        #}}}
        var seq: string = "\<c-y>"
        var items: list<dict<string>> = complete_info(['items'])->get('items', [])

        # If the pum contains only 1 entry, and it's not selected, select it.{{{
        #
        # Otherwise,  the text  which was  inserted  in the  last completion  is
        # removed, which is very jarring.
        #}}}
        var nothing_selected: bool = complete_info(['selected'])->get('selected', -1) == -1
        if len(items) == 1 && nothing_selected
            seq = "\<c-n>" .. seq
        endif

        var menu: string = get(items, 0, {})->get('menu', '')
        # for a file path, re-trigger completion for a next possible path component
        if menu == '[f]'
            seq ..= "\<cmd>call completion#file#complete()\<cr>"
        # for an unexpanded snippet, trigger the expansion
        elseif menu[: 5] == '[snip]'
            seq ..= "\<cmd>call UltiSnips#ExpandSnippet()\<cr>"
        endif

        return seq
    endif

    # If we press Enter on a commented line with nothing in it, we want to delete everything.
    var cml: string = matchstr(&l:cms, '\S*\ze\s*%s')

    # make sure not to break possible text properties:
    # https://github.com/vim/vim/issues/7719
    var autoindent_is_on: bool = &l:ai
    var next_char: string = getline('.')->strpart(col('.') - 1)[1]
    if autoindent_is_on && next_char =~ '\s'
        setl noai
        au TextChangedI * ++once setl ai | FixIndent()
    endif

    if empty(cml)
        return "\<c-g>u\<cr>"
    endif

    if getline('.') =~ '^\s*\V' .. escape(cml, '\') .. '\m\s*$'
        # We can't invoke `setline()` immediately, because of `<expr>`.
        timer_start(0, () => setline('.', ''))
        # Why don't you simply press `BS`?{{{
        #
        #     return "0\<c-d>" .. repeat("\<BS>", strchars(cml) + 1)
        #
        # Not reliable, because sometimes BS deletes more than one char.
        # Happens after a sequence of whitespace.
        #}}}
        return ''
    endif

    return "\<c-g>u\<cr>"
enddef

# https://github.com/vim/vim/issues/7719
ino <expr> <c-m> <sid>CtrlM()

# C-r             ignore `'autoindent'` when inserting register {{{3

# Why handling a block specially?{{{
#
# The default `i^r` inserts a blockwise register as if it was linewise.
# We don't want an inconsistency; our custom `i^r` should behave the same.
#}}}
ino <expr> <c-r> getregtype(v:register) =~# '<c-v>' ? '<c-r>' : '<c-r><c-o>'
# The previous `<c-r>` mapping breaks the default `:h i^r^p`; allow us to still use it.{{{
#
# You may wonder how `:h i^r^p` gets broken.
# Suppose you  press `C-r`  in insert mode;  Vim sees that  you have  2 mappings
# starting with `C-r`:
#
#     i  <C-R>      * <C-R><C-O>
#     i  <C-R><C-F> * <C-\><C-O>:call plugin#fzf#registers('i')<CR>
#
# It must wait for  another key to know whether `C-r` needs  to be remapped, and
# if so with which mapping.
#
# Then, suppose you  press `C-p`; Vim now  knows that you don't want  to use the
# 2nd mapping, but the first mapping is  still ok, and so Vim expands `C-r` into
# `C-r C-o`.
#
# In the end, the typeahead buffer contains:
#
#     C-r C-o C-p
#
# `C-r  C-o` is  valid, but  there  is no  register  named `C-p`,  so the  whole
# sequence fails.  In  any case, that's not  what you wanted; you  wanted Vim to
# execute `C-r C-p`.
#}}}
ino <c-r><c-p> <c-r><c-p>
# the same issue could affect `:h i^r^o` if one day we use `<c-r><c-p>` in the `<c-r>` mapping
ino <c-r><c-o> <c-r><c-o>
# the same issue affects `:h i^r^r`
ino <c-r><c-r> <c-r><c-r>

# C-s             save {{{3

ino <c-s> <cmd>sil update<cr>

# M-a  M-e {{{3

sil! MapMeta('a', '<cmd>norm! (<cr>', 'i', '')
sil! MapMeta('e', '<cmd>norm! )<cr>', 'i', '')

# \ {{{3

ino <silent> <bslash> <c-r>=<sid>IndentBeforeBackslash()<cr>

def IndentBeforeBackslash(): string
    if &filetype != 'vim'
        return '\'
    endif

    var has_text_before_cursor: bool = getline('.')
        ->matchstr('.*\%' .. col('.') .. 'c')
        =~ '\S'
    var prev_indent: string = (line('.') - 1)->getline()->matchstr('^\s*\\')
    var next_indent: string = (line('.') + 1)->getline()->matchstr('^\s*\\')

    if has_text_before_cursor
    || empty(prev_indent) && empty(next_indent)
        return '\'
    endif

    var current_indent: string = empty(next_indent)
        ?     prev_indent
        :     next_indent

    #       ┌ if the cursor is in the middle of the indentation,
    #       │ `0 C-d` removes all whitespace before the cursor AND after
    #       ├─────┐
    return "0\<c-d>" .. current_indent .. ' '
    #                   │                  │
    #                   │                  └ to avoid that `\?` or `\:`
    #                   │                    which can cause a bug when Vim parses
    #                   │                    the ternary operator `?:` in a lambda
    #                   │
    #                   └ includes a backslash at the end
enddef

# }}}2
# Normal {{{2
# SPC {{{3
# . {{{4

# Problem:{{{
#
# Suppose you've just changed the word `foo` into `bar`.
# There's no easy way to repeat this change on all subsequent `foo`s.
# You need to first look for `foo`: `/foo CR`.
# Then, you need to:
#
#    - move to each `foo` by pressing `n`
#    - press `.` to repeat the change
#
# If you have `n` words to change, that's `4  + 2 * n` keypresses (4 to look for
# `foo`, then 2 more for each change).
#}}}
# Solution:{{{
#
# Include the `n` motion inside the change (somewhat similar to `^ifoo` vs `Ifoo`).
# You can  do so by  installing a mapping  leveraging the `gn`  text-object; the
# mapping should:
#
#    1. put the last changed text in the search register (`@"` → `@/`)
#    2. cut the next occurrence of the latter
#    3. insert the previously inserted text and stop insert (`C-@`)
#
# After `SPC .` has been pressed, you can repeat a change with `.`.
# `SPC` is not needed anymore.
#
# IOW, after you've  changed the first `foo`,  you can change the  next `n` ones
# with `2 + (n - 1)` keypresses.
#
# This is much more efficient:
#
#     2 + n - 1  <  4 + 2 * n
#}}}
nno <expr> <space>. <sid>RepeatLastEditOnLastChangedText()

def RepeatLastEditOnLastChangedText(): string
    # put the last changed text inside the search register, so that we can refer
    # to it with the text-object `gn`
    var changed: list<string> = getreg('"', true, true)
    if changed == []
        return ''
    endif

    map(changed, (_, v: string): string => escape(v, '\'))
    var pat: string
    if len(changed) == 1
        pat = changed[0]
    else
        # can't join with real newlines: they would be translated as NULs in the search register
        # we need to join with the *atom* `\n`
        pat = join(changed, '\n')
    endif
    setreg('/', '\V' .. pat, 'c')
    set hls
    return "cgn\<c-@>"
    #          ├────┘
    #          └ insert the previously inserted text and stop insert
enddef

# aa    ac    ad    al    an    arglist {{{4

nno <space>aa <cmd>argedit %<cr>

# load Current argument
nno <space>ac <cmd>argument<cr>

# Delete current argument
nno <space>ad <cmd>.argdelete<cr>

# create Local arglist (by copying the global one)
nno <space>al <cmd>arglocal<cr>

# start New arglist
#
# Define a new argument list, which is local to the
# current window, and containing only the current buffer.
# This causes the buffer to be reloaded.
# Add a bang to `:arglocal` to discard unsaved changes in the current buffer.
nno <space>an <cmd>arglocal %<cr>

# i x                           ixquick, tmux prompt {{{4

# Why don't you use your shell script anymore?{{{
#
# It depends on tmux.
# It opens a whole new window which is distracting.
# It consumes a precious tmux key binding (easy-to-type tmux key bindings are not that numerous).
# It's brittle; it needs to properly set `LC_ALL`, some weird redirections, and a sleep...
# It can't escape special shell characters such as `*`, so sometimes a search may fail.
# ...
#
# If you need to read it, it's there: `~/bin/bash/search-engine`.
#}}}
nno <space>i <cmd>call <sid>RunCurrentLine('websearch')<cr>

# tmux command-prompt has too limited editing capabilities.
# Let's use a Vim buffer to leverage Vim's editing capabilities.
nno <space>x <cmd>call <sid>RunCurrentLine('tmuxprompt')<cr>

def RunCurrentLine(type: string)
    if &ft == type
        return
    endif
    var dir: string = $HOME .. '/.vim/tmp'
    var file: string = dir .. '/' .. type
    var max_history: number = 100
    if !isdirectory(dir)
        mkdir(dir, 'p', 0o700)
    endif
    # make sure the history doesn't exceed `max_history` entries
    if filereadable(file)
        var lines: list<string> = readfile(file)
        if len(lines) > max_history
            writefile(lines[: max_history - 1], file)
        endif
    endif
    exe 'bo sp ' .. file
enddef

# s S                           saiw  saiW{{{4

nmap <space>s saiw
nmap <space>S saiW

# t                             new tab page {{{4

nno <space>t <cmd>exe (v:count ? v:count .. 'tabnew' : 'tabnew')<cr>
#}}}3
# U {{{3
# Uc                clear undo history {{{4

nno Uc <cmd>call <sid>ClearUndoHistory()<cr>

def ClearUndoHistory()
    # `:h clear-undo`
    var ul_save: number = &l:ul
    setl ul=-1
    getline('.')->setline('.')
    &ul = ul_save
    exe 'wundo ' .. expand('%:p')->undofile()->fnameescape()
    sil update
    echom 'cleared undo history'
enddef

# UM                undo changes during current session {{{4

augroup ChangenrSave | au!
    au BufReadPost * ChangenrSave()
augroup END

def ChangenrSave()
    var bufnr: number = bufnr('%')
    if has_key(changenr_save, bufnr)
        return
    endif
    # Is `changenr()` reliable?{{{
    #
    # It was not in the past:
    # https://www.reddit.com/r/vim/comments/dszuz/gundo_my_little_undo_tree_visualization_plugin/c12ril4/
    #
    # `undotree().seq_cur` was not either.
    # But that has changed since 8.0.1290; now, they should both be reliable.
    #}}}
    changenr_save[bufnr] = changenr()
enddef
var changenr_save: dict<number>

# Ideas for other mappings navigating in the undo tree:{{{
#
#     " go to previous save
#     nno UH <cmd>ea 1f <bar> call save#toggleAuto()<cr>
#     " go to next save
#     nno UL <cmd>later 1f <bar> call save#toggleAuto()<cr>
#     nno UM <cmd>exe 'undo ' .. undotree().seq_last <bar> call save#toggleAuto()<cr>
#}}}

# Don't use `UU`; I think we used it in the past, but pressed it by accident too often.
nno UM <cmd>call <sid>UndoChangesDuringCurrentSession()<cr>
def UndoChangesDuringCurrentSession()
    var bufnr: number = bufnr('%')
    if !has_key(changenr_save, bufnr) || changenr_save[bufnr] == changenr()
        return
    endif
    try
        exe 'undo ' .. changenr_save[bufnr]
    # E830: Undo number 1234 not found
    catch /^Vim\%((\a\+)\)\=:E830:/
        var msg: list<string> =<< trim END
            Cannot access original state of the file
            you probably performed too many changes during the same session
            if this is an issue, try to increase 'undolevels'
        END
        echohl ErrorMsg
        mapnew(msg, (_, v: string) => execute('echom ' .. string(v), ''))
        redraw
        echo msg[0]
        echohl NONE
    endtry
enddef

# Ud  Up  Us       (fugitive) {{{4

# We need to unmap `U` in a fugitive buffer because it's used by fugitive
# (`:h fugitive_U`) to unstage everything; this prevents us from using `U`
# as a prefix key in the next mappings.
# TODO: Maybe we should remove this autocmd and map all our prefix keys to
# `<nop>` in *buffer-local* mappings.{{{
#
# This would be a more general solution to this particular problem.
# To implement this idea, you need to write this autocmd:
#
#     augroup CancelPrefix
#         exe 'au FileType * nno <buffer> ' .. pfx .. ' <nop>'
#         exe 'au FileType * xno <buffer> ' .. pfx .. ' <nop>'
#     augroup END
#
# inside the function `CancelPrefix()` from the file:
#
#     ~/.vim/after/plugin/nop.vim
#
# Problem: It would break the `-` fugitive mapping (`:h fugitive_-`) which we use.
# We would need to  re-install this mapping but I don't know how  to get the rhs
# programmatically; the latter contains sth like `<snr>123_`.
# I seem to remember  trying to use the rhs of a fugitive  mapping in one of our
# own mapping, and it didn't work well; it's much trickier than what it seems.
#
# Anyway, this issue  highlights the importance of getting  `<plug>` mappings to
# override all of fugitive mappings.
#}}}
augroup UnmapFugitive | au!
    au FileType fugitive sil! nunmap <buffer> U
augroup END

nno Ud <cmd>Gdiff<cr>
nno Up <cmd>call <sid>TryFugitiveCmd('Git push')<cr>
nno Us <cmd>call <sid>TryFugitiveCmd('Gstatus')<cr>

def TryFugitiveCmd(cmd: string)
    try
        exe cmd
    catch
        # Vim(echoerr):fugitive: file does not belong to a Git repository
        echohl ErrorMsg | echom v:exception | echohl NONE
        return
    endtry
    if cmd == 'Gstatus'
        # Rationale:{{{
        #
        # When we press `q` in the window opened by `:Gstatus`, fugitive gives this warning message:
        #
        #     :Gstatus q is deprecated in favor of gq or the built-in <C-W>q
        #
        # It's annoying and distracting.
        #
        # ---
        #
        # Besides, by default, we end up in  the bottom window, which may not be
        # the one we were focusing before executing `:Gstatus`; IOW, we may lose
        # our focused window.
        #}}}
        nno <buffer><nowait> q <cmd>call <sid>CloseFugitiveWindow()<cr>
        cursor(1, 1)
        search('^# \%(Changes\|Untracked files\)', 'W')
    endif
enddef

def CloseFugitiveWindow()
    # Do *not* try to be smart and focus the previous window immediately, then close the fugitive window.{{{
    #
    #     wincmd p
    #     exe winnr('#') .. 'close'
    #
    # The height of the remaining windows would be wrong.
    # When you close  a non-focused window with `:123close`, no  event is fired,
    # so `vim-window` does not reset the height of the remaining windows:
    #
    #     $ vim +'sp|sp'
    #     :1close
    #
    # You would need additional statements:
    #
    #     if &ft == 'qf'
    #         wincmd _
    #     endif
    #     do <nomodeline> WinEnter
    #
    # The reason  why `wincmd _` is  necessary is because the  original previous
    # window may be a qf window; in that case you're now in a qf window, and
    # `do WinEnter` will make `vim-window` set  the height of *only* the latter;
    # it won't squash the other regular windows.
    #
    #     $ vim +'sp|sp|helpg foobar' +'copen'
    #     :1close
    #     :do WinEnter
    #
    # You could also replace `wincmd _ | do  WinEnter` with `wincmd p | wincmd p`,
    # but  it  would  fire  many  events  (`BufLeave`,  `WinLeave`,  `WinEnter`,
    # `BufEnter`,  `BufLeave`); the  fewer events,  the less  chance you  get an
    # unexpected result.
    #
    # As you can see, there are a few pitfalls; so don't try to be smart, be simple.
    #}}}
    var winid: number = Win_getid('#')
    close
    win_gotoid(winid)
enddef
#}}}3
# g {{{3
# g^ g$       first/last tabpage {{{4

nno g^ <cmd>1tabnext<cr>
nno g$ <cmd>$tabnext<cr>

# gV  g C-v   select last changed text {{{4

nno g<c-v> `[v`]
nno gV     '[V']

# g SPC       break line {{{4

nno <expr> g<space> <sid>BreakLine()

def BreakLine(type = ''): string
    if type == ''
        &opfunc = expand('<stack>')->matchstr('.*\zs<SNR>\w*')
        return 'g@l'
    endif

    # We sometimes press `g SPC` by accident after getting back to the beginning
    # of a markdown file.  It creates a superfluous empty line.
    if col('.') == 1
        return ''
    endif

    var sol_save: bool = &sol
    try
        # https://github.com/andymass/vim-matchup/issues/132
        set sol
        # break the line
        exe "norm! i\r"

        # trim ending whitespace on both lines
        keepj keepp :.-,.s/\s\+$//e
    catch
        return Catch()
    finally
        &sol = sol_save
    endtry
    return ''
enddef

# ga          easy align {{{4

# Start interactive EasyAlign in visual mode (e.g. `vipga`)
xmap ga <plug>(EasyAlign)

# Start interactive EasyAlign for a motion/text object (e.g. `gaip`)
nmap ga <plug>(EasyAlign)

# gf          & friends, in vimrc {{{4

# Purpose:
# When we're on a line enabling a plugin, it's convenient to be able to edit its
# configuration files by pressing `ZF`.
# So, we try to make `gf` & friends smarter.

augroup VimrcMappings | au!
    au BufReadPost $MYVIMRC InstallVimrcMappings()
augroup END

def InstallVimrcMappings()
    nno <buffer><nowait> gf <cmd>call <sid>TryToEditPluginConfig('gf')<cr>
    nno <buffer><nowait> gF <cmd>call <sid>TryToEditPluginConfig('gF')<cr>
    nno <buffer><nowait> <c-w>f <cmd>call <sid>TryToEditPluginConfig('<c-w>f')<cr>
    nno <buffer><nowait> <c-w>F <cmd>call <sid>TryToEditPluginConfig('<c-w>F')<cr>
    nno <buffer><nowait> <c-w>gf <cmd>call <sid>TryToEditPluginConfig('<c-w>gf')<cr>
    nno <buffer><nowait> <c-w>gF <cmd>call <sid>TryToEditPluginConfig('<c-w>gF')<cr>

    nmap <buffer><nowait> Z <c-w>
    # easier to press `ZGF` than `ZgF`
    nmap <buffer><nowait> <c-w>GF <c-w>gF
enddef

def TryToEditPluginConfig(cmd: string)
    var pat: string = '\C^\s*\<Plug\s\+''.\{-}/\%(vim-\)\=\zs.\{-}\ze\%([.-]vim\)\=/\='''
    var plugin: string = getline('.')->matchstr(pat)

    if plugin == ''
        try
            exe 'norm! ' .. cmd .. 'zv'
        catch
            Catch()
            return
        endtry
    else
        var split: string = cmd[0] == 'g' ? 'edit' : cmd[1] == 'g' ? 'tabedit' : 'split'
        var files: list<string> = [$HOME .. '/.vim/plugin/' .. plugin .. '.vim']
        files += [$HOME .. '/.vim/after/plugin/' .. plugin .. '.vim']
        files += [$HOME .. '/.vim/autoload/slow_call/' .. plugin .. '.vim']
        filter(files, (_, v: string): bool => filereadable(v))
        if empty(files)
            echo 'There''s no config file for ' .. string(plugin)
            return
        endif

        var a_file_is_opened: bool = false
        for f in files
            exe (a_file_is_opened ? 'sp' : split) .. ' ' .. f
            norm! zv
            a_file_is_opened = true
        endfor
    endif
enddef

# go {{{4

nno gof <cmd>eval expand('%:p:h', v:true)->myfuncs#gtfoOpenGui()<cr>
nno goF <cmd>eval getcwd()->myfuncs#gtfoOpenGui()<cr>

nno got <cmd>eval expand('%:p:h', v:true)->myfuncs#gtfoOpenTerm()<cr>
nno goT <cmd>eval getcwd()->myfuncs#gtfoOpenTerm()<cr>
#}}}3
# m {{{3
# m;             mark current location {{{4

# These mappings can be used to traverse an arbitrary set of locations in the current buffer, using:{{{
#
#    - `m;` to save the current position into a list
#    - `m,` to empty the latter
#    - `[;` and `];` to jump from one location to the other
#}}}
# Why using text properties?  Why not a loclist?{{{
#
# A loclist would only save positions,  which could become invalid when the text
# changes (e.g. a line before has been removed).
# Text properties "follow" the text to which they're tied.
#
# ---
#
# Also, our breakdown plugin can frequently add a new loclist on the stack; when
# that happens we would need to run `:lolder` or `:[count]lhi`.
#}}}

# set mark on current position
nno m; <cmd>call <sid>MyLocations('save')<cr>
# clear locations
nno m, <cmd>call <sid>MyLocations('clear')<cr>

nno ]; <cmd>call <sid>JumpMyLocations('f')<cr>
nno [; <cmd>call <sid>JumpMyLocations('b')<cr>

def MyLocations(action: string)
    var buf: number = bufnr('%')
    if action == 'save'
        if prop_type_list({bufnr: buf})->index('MyLocations') == -1
            prop_type_add('MyLocations', {
                bufnr: buf,
                highlight: 'WildMenu',
                combine: false
                })
        endif
        prop_add(line('.'), col('.'), {
            bufnr: buf,
            type: 'MyLocations',
            combine: false,
            })
    else
        if prop_type_list({bufnr: buf})->index('MyLocations') >= 0
            prop_type_delete('MyLocations', {bufnr: buf})
            redraw!
        endif
        prop_type_add('MyLocations', {
            bufnr: buf,
            highlight: 'WildMenu',
            combine: false
            })
    endif
enddef

def JumpMyLocations(direction: string)
    var prop: dict<any> = prop_find({
        type: 'MyLocations',
        skipstart: true
        }, direction)
    if prop == {}
        return
    endif
    cursor(prop.lnum, prop.col)
enddef

# m/             matchadd / matchdelete search pattern {{{4

def WhereAreMyMatches()
    if exists('w:my_matches')
        sil! matchdelete(w:my_matches)
        unlet! w:my_matches
    else
        w:my_matches = matchadd('WildMenu', '\c' .. @/, 0)
    endif
enddef

nno m/ <cmd>noh <bar> call <sid>WhereAreMyMatches()<cr>
#}}}3
# y {{{3
# Y y$ {{{4

nno Y y$<cmd>call repeat#invalidate()<cr>

# In visual mode, make `Y` yank until the end of the line, just like it does in normal mode.{{{
#
# We can't separate a  register name from the `y` command,  with a motion.  They
# must  be consecutive.   Otherwise  the  yanking fails  to  target the  desired
# register.  MWE:
#
#     C-v 3j "+ $ y    ✘
#     C-v 3j $ "+ y    ✔
#
# As  soon as  we type  the `$`  motion, the  register name  is lost  (watch the
# command-line).   So,  we  use  an  expression, to  make  sure  that  they  are
# consecutive.
#
# There is  no need to prefix  the keys with  `Escape` when a register  has been
# specified, and you need to reposition it in the command.
# As  soon  as   `$`  is  pressed,  the  old  register   is  cancelled  (because
# `"{register}$` is not a valid command).
#}}}
xno <expr> Y '$"' .. v:register .. 'y' .. repeat#invalidate()

# y[cC]  y[mM]        yank code / Comments  matching / non-matching lines {{{4

nno <expr>  yc myfuncs#opYankSetup('code')
xno <expr> myc myfuncs#opYankSetup('code')

nno <expr>  yC myfuncs#opYankSetup('comments')
xno <expr> myC myfuncs#opYankSetup('comments')

# lines matching last search
nno <expr>  ym myfuncs#opYankSetup('g//')
xno <expr> mym myfuncs#opYankSetup('g//')

# lines which do *not* match last search
nno <expr>  yM myfuncs#opYankSetup('v//')
xno <expr> myM myfuncs#opYankSetup('v//')
#}}}3
# z {{{3
# z. {{{4

# Scroll the screen so that cursor is at the center of a long non-wrapped line.
# https://unix.stackexchange.com/a/585098/289772
nno z. zszH
#      ├┘├┘
#      │ └ scroll half-a-screen to the left
#      └ scroll the screen so that the cursor is at the start

# z= {{{4

# Will a repetition of this command open a new menu?{{{
#
# No, it will simply repeat the previous edit.
# Consider this text:
#
#     Hellzo peozple.
#
# Move your cursor on `Hellzo`, and press `z=` to fix it.
# Move your cursor on `peozple`, and press `.` to repeat.
# Vim will simply replace the word with `Hello`, it won't try to fix `peozple`.
#
# This is normal, do *not* try to change the code so that it opens a new menu.
# From `:h z=`:
#
#    > When a word was replaced the redo command "." will
#    > repeat the word replacement.  This works like "ciw",
#    > the good word and <Esc>.
#}}}
nno <expr> z= <sid>ZEqual()

def ZEqual(type = ''): string
    if type == ''
        &opfunc = expand('<stack>')->matchstr('.*\zs<SNR>\w*')
        return 'g@l'
    endif
    try
        # Why not `norm! z=`?{{{
        #
        # We would not be  able to select an entry in  the menu, because `:norm`
        # would press `Escape`.
        # Indeed, it  considers `z=`  as in INcomplete  command, since  we don't
        # give it the number of the entry we want to select in advance.
        # From `:h norm`:
        #
        #    > {commands} should be a complete command.  If
        #    > {commands} does not finish a command, the last one
        #    > will be aborted as if <Esc> or <C-C> was typed.
        #}}}
        feedkeys((v:count ? v:count : '') .. 'z=', 'in')
        return ''
    catch
        return Catch()
    endtry
    return ''
enddef

# zd  zD  zE {{{4

# make `zd` repeatable; also, make it handle Vim9's comment leader (`#`) correctly
nno <expr> zd <sid>ZdSetup('zd')
nno <expr> zD <sid>ZdSetup('zD')
nno <expr> zE <sid>ZdSetup('zE')

def ZdSetup(cmd: string): string
    zd_cmd = cmd
    &opfunc = expand('<SID>') .. 'Zd'
    return 'g@l'
enddef
var zd_cmd: string

def Zd(_: string)
    var cms_save: string = &l:cms
    try
        if IsVim9()
            setl cms=#%s
        endif
        exe 'norm! ' .. zd_cmd
    # `zd` only works when 'foldmethod' is "manual" or "marker"
    catch /^Vim\%((\a\+)\)\=:\%(E351\|E490\):/
        Catch()
        return
    finally
        &l:cms = cms_save
    endtry
enddef

# zg (&friends) {{{4

# The default commands to add good / bad words in:
#
#    - a temporary list  use an uppercase character
#    - a persistent list use only lowercase characters
#
#    ┌────────────┬──────────────┬──────────────┐
#    │            │ mark         │ undo         │
#    ├────────────┼──────┬───────┼──────┬───────┤
#    │            │ good │ wrong │ good │ wrong │
#    ├────────────┼──────┼───────┼──────┼───────┤
#    │ persistent │ zg   │ zw    │ zug  │ zuw   │
#    ├────────────┼──────┼───────┼──────┼───────┤
#    │ temporary  │ zG   │ zW    │ zuG  │ zuW   │
#    └────────────┴──────┴───────┴──────┴───────┘
#
# For the moment, we prefer to always add  good / bad words to a temporary list,
# so that my choices don't persist  across sessions.  Therefore, we swap all the
# commands (easier to type lowercase characters).

# mark word under cursor as good
nno <expr> zg <sid>SpellCommandSetup('zG')
nno <expr> zG <sid>SpellCommandSetup('zg')

# mark word under cursor as wrong
nno <expr> zw <sid>SpellCommandSetup('zW')
nno <expr> zW <sid>SpellCommandSetup('zw')

# undo the marking of word under cursor as good
nno <expr> zug <sid>SpellCommandSetup('zuG')
nno <expr> zuG <sid>SpellCommandSetup('zug')

# undo the marking of word under cursor as wrong
nno <expr> zuw <sid>SpellCommandSetup('zuW')
nno <expr> zuW <sid>SpellCommandSetup('zuw')

def SpellCommandSetup(cmd: string): string
    spell_command = cmd
    &opfunc = expand('<SID>') .. 'SpellCommand'
    return 'g@l'
enddef
var spell_command: string

def SpellCommand(_: string)
    try
        exe 'norm! ' .. spell_command
    catch /^Vim\%((\a\+)\)\=:E349:/
        echohl ErrorMsg
        echom v:exception
        echohl NONE
    endtry
enddef
# }}}3
# | {{{3
# |c         execute the Compiler {{{4

# Why `:silent`?{{{
#
# To avoid a hit-enter prompt.
#}}}
# Why `:redraw!`?{{{
#
# To erase artifacts which appears because of `:silent`.
#}}}
# Why `:lmake` instead of `:make`?{{{
#
# Most of the time, we compile a single file, not a whole project.
# It makes more sense to use a location list, and not pollute the qf stack.
#}}}
# Why no `:lw` at the end?{{{
#
# There's no need to.
# `vim-qf` installs an autocmd which takes care of that.
#}}}
# Do *not* install a `<bar>c` mapping in a filetype plugin to set the compiler and then compile.{{{
#
# Unless you have to, because it requires some special handling.
#
# Instead, simply set the compiler in the filetype plugin with `:compiler foo`.
# This global `<bar>c` mapping will then use the right compiler.
#}}}
nno <bar>c <cmd>call <sid>RunCompiler()<cr>

def RunCompiler()
    if &l:mp =~ '^\m\Cdesktop-file-validate\>'
        sil update
        sil var out: string = system('desktop-file-validate ' .. expand('%:p')->shellescape())
        if out == ''
            echo '[desktop-file-validate] OK'
        else
            echo out
        endif
        return
    endif

    var is_shellcheck: bool = &l:mp =~ '\m\C^shellcheck\>'
    update
    # TODO: This causes the shell command output  to be printed in the terminal,
    # which we  can see once  we quit  Vim.  Try to  run `'mp'` via  `:cexpr system()`
    # or `getqflist()`, to get fewer side-effects.
    sil lmake!
    redraw!

    if &ft == 'qf' && is_shellcheck
        # install  `gx` mapping, to  let us open the  wiki page where  the error
        # under the cursor is documented
        nno <buffer><nowait> gx <cmd>call <sid>GxShellcheck()<cr>
    endif
enddef

def GxShellcheck()
    var error_number: string = getline('.')->matchstr('.\{-}|.\{-}\zs\d\+\ze\s*|')
    # `:ShellCheckWiki` is defined only in a shell buffer (i.e. in the previous window).
    wincmd p
    exe 'ShellCheckWiki ' .. error_number
    wincmd p
enddef

# |g         grep word under cursor / visual selection {{{4

# grep the word under the cursor, recursively in all the files of cwd
nno <expr> <bar>g myfuncs#opGrep()

# same thing for visual selection
# Do not use `!g` for the `{lhs}`.{{{
#
# It  would introduce  some "lag"  whenever  we hit  `!` to  filter some  visual
# selection.  We would need to wait, or  hit the second character of our command
# to see the bang on the command-line.
#}}}
xno <expr> <bar>g myfuncs#opGrep()

# |t         translate {{{4

nno <bar>t <cmd>call myfuncs#trans()<cr>
nno <bar>T <cmd>call myfuncs#transStop()<cr>
xno <bar>t <cmd>call myfuncs#trans()<cr>
#     └ do *not* use `!t`{{{
#
# It would prevent us from writing a visual selection on the standard input of a
# shell command whose name begins with a `t`.
#
# Do *not* use `!<c-t>`, it would introduce lag when we press `!` in visual mode.
#
# Do *not* use `<c-t>!`, it would be inconsistent with other similar mappings.
#}}}

# cycle through several types of translations
nno coT <cmd>call myfuncs#transCycle()<cr>
# }}}3
# = {{{3
# = C-p               fix indentation of pasted text {{{4

# Why not `=p`?{{{
#
# Already used in `vim-brackets` to paste and fix right afterward.
# Same for `=P`.
#}}}
nno =<c-p> m''[=']``

# =d                  fix display {{{4

# In normal mode, we remapped `C-l` to give the focus to the right window.
# But by default, `C-l` redraws the screen by executing `:redraw!`.
#
# So, we need to bind `:redraw!` to another key, `=d` could be a good
# candidate.

nno =d <cmd>call <sid>FixDisplay()<cr>

def FixDisplay()
    var view: dict<number> = winsaveview()
    redraw! | redraws! | redrawt

    if &l:diff
        # update differences between windows in diff mode
        diffupdate!
        #         │
        #         └ check if the file was changed externally and needs to be reloaded
        winrestview(view)
        return
    endif

    # reload filetype plugins (to reapply window-local options)
    # Why don't you run `do filetypeplugin filetype`?{{{
    #
    # It would only reload the default filetype plugins.
    #
    # It would not run our custom autocmds listening to `FileType`.
    # In particular, it would not run the autocmd in the `StyledComments` augroup.
    # For that, you would need to run:
    #
    #     do StyledComments filetype
    #
    # Nor would it run the autocmd in `MyDefaultLocalFormatoptions`.
    # For that, you would need to run:
    #
    #     do MyDefaultLocalFormatoptions filetype
    #
    # IOW, you would need to run an extra `:do` command for every custom augroup
    # you have installed; that's not manageable.
    #}}}
    exe 'do filetype ' .. &ft

    # recompute folds
    foldlevel(1)
    # and their titles
    do <nomodeline> BufWinEnter

    # Re-install HGs which may have been cleared after changing the color scheme.{{{
    #
    # Remember that to change the brightness  of `seoul-256`, in effect, we *do*
    # change the color scheme.
    # Also, note  that `do Syntax` will  only re-install a HG  if its attributes
    # are defined in a syntax plugin which is sourced for the current buffer.
    #}}}
    # We already run `:do Syntax` from an autocmd listening to `ColorScheme`.  Is it really useful here?{{{
    #
    # Yes.
    #
    # For  performance  reason,  the  autocmd only  iterates  over  the  buffers
    # *displayed* in a window.
    #
    # MWE:
    #
    #     $ cat <<'EOF' >>~/.vim/after/syntax/conf.vim
    #     syn match confError /some error/
    #     hi confError ctermbg=red
    #     EOF
    #
    #     $ cat <<'EOF' >>/tmp/conf.conf
    #     # some comment
    #     some error
    #     EOF
    #
    #     $ vim ~/.bashrc /tmp/conf.conf
    #     :bn|bp " to source conf syntax plugin
    #     ]ol
    #     [ol
    #     :bn
    #
    # `some error` should be highlighted in red; it's not.
    # The `confError` HG has been cleared when we pressed `]ol` and `[ol`.
    # It has not been re-installed by  our autocmd, because there was no `.conf`
    # file displayed anywhere.
    #}}}
    do Syntax

    # Purpose:{{{
    #
    # Reset the min/max number of lines above the viewport from which Vim begins
    # parsing the buffer to apply syntax highlighting.
    #
    # Sometimes syntax highlighting is wrong, these commands should fix that.
    #
    # We could also be more radical, and execute:
    #
    #     :syn sync fromstart
    #
    # But after we execute it in our  vimrc, every time we source the latter, we
    # experience lag.
    #}}}
    syn sync minlines=200
    syn sync maxlines=400

    sil! window#popup#closeAll()
    winrestview(view)
enddef

# =m                  fix macro {{{4

# Usage:
#     =ma  →  edit recording a
nno =m <cmd>call <sid>FixMacro()<cr>

var fix_macro_c: string
def FixMacro()
    # don't open several windows if we press `=m` several times consecutively
    if !empty(fix_macro_c)
        return
    endif
    var c: any = getchar()
    if typename(c) != 'number'
        return
    endif
    var char: string = nr2char(c)
    if char !~ '[[:lower:]]'
        return
    endif
    # Why don't you use the command-line window?{{{
    #
    # When the  register contains some  special characters (like `C-u`),  and we
    # press  Enter  to  leave  the  command-line window,  the  register  is  not
    # populated with what we expect.
    #}}}
    :40vnew
    setl bh=wipe bt=nofile nobl nomod noswf wfw wrap
    augroup FixMacro
        au! * <buffer>
        fix_macro_c = char
        au QuitPre <buffer> setreg(fix_macro_c, [getline(1)], 'c') | fix_macro_c = ''
    augroup END
    if !has('gui_running')
        # When running the macro, we don't want an escape to be wrongly translated as part of a terminal sequence.{{{
        #
        # E.g. `Esc f` → `M-f`.
        #
        # If we insert an escape character, it's probably just to get back to normal mode.
        #}}}
        # What if I really want to insert an escape?{{{
        #
        #     i C-r = " \ e " CR
        #}}}
        ino <buffer> <c-v><esc> <c-v><c-\><c-v><c-n>
    endif
    nno <buffer><expr><nowait> q reg_recording() != '' ? 'q' : '<cmd>q<cr>'
    nmap <buffer><nowait> <cr> q
    nmap <buffer><nowait> ZZ q
    getreg(char, 1, 1)->setline(1)
    norm! 1|0f'
enddef
#}}}3
# hyphen {{{3
# -a  -8           ascii / bytes info {{{4

# We remap `-a`  to a function of  the `unicode.vim` plugin which  gives us more
# info about the character under the cursor.
# In   particular,   its  unicode   name,   html   entity  (`&entity_name;`   OR
# `&#entity_number;`), and digraph inside parentheses (if there's one defined).
#
# We also capture the  output of the command in the `o` register,  to be able to
# dump it in a buffer.
nno -a <cmd>call <sid>UnicodeGa()<cr>
def UnicodeGa()
    var out: string = execute('UnicodeName', 'silent!')->substitute('\s*$', '', '')
    setreg('o', [out], 'c')
    UnicodeName
enddef

# We remap `-8` to `g8` for consistency.
nno -8 <cmd>call <sid>GetCharbyte()<cr>
def GetCharbyte()
    var out: string = execute('norm! g8', 'silent!')[1 :]->substitute('\s*$', '', '')
    setreg('o', [out], 'c')
    echo @o
enddef

# -f               show filetype {{{4

nno -f <cmd>call <sid>PrintFiletype()<cr>
def PrintFiletype()
    setreg('o', [!empty(&ft) ? &ft : '∅'], 'c')
    echohl Title
    echo '[filetype] ' .. @o
    echohl NONE <cr>
enddef

# full path current file
#
# C-g does sth similar (:h ^g), but its output is:
#
#    - noisy
#    - not colored
#    - unable to expand `~`
#    - relative to the working directory

# -P  -p           show filePath / :pwd {{{4

nno -P <cmd>call <sid>PrintCwd()<cr>
nno -p <cmd>call <sid>PrintFullPath()<cr>

def PrintCwd()
    var fmt: list<string> =<< trim END
        window:  %s
        tabpage: %s
        global:  %s
    END
    map(fmt, (i: number, v: string): string => [
            getcwd(), getcwd(-1, 0), getcwd(-1)
        ][i]
        ->printf(v)
        )
        # 'c' instead of 'l' to prevent the insertion of a trailing newline
        ->setreg('o', 'c')
    echo @o
enddef

def PrintFullPath()
    if &bt == 'quickfix'
        var out: string = get(w:, 'quickfix_title', 'no title')
        setreg('o', [out], 'c')
        echo @o
        return
    endif

    var fname: string = expand('%:p')
    # later, we'll compare `fname` with its resolved form,
    # and the comparison may be wrongly different because of an extra ending slash
    fname = substitute(fname, '/$', '', '')

    if fname == ''
        @o = '[No Name]'
    elseif &buftype == 'quickfix'
        setreg('o', [w:quickfix_title], 'c')
    else
        if fname[0] == '/' || fname =~ '^\l\+://'
            var resolved: string = resolve(fname)
            var out: string = resolved == fname ? fname : fname .. ' -> ' .. resolved
            setreg('o', [out], 'c')
        else
            # Why is adding the current working directory sometimes necessary?{{{
            #
            # If you edit a new buffer whose path is relative (to the working
            # directory), `expand('%:p')` will return a relative path:
            #
            #     :cd /tmp
            #     :e foo/bar
            #     :echo expand('%:p')
            #}}}
            var out: string = getcwd() .. '/' .. fname
            setreg('o', [out], 'c')
        endif
    endif

    echo @o
enddef

# -q               faq {{{4

# Purpose:{{{
#
# Open a split in which you can write answers to a faq in a wiki.
# The height of the split will stay the same, even when you focus the wiki,
# because we temporarily set its window option 'pvw'.
# Also, we temporarily enable the “auto open folds” mode.
#}}}
# Usage:{{{
#
#     press `-q`: begin answering a faq in a wiki
#
#     press `-q` again: stop answering the faq
#}}}

nno -q <cmd>exe <sid>Faq()<cr>

def Faq(): string
    # If you move this function outside the vimrc, there's no guarantee that `$XDG_RUNTIME_VIM` is set.{{{
    #
    # In that case, rewrite the code like so:
    #
    #     # outside the function
    #     const DIR: string = getenv('XDG_RUNTIME_VIM') ?? '/tmp'
    #
    #     ...
    #
    #     # inside the function
    #     if expand('%:p')->stridx('/wiki/') == -1 && expand('%:p') != DIR .. '/faq'
    #}}}
    if expand('%:p')->stridx('/wiki/') == -1 && expand('%:p') != $XDG_RUNTIME_VIM .. '/faq'
        return 'echo "you''re not in a wiki"'
    endif

    var this_tab: number = tabpagenr()
    var win_in_this_tab: list<dict<any>> = getwininfo()
        ->filter((_, v: dict<any>): bool => v.tabnr == this_tab)
    var faq_file: string = $XDG_RUNTIME_VIM .. '/faq'

    for win in win_in_this_tab
        if get(win, 'bufnr', '')->bufname() == faq_file
            exe ':' .. win.winnr .. 'q'
            sil! FoldAutoOpen 0
            return ''
        endif
    endfor

    if win_in_this_tab
        ->mapnew((_, v: dict<any>): bool => getwinvar(v.winnr, '&pvw'))
        ->index(true) >= 0
        return 'echoerr "E590: A preview window already exists: previewwindow"'
    endif

    if win_in_this_tab
        ->mapnew((_, v: dict<any>): string => bufname(v.bufnr))
        ->index(faq_file) >= 0
        echo 'a window displaying  ' .. faq_file .. '  already exists'
        return ''
    endif

    exe 'sp ' .. faq_file
    setl pvw
    sil! FoldAutoOpen 1
    wincmd p
    return ''
enddef

# -r               edit README {{{4

# Works also for a CONTENTS file.
#
# Idea: Create a `CONTENTS.md` file in each of your wiki.
# Use it as  a table of contents,  which briefly explains what each  page of the
# wiki is about.

nno -r <cmd>call <sid>EditReadme()<cr>

def EditReadme()
    if expand('%:p:h') == $HOME
        sp ~/.README.md | exe ':1'
        return
    endif
    var files: list<string> = (expand('%:p:h') .. '/*')->glob(false, true)
    var kwd: string = '\%(readme\|contents\)'
    var pat: string = '\c/' .. kwd .. '\%(\..\{-}\)\=$'
    var readmes: list<string> = filter(files, (_, v: string): bool => v =~ pat)
    var readme: string = get(readmes, 0, '')
    if filereadable(readme) || isdirectory(readme)
        exe 'sp ' .. readme
        :1
    endif
enddef

# -s               edit snippets {{{4

# Why did you remove `-S`, which showed all our snippets?{{{
#
# `SPC fs` is better.
# It lets  us fuzzy search  our snippets, and can  automatically inserts+expands
# the selected tab trigger.
#}}}
nno -s <cmd>UltiSnipsEdit<cr>

# -U               show unicode table {{{4

# We define this mappping because  it's more convenient than the `:UnicodeTable`
# command, and  to install a buffer-local  mapping to close the  “unicode table“
# window with a single `q` (instead of `:q`).
nno -U <cmd>call <sid>UnicodeTable()<cr>

def UnicodeTable()
    UnicodeTable
    nno <buffer><expr><nowait> q reg_recording() != '' ? 'q' : '<cmd>q<cr>'
enddef

# }}}3
# plus {{{3
# +>    +<      split/join listing or long data {{{4

# long data = dictionary, list, bulleted list

nno <expr> +> myfuncs#longDataSplit()

nno <expr> +< myfuncs#longDataJoin()
xno <expr> +< myfuncs#longDataJoin()

# +e            emphasize {{{4

# word → *word*
# WORD → *word*
nno <expr> +e <sid>Emphasize()
def Emphasize(type = ''): string
    if type == ''
        &opfunc = expand('<stack>')->matchstr('.*\zs<SNR>\w*')
        return 'g@l'
    endif
    var word: string = expand('<cword>')
    if word !~ '^\k*$'
        return ''
    endif
    var line: string = getline('.')
    var col: number = col('.')
    # the negative lookbehind is  necessary to prevent a match when  we are on a
    # sequence of whitespace before a word
    var pat: string = '\%(\%' .. col .. 'c.\+\)\@<!'
        .. word .. '\%(.*\%' .. col .. 'c\)\@!'
    if line !~ pat
        return ''
    endif
    var rep: string = '*' .. tolower(word) .. '*'
    var new_line: string = substitute(line, pat, rep, '')
    setline('.', new_line)
    return ''
enddef

# +t            trim whitespace {{{4

nno <expr> +t  myfuncs#opTrimWs()
xno <expr> +t  myfuncs#opTrimWs()
nno <expr> +tt myfuncs#opTrimWs() .. '_'
# }}}3
# Control / Meta / CR / Tab / Shift {{{3
# CR                  move cursor on 80th column {{{4

# If the buffer is special (`!empty(&buftype)`), we let `CR` unchanged.
# Special  buffers  include   the  ones  displayed  in  the   quickfix  and  the
# command-line windows.
# It's important to not alter the behavior of `CR` in those buffers, because
# usually it's already mapped to a very useful function such as executing
# a command or going to an entry in the quickfix list.
#
# Otherwise, if the buffer  is a regular one, we remap `CR` to  move on the 80th
# column.  It can be overridden on a filetype-basis, by an arbitrary Ex command.
# Example:
#
#     b:cr_command = 'echo "hello"'
#
# If we wrote the previous line in a python ftplugin, hitting CR would display
# 'hello'.

nno <expr> <cr> !empty(&buftype)
    \ ?     '<cr>'
    \ :     '<cmd>' .. getbufvar('%', 'cr_command', 'norm! 80<bar>') .. '<cr>'

# S-→    C-↑ ...      modified arrow keys {{{4

# When  Vim runs  inside a  terminal whose  name begins  with `xterm`  (`xterm`,
# `xterm-256color`), it automatically sets up  a few keys including the modified
# arrow keys (`S-Left`, `S-Right`, `C-Up`, `C-Down` ...).
#
# However, if the name  of the terminal begins with `screen`  or `tmux`, it does
# *not* set up those keys.
# Because of this, Vim does *not* set up  the modified arrow keys when we run it
# inside tmux.  This means we can't map any action to a modified arrow key.
# For example, by  default Vim moves the  cursor by word in normal  mode when we
# hit `S-Left` / `S-Right`.
#
# We need to set up the modified arrow keys ourselves.

# To understand the code, read:
# https://unix.stackexchange.com/a/34723/289772
#
# From `:h version7`:
#
#    > Not all modifiers were recognized for xterm function keys.  Added the
#    > possibility in term codes to end in ";*X" or "O*X", where X is any
#    > character and the * stands for the modifier code.
#    > Added the <xUp>, <xDown>, <xLeft> and <xRight> keys, to be able to
#    > recognize the two forms that xterm can send their codes in and still
#    > handle all possible modifiers.
#
# The `*` in the next code stands for the modifier `C-`, `S-`, `M-`.
# While the `x` is there because it seems that `xterm` can send codes in
# 2 forms.
#
# See also: `:h xterm-modifier-keys`.

if &term =~ '^\%(screen\|tmux\)'
    sil! exe "set <xUp>=\e[1;*A"
    sil! exe "set <xDown>=\e[1;*B"
    sil! exe "set <xRight>=\e[1;*C"
    sil! exe "set <xLeft>=\e[1;*D"
endif

# C-]                 jump to definition {{{4

# Purpose:{{{
#
# This mapping overloads `C-]`.
#
# It keeps  its default behavior, however,  if it fails because  there's no tags
# file, it tries `1gd` as a fallback.
#
# It's useful for example, in `~/bin`, where atm we don't have any tags file.
#}}}
# Why `1gd` instead of `gd`?{{{
#
# Sometimes, `gd` jumps  to a location where the identifier  under the cursor is
# present, but it's not its definition.
# It happens for example,  if you have a shell script  which includes a function
# `install`, and the command `aptitude install package` somewhere in a function.
#
# `1gd` makes `gd` ignore any occurrence of the identifier which is inside curly
# brackets, and with  the closing one written  on a column whose  index is lower
# than the one of the current cursor position.
#}}}
nno <c-]> <cmd>call <sid>JumpToDefinition()<cr>

def JumpToDefinition()
    try
        exe "norm! \<c-]>zvzz"
    catch /^Vim\%((\a\+)\)\=:E\%(426\|433\)/
        if &filetype != 'help'
            norm! 1gd
            norm! zvzz
        else
            Catch() | return
        endif
    catch
        Catch() | return
    endtry
enddef

# C-a                 toggle some characters {{{4

nno <expr> <c-a> <sid>CA()

def CA(): string
    var pos: list<number> = searchpos('[✘✔]', 'cW', line('.'))
    if pos == [0, 0]
        return "\<c-a>"
    endif
    var char_under_cursor: string = getline('.')->matchstr('\%' .. pos[1] .. 'c.')
    var old2new: dict<string> = {
        '✘': '✔',
        '✔': '✘',
        }
    if !has_key(old2new, char_under_cursor)
        return ''
    endif
    var new_char: string = old2new[char_under_cursor]
    # Why returning a `|` motion?{{{
    #
    # From `:h :map-<expr>`:
    #
    #    > - Moving the cursor is allowed, but it is restored afterwards.
    #}}}
    var vcol: number = virtcol('.')
    return vcol .. '|r' .. new_char
enddef

# C-g                 run simple macro {{{4

# run a simple "macro" on all the lines
# What do you mean by "simple"?{{{
#
# It doesn't contain many keys, and it doesn't alter the addresses of the lines.
# Remember that `:norm` – like most Ex  commands – doesn't mark the lines in its
# range, contrary to `:g`.
#}}}
nno <c-g>n <cmd>%norm!<space>

# C-np                move across tab pages {{{4

nno <c-p> <cmd>tabprevious<cr>
nno <c-n> <cmd>exe (v:count > 1 ? v:count : '') .. 'tabnext'<cr>

# C-q t  C-q T        search Todo, fixme, ... {{{4

nno <c-q>t <cmd>call myfuncs#searchTodo('buffer')<cr>
nno <c-q>T <cmd>call myfuncs#searchTodo('project')<cr>
#      │
#      └ quickfix

# C-w s               send to tab page {{{4

nno <c-w>s <cmd>call myfuncs#sendToTabPage(v:count)<cr>

# M-n    M-p          navigate between marks {{{4

sil! MapMeta('n', "]'", 'n', '')
sil! MapMeta('p', "['", 'n', '')
# }}}3
# @@ {{{3

# Save the name of the last register executed interactively, to avoid a pitfall with `@@`.{{{
#
# During a  recording, if  you use a  mapping whose rhs  contains `@=`,  it will
# reset the last executed register.
#
# More generally,  if you execute  `@b` during  a recording into  register `"a`,
# `"b` will be considered  to be the last executed register,  not `"a`, and `@@`
# will re-execute it.  If that happens,  you'll probably find `@@`'s behavior to
# be unexpected.
#
#     $ vim -Nu NONE +'let @a = "a@a\e@b" | let @b = "a @b \e"'
#     " press @a: '@a @b ' is inserted
#     " press @@: ' @b'    is inserted
#
# To "fix" this,  we use this `@` wrapper  mapping to save the name  of the last
# register  executed *interactively*.   We assume  that a  register is  executed
# interactively iff no recording is active.
# Note  that this  assumption  may  be wrong;  you  *could*  execute a  register
# interactively while  a recording is  active.  But  in practice, I  doubt we'll
# ever want to re-execute such a register with `@@`.
# Usually,  we  press  `@@`  to  re-execute  a  register  which  we've  executed
# previously *outside* a recording.
#}}}
nno <expr> @ <sid>SaveLastRegisterExecutedInteractively()
def SaveLastRegisterExecutedInteractively(): string
    # ask which register we want to execute
    var c: any = getchar()
    # `c` is not necessarily a number.{{{
    #
    # It  could  be  a  string.   For   example,  this  is  the  case  when  Vim
    # automatically presses the pseudo-key `<CursorHold>`.
    #
    # From `:h getchar()`:
    #
    #    > If it is a single character, the result is a number.  [...]
    #    > **Otherwise a String is returned** with the encoded character.
    #}}}
    if typename(c) != 'number'
        return '@'
    endif
    var char: string = nr2char(c, 1)
    if reg_executing()->empty()
        last_register_executed_interactively = char
    endif
    return '@' .. char
enddef

nno <expr> @@ <sid>Atat()
def Atat(): string
    return '@' .. last_register_executed_interactively
enddef
var last_register_executed_interactively: string = '@'

# _                   0_ {{{3

# Problem:
#
#     # start xterm with default geometry (80 columns)
#     $ vim -Nu NONE +"pu='some short text'" +"pu=repeat(' ', 50) .. repeat('some long text ', 10)" +'setl nowrap'
#     " press `$` to move to the end of the line
#     " press `_` to move to the first non-whitespace of the line
#
#     " the text of the first line is partially hidden:
#     " you can only read `text`, not `some short text`
#
# Solution:
nno _ 0_

# << >>                  indent with 'shiftround' {{{3

nno <expr> >> <sid>IndentWithShiftroundSetup('>>')
nno <expr> << <sid>IndentWithShiftroundSetup('<<')

def IndentWithShiftroundSetup(cmd: string): string
    indent_with_shiftround = {cmd: cmd}
    &opfunc = expand('<SID>') .. 'IndentWithShiftround'
    return 'g@l'
enddef
var indent_with_shiftround: dict<string>

def IndentWithShiftround(type: string)
    var cmd: string = indent_with_shiftround.cmd
    var sr_save: bool = &shiftround
    try
        set shiftround
        exe 'norm! ' .. (v:count != 0 ? v:count : '') .. cmd
    catch
        Catch()
        return
    finally
        &shiftround = sr_save
    endtry
enddef

# <b  >b              destroy/create box {{{3

# Draw a box around the text inside the paragraph.
# The fields must be separated with `|`.
# The function will populate the `s` and `x` registers with 2 kind of separation
# lines.  We can paste them to fine tune the box.
nno <expr> >b myfuncs#boxCreate() .. 'ip'

# undo the box, make it come back to just bars between cells
nno <expr> <b myfuncs#boxDestroy() .. 'ip'

# ""                  easier access to clipboard register (and tweak paste/yank) {{{3

# We don't tweak `'cb'` anymore, because it causes too many issues.
# We use a mapping instead.
# We also leverage  this mapping to replace  some characters after a  paste in a
# markdown file; e.g. `’` → `'`.

nno "" <cmd>call <sid>EasyAndCustomPaste()<cr>"+
xno "" "+

def EasyAndCustomPaste()
    var reginfo: dict<any> = getreginfo('+')
    var contents: list<string> = get(reginfo, 'regcontents', [])
    # We manipulate the `+` register in case we're going to paste it.
    # But what if we're going to yank some text into it?{{{
    #
    # Our manipulation won't have any effect.
    # Whatever  we're going  to yank  will overwrite  the old  (and manipulated)
    # register.
    #}}}
    if &ft == 'markdown'
        map(contents, (_, v: string): string => substitute(v, '’', "'", 'g'))
        map(contents, (_, v: string): string => substitute(v, '\w\zs \ze, \w', '', 'g'))
        if getline('.') =~ '^\S\|^$'
            map(contents, (_, v: string): string => substitute(v, '^\s*\zshttp.*', '<&>', ''))
        endif
    endif
    map(contents, (_, v: string): string => substitute(v, '٪', '$', 'g'))
    setreg('+', reginfo)
enddef

# When we yank a multiline shell command, we want to be able to paste it and run
# it immediately in an interactive shell.
augroup FixMultilineShellCommand | au!
    au TextYankPost * FixMultilineShellcmd()
augroup END

def FixMultilineShellcmd()
    if v:register != '+'
        return
    endif

    var reginfo: dict<any> = getreginfo('+')
    var contents: list<string> = get(reginfo, 'regcontents', [])

    var cml: string = matchstr(&l:cms, '\S*\ze\s*%s')
    cml = '\%(\V' .. escape(cml, '\') .. '\m\)\='

    # remove possible dollar sign in front of a shell command
    var pat: string = '^\s*' .. cml .. '\s*\$\s'
    if contents[0] =~ pat
        contents[0] = substitute(contents[0], pat, '', '')
    endif

    # remove possible indentation/comment leader in front of terminating `EOF`
    if len(contents) > 1
        # Why do you look for `EOF` only on the first line of the register?{{{
        #
        # We don't want to remove the  indentation if we're copying a bug report
        # which  includes some  heredoc.   We  need it  so  that it's  correctly
        # formatted as a codeblock on whatever forum we paste it.
        #}}}
        if contents[0] =~ '<<-\=\([''"]\=\)EOF\1'
            var eof_line: string = contents[match(contents, '^\s*' .. cml .. '\s*EOF$')]
            var indent: string = matchstr(eof_line, '^\s*' .. cml .. '\s*')
            map(contents, (_, v: string): string => substitute(v, indent, '', ''))
        endif
    endif

    setreg('+', reginfo)
enddef

# Problem: Fix `E353` in case `"+` has been written into from another Vim instance.{{{
#
# Indeed, the previous mapping and autocmd write into `"+`; now watch this:
#
#     " first Vim instance
#     $ vim -Nu NONE -i NONE +"pu!='first' | norm! \"+y$" +'reg "+'
#
#     " second Vim instance
#     $ vim -Nu NONE -i NONE +'let @+ = "second"'
#
#     " from first Vim instance
#     E353: Nothing in register "~
#     :reg "+
#     Type Name Content~
#       c  "+   second~
#
# For  some reason,  writing into  `"+` from  a second  Vim instance  breaks the
# connection from `""` to `"+` in the first instance.
#}}}
# Solution: run `:reg "` before putting the unnamed register.{{{
#
# For some reason, this reconnects `""` to `"+`.
#}}}
# https://github.com/vim/vim/issues/6435
nno <expr> p <sid>P('p')
nno <expr> P <sid>P('P')
xno <expr> p <sid>P('p')
xno <expr> P <sid>P('P')

def P(key: string): string
    sil reg "
    return key
enddef

# { }                 move by paragraphs {{{3

nno { <cmd>call search('\(^\s*$\<bar>\%^\)\_s*\zs\S', 'bW')<cr>zv
nno } <cmd>call search('\S\+.*\ze\n\s*$', 'W')<cr>zv

# c*                  change word under cursor {{{3

# What you need to know to understand these mappings:{{{
#
# 1. `cgn` changes the next occurrence of the search register.
#    `cgN` changes the previous occurrence of the search register.
#
# 2. We've enabled 'ignorecase', because it's convenient for a broader search.
#    We've enabled 'smartcase', to make Vim a bit smarter:
#    if the search register contains uppercase characters,
#    we probably want to take the case into account.
#
# 3. `*` and `/` are resp. stupid and clever,
#    because the former ignores 'smartcase' while the latter respects it.
#
# 4. The `c*` mapping uses `*` to populate the search register,
#    so it will be stupid, and we need to make it clever:
#
#         /<up><cr>``
#         │
#         └ fixes `*` stupidity
#}}}

#      ┌ populate search register with word under cursor
#      │
#      │┌ get back where we were
#      ││
#      ││          ┌ get back where we were
#      ││          │
#      ││          │ ┌ change next occurrence of pattern
#      ││          │ ├─┐
nno c* *``/<up><cr>``cgn
#         ├───────┘
#         └ take 'smartcase' into account

nno c# #``/<up><cr>``cgN


# We also install `cg*` and `cg#` if we want to look for the word under the
# cursor *without* the anchors `\<`, `\>`.
nno cg* g*``/<up><cr>``cgn
nno cg# g#``/<up><cr>``cgN

# cc {{{3

# https://github.com/vim/vim/issues/7737
nno cc <cmd>call <sid>CC()<cr>

def CC()
    var indent: string = getline('.')->matchstr('^\s*')
    exe 'norm! 0' .. v:count .. 'C'
    startinsert
    if &l:ai
        if &l:indentexpr == '' && !&l:cindent
            setline('.', indent)
            startinsert!
        else
            FixIndent()
        endif
    endif
enddef

# crg                 coerce to glyph {{{3

# The behavior of this operator can be customized via
# g:Unicode_ConvertDigraphSubset.
# Have a look at: ~/.vim/after/plugin/abbrev.vim

nmap crg  <plug>(MakeDigraph)
nmap crgg <plug>(MakeDigraph)_

# d[gv]...            delete all lines containing/excluding some pattern {{{3

# If you need to delete folds, use `zd`, `zD`, or `zE`.
# They also work in visual mode (except `zE`).

nno dg<space> <cmd>call myfuncs#deleteMatchingLines('empty')<cr>
xno mg<space> <cmd>call myfuncs#deleteMatchingLines('empty')<cr>

nno dg" <cmd>call myfuncs#deleteMatchingLines('comments')<cr>
xno mg" <cmd>call myfuncs#deleteMatchingLines('comments')<cr>
nno dv" <cmd>call myfuncs#deleteMatchingLines('comments', v:true)<cr>
xno mv" <cmd>call myfuncs#deleteMatchingLines('comments', v:true)<cr>

nno dg/ <cmd>call myfuncs#deleteMatchingLines('search')<cr>
xno mg/ <cmd>call myfuncs#deleteMatchingLines('search')<cr>
nno dv/ <cmd>call myfuncs#deleteMatchingLines('search', v:true)<cr>
xno mv/ <cmd>call myfuncs#deleteMatchingLines('search', v:true)<cr>

# dr                  replace without yank {{{3

nno <expr> dr  myfuncs#opReplaceWithoutYank()
nno <expr> drr myfuncs#opReplaceWithoutYank() .. '_'

# j  k  ^  0  $       gj  gk  ... {{{3

# let us move across several lines of a long wrapped line with `j` and `k`
nno <expr> j <sid>JK('j')
nno <expr> k <sid>JK('k')

def JK(key: string): string
    # if we used a count, we probably don't care about wrapped lines
    if v:count != 0
    # Don't use `gj` or `gk` when we're in a closed fold.{{{
    #
    # Otherwise, when we  open a fold with `za`, the  first visible line depends
    # on the direction in which we landed on the fold:
    #
    #  - if we've moved from *below*, the first visible line is the *last* line in the fold
    #  - if we've moved from *above*, the first visible line is the *first* line in the fold
    #
    # This is a new behavior introduced in 8.2.2385.
    # It might  make sense,  but I  find this  confusing; I  prefer the  fold to
    # always open in the same way, regardless of how we reached it.
    #}}}
    || foldclosed('.') >= 0
        return (v:count >= 5 ? "m'" .. v:count : '') .. key
        #       ├─────────────────────────────────┘
        #       └ if the count was bigger than 5,
        #         we consider the motion as a jump useful to come back with `c-o`
    else
        return 'g' .. key
    endif
enddef

nmap <down> j
nmap <up> k

# If we're inside a long wrapped line, `^` and `0` should go the beginning
# of the line of the screen (not the beginning of the long line of the file).
nno ^ g^
nno 0 g0

# To draw freely, sometimes we need to enable 'virtualedit'.
# And then, when we press `$`, the cursor moves to the very end of the screen.
# We never want that.  We want the cursor on the last non whitespace.
nno <expr> $ &virtualedit ==# 'block' ? '$' : 'g_'
# Do *not* use `g$` by default (i. e. don't write `g$` in the lhs when 've' is 'block')!  Keep using `$`.{{{
#
# It would break the dot command when you've pressed `$` right before.
#
# MWE:
#
#     $ vim -Nu NONE =(cat <<'EOF'
#     foo = a
#           ab
#           abc
#     EOF
#     )
#
#     / a$
#     " press:  C-v G h A ' Esc
#     " press:  g$.
#
# Result:
#
#     foo = 'a'
#           'a'b
#           'a'bc
#
# Expected:
#
#     foo = 'a'
#           'a'b
#           'abc'
#
# Theory: Maybe `$` moves the cursor on the  newline, while `g$` moves it on the
# last character of the screen line (excluding the newline).
# And for the dot command to work as expected, we need to be on the newline...
#}}}

# Same mappings for visual mode.
xno j gj
xno k gk
xno ^ g^
xno 0 g0

# J        gJ         join without moving {{{3

nno <expr> J "m'" .. v:count1 .. 'J``'

# gJ doesn't insert or remove any spaces
nno <expr> gJ "m'" .. v:count1 .. 'gJ``'

# Q        q {{{3

# no more entering Ex mode by accident
nno Q q

# }}}2
# Objects {{{2
# i- {{{3

xno i- <cmd>call myfuncs#HorizontalRulesTextobject('inside')<cr>
xno a- <cmd>call myfuncs#HorizontalRulesTextobject('around')<cr>

ono i- <cmd>norm Vi-<cr>
ono a- <cmd>norm Va-<cr>

# iE {{{3

# Entire buffer
# We don't use `ie` but `iE`, because `ie` is too easily typed.
# We could easily delete the whole buffer `cie`, `die` by mistake.

xno iE G$ogg0
ono iE <cmd>norm ViE<cr>

# iF {{{3

xno iF <cmd>call <sid>FencedCodeblock('inside')<cr>
xno aF <cmd>call <sid>FencedCodeblock('around')<cr>

ono iF <cmd>norm ViF<cr>
ono aF <cmd>norm VaF<cr>

def FencedCodeblock(what: string)
    if mode() != 'V'
        norm! V
    endif
    if what == 'around'
        if search('^```\l*$', 'bW') == 0
            return
        endif
        norm! o
        search('^```$', 'W')
    else
        if search('^```\l*$', 'bW') == 0
            return
        endif
        norm! jo
        if search('^```$', 'W') == 0
            return
        endif
        norm! k
    endif
enddef

# iN {{{3

# We don't use `in` but `iN`, because `in` is already used by `targets.vim`.

# next number after cursor on current line
xno iN <cmd>call <sid>TextobjNumber(v:false)<cr>
# same thing, but includes possible whitespace after the number
xno aN <cmd>call <sid>TextobjNumber(v:true)<cr>

ono iN <cmd>norm viN<cr>
ono aN <cmd>norm vaN<cr>

def TextobjNumber(around: bool)
    var stopline: number = line('.')
    var pat: string = '\%(' .. GetPatnum() .. '\)' .. (around ? '\s*' : '')
    # move cursor to end of number
    if search(pat, 'ceW', stopline) == 0
        return
    endif

    # select back to start of number
    norm! o
    search(pat, 'cW', stopline)
enddef

def GetPatnum(): string
    var sign: string = '[-+]\='
    var decimal: string = '\d\+\.\=\d*'
    var fraction: string = '\.\d\+'
    var exponent: string = '[eE]' .. sign .. '\d\+'
    var number: string = printf('%s\%%(%s\|%s\)\%%(%s\)\=',
        sign, decimal, fraction, exponent)

    var binary: string = '0b[01]\+'
    var hex: string = '0x\x\+'

    # the order matters; keep `number` at the end
    var pat: string = binary .. '\|' .. hex .. '\|' .. number
    return pat
enddef

# iS {{{3

# `vim-sandwich` installs the following mappings:
#
#     x  is  <plug>(textobj-sandwich-query-i)
#     x  as  <plug>(textobj-sandwich-query-a)
#     o  is  <plug>(textobj-sandwich-query-i)
#     o  as  <plug>(textobj-sandwich-query-a)
#
# They  shadow the  built-in  sentences objects.   But we  use  the latter  less
# frequently than the sandwich objects.  So, we won't remove the mappings.  But,
# instead, to restore the sentences objects, we install these mappings:

ono iS is
ono aS as

xno iS is
xno aS as
# if {{{3

# Vim function

xno if <cmd>call <sid>TextobjFunc(v:true)<cr>
xno af <cmd>call <sid>TextobjFunc(v:false)<cr>

ono if <cmd>norm Vif<cr>
ono af <cmd>norm Vaf<cr>

def TextobjFunc(inside: bool)
    var start: string = '^\C\s*\%(fu\%[nction](\@!\|\%(export\s\+\)\=def\)\>'
    var end: string = '^\C\s*\%(endfu\%[nction]\|enddef\)\s*$'
    var curline: string = getline('.')

    # special cases: we're on the first or last line of a function
    if inside && curline =~ start
        if getline(line('.') + 1) =~ end
            # there's no inside in an empty function
            return
        endif
        norm! j
    elseif inside && curline =~ end
        if getline(line('.') - 1) =~ start
            # there's no inside in an empty function
            return
        endif
        norm! kok
    elseif !inside && curline =~ start
        # To be sure we are not on the first character.{{{
        #
        # `vaf` unexpectedly fails when we're on the first character.
        # That's because  – for  some reason  – `searchpair()`  fails to  find a
        # function when we're at its very beginning (and use the `c` flag).
        #
        #     vim9script
        #     var lines: list<string> =<< trim END
        #         def Func()
        #         enddef
        #     END
        #     setline(1, lines)
        #     echo searchpair('^def', '', '^enddef$', 'cnW')
        #     0~
        #     ✘
        #
        #     vim9script
        #     var lines: list<string> =<< trim END
        #         def Func()
        #         enddef
        #     END
        #     setline(1, lines)
        #     norm! $
        #     echo searchpair('^def', '', '^enddef$', 'cnW')
        #     2~
        #     ✔
        #}}}
        norm! $
    elseif !inside && curline =~ end
        if getline(line('.') - 1) =~ start
            norm! Vk
            return
        endif
        norm! kok
    endif

    # look for the end of the function
    if searchpair(start, '', end, 'cW') <= 0
        return
    endif
    # we want a linewise selection no matter the original visual mode
    if mode() != 'V'
        norm! V
    endif
    if inside
        norm! k
    endif
    # focus the other selection's corner
    norm! o
    # now look for the start of the function
    if searchpair(start, '', end, 'bcW') <= 0
        return
    endif
    if inside
        norm! j
    endif
enddef

# il {{{3

# `il` = in line (operate on the text between first and last non-whitespace on the line)
# Useful to copy a line and paste it characterwise (in the middle of another line)

xno il _og_
xno al V

ono il <cmd>norm vil<cr>
ono al _

# We don't need to create `al` (around line) to operate on the whole line
# including newline, because `_` can be used instead.
# Example:
#
#     +y_
#     +y3_
#
# ... add current line to plus register (`+y` = custom operator, incremental yanking).
# Besides, an operator should  be able to operate on the  current line when it's
# repeated (`cc`, `yy`, `dd`...).
# But still, it brings consistency/symmetry.

# }}}2
# Select {{{2

# DWIM:
# move to left/right in select mode (useful for UltiSnips)
snor <c-b> <c-\><c-n>i<left>
snor <c-f> <c-\><c-n>i<right>

# After expanding a  snippet, we want to  be able to delete  the character after
# the cursor with C-d like in insert mode.
snor <c-d> <c-\><c-n>i<del>

# Visual {{{2
# C-g g {{{3

# search inside visual selection
# What difference with `:*ilist! foobar`?{{{
#
# `:ilist`:
#
#    - searches in all included files. `:g` only in current buffer.
#    - can ignore comment if we don't put a bang
#    - automatically adds `\<`,`\>` around the pattern, if we don't surround it with slashes
#}}}
xno <c-g>g <c-\><c-n>:keepj keepp *g/\%V/#<left><left>

# /           search only in visual selection {{{3

# Do not try to install an `<expr>` mapping which would return the keys.{{{
#
# Before the  function checks the  position of the  visual marks, you  must have
# quit visual mode so that they have been updated.
# But you can't do that if the function is called while the text is locked.
#}}}
xno / <cmd>call <sid>VisualSlash()<cr>
def VisualSlash()
    # if  we've selected  only 1  line, we  probably don't  want to  look for  a
    # pattern; instead, we just want to extend the selection
    if line('v') == line('.')
        feedkeys('/', 'in')
    else
        feedkeys("\<c-\>\<c-n>/\\%V", 'in')
    endif
enddef

# .    @ {{{3

# repeat last edit on all the visually selected lines with dot
xno . <c-\><c-n><cmd>*norm! .<cr>
#                         ^
# Warning: The bang may prevent the repetition of pseudo-operators such as `ys` provided by `vim-surround`.{{{
#
# I think that's because `vim-surround` doesn't implement real operators.
# It emulates them.
# `vim-sandwich` doesn't suffer from this issue.
#}}}

# Purpose:{{{
#
# Repeat last macro on all the visually selected lines with `@{reg}`.
#}}}
xno @ <c-\><c-n><cmd>exe '*norm @' .. getchar()->nr2char()<cr>
#                             │
#                               └ Do *not* add a bang:{{{
#
# We want the recursiveness, for one of our mapping to be used.
# It temporarily disables some keysyms which may break the replay of a macro.
#}}}

# A  I  gI    niceblock {{{3

# https://github.com/kana/vim-niceblock/blob/master/doc/niceblock.txt
#
# v_b_I = Visual-block Insert
# v_b_A = Visual-block Append
#
#    - Make |v_b_I| and |v_b_A| available in all kinds of Visual mode.
#    - Adjust the selected area to be intuitive before doing blockwise insertion.

# Why appending `h` for the `$` motion in characterwise and blockwise visual mode?{{{
#
# In characterwise visual mode, `$` selects the trailing newline.
# We don't want that; `h` makes sure we leave it alone.
#
# ---
#
# In blockwise visual mode,  if you set `'ve'` with the  value `block` (which we
# do by default), then something unexpected happens.
#
# MWE:
#
#     abc
#     def
#     ghi
#
# Position the cursor on `a` and press `C-vjj$`, then yank or delete the block.
# Paste it below by running `:pu` (or pressing our custom `]p`):
# a trailing space is added on every pasted line.
#
# What's weird,  is that the  contents and type of  the unnamed register  is not
# affected by our custom `'ve'`.
# You only see a difference when you paste.
#
# Anyway, I don't like that trailing space.
# That's not how  Vim behave without config;  so this makes it  harder to follow
# instructions found on forums.
# Besides, a trailing space is useless.
#}}}
var niceblock_keys: dict<dict<string>> = {
    '$':  {v: 'g$h',      V: '$',          "\<c-v>": '$h'},
    'I':  {v: "\<c-v>I",  V: "\<c-v>^o^I", "\<c-v>": 'I'},
    'A':  {v: "\<c-v>A",  V: "\<c-v>0o$A", "\<c-v>": 'A'},
    'gI': {v: "\<c-v>0I", V: "\<c-v>0o$I", "\<c-v>": '0I'},
    '>':  {v: "\<c-v>>",  V: "0\<c-v>>",   "\<c-v>": '>'},
    '<':  {v: "\<c-v><",  V: "0\<c-v><",   "\<c-v>": '<'},
    }

def Niceblock(key: string): string
    return niceblock_keys[key][mode()]
enddef


# The purpose of this mapping is to not include a newline when selecting
# a characterwise text until the end of the line.
xno <expr> $ <sid>Niceblock('$')

xno <expr> I  <sid>Niceblock('I')
xno <expr> gI <sid>Niceblock('gI')
xno <expr> A  <sid>Niceblock('A')

# Why these assignments:
#
#     niceblock_keys['>']['V'] = "0\<c-v>>"
#     niceblock_keys['<']['V'] = "0\<c-v><"
#
# ... and not simply:
#
#     niceblock_keys['>']['V'] = ">"
#     niceblock_keys['<']['V'] = "<"
#
# ? Because, without "\<c-v>", sometimes the alignment is lost.

xno <expr> > <sid>Niceblock('>')
xno <expr> < <sid>Niceblock('<')

# d y         preserve last deleted/yanked visual selected text through registers {{{3

# When we delete sth in visual mode to  move it somewhere else, if we delete sth
# else before  pasting it, we  lose it  (well technically it's  still accessible
# from a numbered register, but if we  delete several things, we have to execute
# `:reg` to see where it is now).

# With this  mapping, we can  always access the last  text we deleted  in visual
# mode, from the `v` register.
xno d d<cmd>call getreginfo('"')->setreg('v')<cr>

# same thing when we yank
xno y y<cmd>call getreginfo('"')->setreg('v')<cr>

# h l         disable at the beginning/end of line in visual block mode {{{3

# Why `virtcol()`, and not `col()`?{{{
#
# With `col()`,  if the  first character  on the  cursor line  occupies multiple
# cells  but takes  only 1  byte  (e.g. a  tab  character or  a literal  control
# character), `h` would  not be able to  move onto its first cell.   It would be
# blocked on its last cell:
#
#     tab character
#     v------v
#     <------>xxx
#            ^
#            'h' could not move before that cell
#
# This is because  `col('.')` evaluates to 1  when `h` reaches the  last cell of
# the tab  character.  Indeed, it's the  byte index of the  cursor position; the
# cursor is considered to be on the first byte of the line.
#
# ---
#
# Same thing for `l`.
# We want  to know whether  the cursor has reached  the maximum number  of cells
# which can be  displayed in the current  window.  The byte index  of the cursor
# position could be much bigger depending on the kind of text which is currently
# displayed; but we don't care about the latter.
#}}}
xno <expr> h mode() ==# '<c-v>' && virtcol('.') == 1 ? '' : 'h'
xno <expr> l <sid>VL()

# Purpose:{{{
#
# Prevent Vim  from scrolling  horizontally when  we smash `l`  for too  long by
# accident while in visual block mode.
# When  that happens,  we lose  context, and need  to scroll  back in  the other
# direction which is annoying/distracting.
#
# If you *really*  want to visually select beyond the  current last screen cell,
# you can always use another motion like  `e` just to bypass the limit; then `l`
# is not blocked anymore.
#}}}
def VL(): string
    var siso: number = &l:siso != -1 ? &l:siso : &g:siso
    # this should evaluate to the total width of the fold/number/sign columns
    var left_columns: number = wincol() - virtcol('.')
    var offset: number = siso + left_columns
    return mode() == "\<c-v>" && virtcol('.') == winwidth(0) - offset ? '' : 'l'
enddef

# ip          disable on empty line {{{3

# sometimes we hit `vip` by accident on an empty line
# annoying, because it can make me lose previous visual selection
# (you can cycle through the last 2 visual selections with `gv`)

nno <expr> vip getline('.') =~# '^\s*$' ? '' : 'vip'

# mJ  m C-j   join blocks {{{3

# Difference compared to :JoinBlocks?:
#
#   - easier to use;  no need to position the cursor on
#                     the first line of the 2nd block
#                     no need to provide the nr of lines in a block
#                     as an argument
#
#   - not repeatable; each time we call it, we must first visually select
#                     the lines (or provide an arbitrary range)
#                     `:JoinBlocks` can be repeated simply by typing @:


# How does `join_blocks()` work?
# It mainly executes 3 commands:
#
#   - insert a literal ^A in front of all the lines in the 2nd block
#   - join the 2 blocks
#   - align the blocks using ^A as a delimiter

xno mJ <c-\><c-n><cmd>call myfuncs#joinBlocks()<cr>
xno m<c-j> <c-\><c-n><cmd>call myfuncs#joinBlocks(v:true)<cr>
#                                                 │
#                                                 └ first, reverse the order of the blocks
#                                                   then, join them

# mq          populate qfl with lines in the selection {{{3

xno mq <c-\><c-n><cmd>exe line("'<") .. ',' .. line("'>") .. 'cgetbuffer' <bar> cw<cr>

# P           paste without yanking selection in unnamed register {{{3

# If you want the original behavior, press `p` instead.
# By default, `x_p` and `x_P` do the same thing.
# Why don't you remap `p` instead of `P`?{{{
#
# If you do that, when you'll try  to reselect the text you've pasted with `gv`,
# you'll get an unexpected result.
# I'm ok with an unexpected result when pressing `P`, but not when pressing `p`.
#}}}
xno <expr> P '"_d"' .. v:register .. 'P'
# }}}1
# Commands {{{1
# Warning: Here, do NOT create commands which are only relevant for a specific type of buffer. {{{2
#
# Those should be defined in a filetype plugin with the `-buffer` attribute.
# }}}2

# Cfg {{{2

com -bar -nargs=1 -complete=custom,CfgComplete Cfg Cfg(<q-args>)

def CfgComplete(...l: list<any>): string
    return keys(PGM2CFGFILES)->sort()->join("\n")
enddef

def Cfg(pgm: string)
    var files: list<string>
    if has_key(PGM2CFGFILES, pgm)
        files = PGM2CFGFILES[pgm]
    else
        echohl ErrorMsg
        echo pgm .. ' is not supported'
        echohl NONE
        return
    endif
    filter(files, (_, v: string): bool => expand(v)->filereadable())
    if empty(files)
        echo 'no readable file'
    endif
    for file in files
        if expand('%:p') == '' && (line('$') + 1)->line2byte() <= 2
            exe 'e ' .. file
        else
            exe 'sp ' .. file
        endif
    endfor
enddef

var PGM2CFGFILES: dict<list<string>> = {
    autostart:     ['~/bin/autostartrc'],
    bash:          ['~/.bashrc', '~/.bashenv', '~/.bash_profile'],
    conky:         ['~/.config/conky/system.lua', '~/.config/conky/system_rings.lua', '~/.config/conky/time.lua'],
    fasd:          ['~/.fasdrc'],
    fd:            ['~/.fdignore'],
    firefox:       glob('~/.mozilla/firefox/*.default/chrome/userContent.css', false, true),
    git:           ['~/.config/git/config', '~/.cvsignore'],
    htop:          ['~/.config/htop/htoprc'],
    intersubs:     [
        '~/.config/mpv/scripts/interSubs.lua',
        '~/.config/mpv/scripts/python.disable/interSubs.py',
        '~/.config/mpv/scripts/python.disable/interSubs_config.py'
        ],
    keyboard:      glob('~/.config/keyboard/*', false, true),
    kitty:         ['~/.config/kitty/kitty.conf'],
    latexmk:       ['~/.config/latexmk/latexmkrc'],
    less:          ['~/.config/lesskey'],
    mpv:           ['~/.config/mpv/input.conf', '~/.config/mpv/mpv.conf'],
    newsboat:      ['~/.config/newsboat/config', '~/.config/newsboat/urls'],
    ranger:        ['~/.config/ranger/rc.conf'],
    readline:      ['~/.inputrc'],
    surfraw:       ['~/.config/surfraw/bookmarks', '~/.config/surfraw/conf'],
    tig:           ['~/.config/tigrc'],
    tmux:          ['~/.config/tmux/tmux.conf'],
    vim:           [$MYVIMRC],
    w3m:           ['~/.w3m/config'],
    weechat:       ['~/.config/weechat/script/rc.conf'],
    xbindkeys:     ['~/.config/keyboard/xbindkeys.conf'],
    zathura:       ['~/.config/zathura/zathurarc'],
    zsh:           ['~/.zshrc', '~/.zshenv'],
    zsh_snippets:  glob('~/.config/zsh-snippets/*.txt', false, true),
    }

# CGrep / LGrep {{{2

# Grep for a pattern below the cwd.

# Usage: `:CGrep 'pat' file ...` (like `grep(1)`).

# I have an improvement idea!  I just need to tweak the definitions of the commands...{{{
#
# OK, but remember:
#
#    1. The new synopsis should be identical to the one of `grep(1)`.
#
#       I.e.:
#       It should allow us to pass a quoted pattern, or an unquoted one.
#       It should allow us to pass the files/directories which we want to grep.
#
#    2. If you hesitate between several implementations, have a look at how Tpope
#       implemented `:CFind` in `vim-eunuch`.
#}}}
# How to search for a pattern containing a single quote?{{{
#
# Like with `grep(1)`.
# For example, if you want to grep `a'b"c`, run:
#
#     :CGrep 'a'\''b"c'
#}}}
com -nargs=1 CGrep myfuncs#GrepEx(<q-args>, false)
com -nargs=1 LGrep myfuncs#GrepEx(<q-args>, true)

# ClearRegisters {{{2

com -bar ClearRegisters ClearRegisters()

def ClearRegisters()
    var numeric: list<number> = range(10)
    var alpha: list<string> = range(char2nr('a'), char2nr('z'))
        ->mapnew((_, v: number): string => nr2char(v))
    var other: list<string> = ['-', '*', '+', '/', '=']
    map(numeric + alpha + other, (_, v: any) => setreg(v, {}))
enddef

# CombineParamValues {{{2

# Purpose:{{{
#
# Here is a situation which we frequently encounter:
#
# We find some issue which can be influenced by several parameters.
# To  get a  better  understanding, we  want  to  make a  test  in all  possible
# environments (i.e. for all combinations of parameters values).
#
# Getting all those combinations can be time-consuming, and tedious.
# We need a command to automate the task.
#}}}
# Usage:{{{
#
# Write all the possible values of each parameter on a dedicated line, separated
# by whitespace.  Then run the command against this range of lines.
#
# As an example, executing the command on these lines:
#
#     a
#     b c
#
# will replace them with:
#
#     a b
#     a c
#
# And these lines:
#
#     a
#     b c
#     d e f
#
# would be replaced by:
#
#     a b d
#     a b e
#     a b f
#     a c d
#     a c e
#     a c f
#}}}
com -bar -range=% CombineParamValues CombineParamValues(<line1>, <line2>)

def CombineParamValues(lnum1: number, lnum2: number)
    var param_values: list<list<string>> = getline(lnum1, lnum2)
        ->filter((_, v: string): bool => v != '')
        ->mapnew((_, v: string): list<string> => split(v))
    if len(param_values) < 2
        return
    endif
    var reg_save: list<dict<any>> = [getreginfo('0'), getreginfo('"')]
    @" = Combine(param_values)->join("\n")
    exe 'norm! ' .. lnum1 .. 'GV' .. lnum2 .. 'Gp'
    setreg('0', reg_save[0])
    setreg('"', reg_save[1])
    sil exe ':*EasyAlign *\ '
enddef

def Combine(param_values: list<list<string>>): list<string>
    var res: list<string>
    if len(param_values) == 2
        res = []
        for i in param_values[0]
            for j in param_values[1]
                res += [i .. ' ' .. j]
            endfor
        endfor
    else
        res = Combine([Combine(param_values[: -2]), param_values[-1]])
    endif
    return res
enddef

# Def {{{2

# `:def` – contrary to `:fu` – doesn't support any completion.
# https://github.com/vim/vim/issues/6525
# Let's fix that.

cnorea <expr> def getcmdtype() == ':' && getcmdpos() == 4 ? 'Def' : 'def'
com -bar -nargs=? -complete=customlist,FuncComplete Def Def(<q-args>)

def Def(name: string)
    var _name: string = trim(name, '()')
    try
        exe 'def ' .. _name
    catch
        Catch()
        return
    endtry
enddef

# DiffLines {{{2

com -bar -bang -range -nargs=? DiffLines myfuncs#diffLines(<bang>0, <line1>, <line2>, <q-args>)

# DiffOrig {{{2

# See differences between current buffer and original file.
com -bar DiffOrig echo DiffOrig()

def DiffOrig(): string
    save#toggleAuto()
    var cole_save: number = &l:conceallevel
    setl conceallevel=0

    if difforig_tempfile != ''
        sil! delete(difforig_tempfile)
        difforig_tempfile = ''
    endif
    difforig_tempfile = tempname() .. '/Original File'
    exe 'vnew ' .. difforig_tempfile
    setl buftype=nofile nobuflisted noswapfile nowrap

    sil exe ':0r ++edit ' .. bufname('#')->fnamemodify(':p')
    keepj :$d _
    setl nomodifiable readonly

    diffthis
    nno <buffer><expr><nowait> q reg_recording() != '' ? 'q' : '<cmd>q<cr>'
    &filetype = getbufvar('#', '&ft')

    TmpPartial = function(DiffOrigRestoreSettings, [cole_save])
    augroup DiffOrigRestoreSettings
        au! * <buffer>
        au BufWipeOut <buffer> save#toggleAuto(true) | timer_start(0, TmpPartial)
    augroup END

    exe ':' .. winnr('#') .. 'windo diffthis'
    return ''
enddef
var difforig_tempfile: string = ''
var TmpPartial: func

def DiffOrigRestoreSettings(cole: number, _: any)
    &l:cole = cole
    diffoff!
    norm! zvzz
    aug! DiffOrigRestoreSettings
enddef

# DumpWiki {{{2
# Usage:
#
#     :DumpWiki https://github.com/oniony/TMSU/

com -bar -nargs=1 DumpWiki myfuncs#dumpWiki(<q-args>)

# FormatManpage {{{2

com -bar -range=% FormatManpage FormatManpage(<line1>, <line2>)

def FormatManpage(line1: number, line2: number)
    var range: string = ':' .. line1 .. ',' .. line2
    var mods: string = 'sil keepj keepp '
    # create folds
    exe mods .. range .. 's/^\u\+/# &/e'
    # titlecase headers
    exe mods .. range .. 's/\%(^#.*\)\@<=\(\u\)\(\u\+\)/\1\L\2/ge'
    # make sure there's an empty line between a header and the next non-empty line
    exe mods .. range .. 'g/^#.*\n.*\S/call append(".", "")'
enddef

# GotoChar {{{2

com -bar -nargs=1 GotoChar search('\m\%^\_.\{<args>}', 'es')

# GrepCfg {{{2

# Description:{{{
#
# Search for a pattern inside all our configuration files.
#
# ---
#
# The basic idea is to get the list of all files in our config repo with:
#
#     # https://stackoverflow.com/a/8533413/9780968
#     $ config ls-tree --full-tree --name-only HEAD -r >/tmp/listing
#
# Make the paths absolute:
#
#     $ sed -i "s:^:$HOME/:" /tmp/listing
#
# Then feed them to `:vimgrep`.
#
# ---
#
# We need `sed(1)`,  because the paths output by `$ git  ls-tree` are relative to
# the root of the repo, which here is our home.
# But if we're not  in our home, the relative paths  will be interpreted wrongly
# by `$ vim -q`.
#
# ---
#
# You could also feed the file names to `grep(1)` via `xargs(1)`:
#
#     $ vim -q <(config ls-tree --full-tree -r --name-only HEAD | sed "s:^:$HOME/:" | xargs grep -HIins pattern) +cw
#
# But grep's regex engine is not as powerful as Vim.
#
# And it can't give you the column position.
# You can get the byte-offset from the  start of the file with `-ob`, but that's
# not the byte-offset from the start of the line.
#}}}
# Usage:{{{
#
#     :GrepCfg \<sed\>
#}}}
com -nargs=1 GrepCfg GrepCfg(<q-args>)

def GrepCfg(pat: string)
    var cmd: list<string> =<< trim END
        git
            --git-dir="${HOME}/.cfg/"
            --work-tree="${HOME}"
        ls-tree
            --full-tree
            --name-only HEAD
        -r
        | sed "s:^:${HOME}/:; \%.vim/tools/mthesaur.txt%d"
    END
    var files: list<string> = join(cmd)->systemlist()
    filter(files, (_, v: string): bool => filereadable(v))
    # we may  have a  versioned controlled symlink  pointing to  another version
    # controlled file (e.g. vimrc → init.vim); we don't want to vimgrep into the
    # same file twice (it would give duplicate entries)
    map(files, (_, v: string): string => resolve(v))
    sort(files)->uniq()
    try
        exe 'vim /' .. escape(pat, '/') .. '/gj ' .. join(files)
    catch /^Vim\%((\a\+)\)\=:E480:/
        echohl ErrorMsg
        echom v:exception
        echohl NONE
        return
    endtry
    setqflist([], 'a', {title: ':GrepCfg ' .. pat})
enddef

# HlWeirdWhitespace {{{2

# Why don't you use an autocmd instead?{{{
#
# So, you're thinking about sth like this:
#
#     augroup StrangeWhitespace | au!
#         au WinEnter * HlWeirdWhitespace()
#     augroup END
#
# OK, but we wouldn't be able to disable the highlight in a 'fex' buffer.
#
# The  same issue  would probably  apply to  other types  of buffers  (like help
# buffers), where we don't want this highlighting.
#
# The issue comes from the fact that when `WinEnter` is fired after a split, the
# current buffer is still the one displayed  in the original window, not the one
# which is going to be loaded.
# So this guard wouldn't work:
#
#     var bufnr: number = winnr()->winbufnr()
#     if getbufvar(bufnr, '&ft', '') == 'fex'
#         return
#     endif
#
# MWE:
#
#     :LogEvents! WinEnter
#     :sp /tmp/file
#     12:34  WinEnter  /home/user/.vim/vimrc~
#                      ^-------------------^
#                      ✘ we would need `/tmp/file`, but the latter has not yet been loaded~
#}}}
com -bar -range=% HlWeirdWhitespace HlWeirdWhitespace()

def HlWeirdWhitespace()
    if !exists('w:strange_whitespace')
        # https://vi.stackexchange.com/a/17697/17449
        var pat: string = '[\x0b\x0c\u00a0\u1680\u180e'
            .. '\u2000-\u200a\u2028\u202f\u205f\u3000\ufeff]'
        #       ├───────────┘
        #       └ yes, one can write an arbitrary range of unicode characters
        w:strange_whitespace = matchadd('ErrorMsg', pat, 0)
    else
        matchdelete(w:strange_whitespace)
        unlet! w:strange_whitespace
    endif
enddef

# InANotInB {{{2

# This command outputs the lines which are in buffer A but not in buffer B.

# Why `<f-args>`?{{{
#
# A filename can contain whitespace.
#}}}
com -bar -nargs=+ -complete=buffer InAButNotInB myfuncs#inANotInB(<f-args>)

# JoinBlocks {{{2

# The following command joins 2 blocks of lines.
# To use it, you must:
#
#    - remove possible empty lines between the blocks
#    - be on the 1st line of the 1st block
#    - provide the nr of lines of a block as an argument to the command
#
# After an initial join, you can repeat it with @:

# How it works?{{{
#
# If the blocks are 5 lines long, the command will execute:
#
#     ┌ for each line of the first block (.,.+4g/^/)
#     ├───────┐
#     .,.+4g/^/''+5m.|-j
#              ├────┘ ├┘
#              │      └ then join the two lines
#              │
#              └ move the first line of the second block (''+5) under the current one (m.)


# We can notice that the address of the 1st line of the 1st block is expressed
# in 2 different ways, depending on the context.
# Inside the range passed to `:g` it's `.` (current line when `:g` starts).
# Inside the command executed by `:g`, it can't be `.` anymore (because the
# current line changes constantly), so here we use `''` instead.
# Indeed, before jumping to the first line to process, `:g` adds an entry in the
# jumplist, whose mark is `''`. So:
#
#         we're on the 1st line of the 1st block
#     and ''    is a line specifier for the latter
#     and a block has 5 lines
#
#     ⇒
#
#     ''+5    is a line specifier for the 1st line of the second block
#
# This shows that the range passed to `:g` is entirely processed BEFORE
# the command (here `:m`) it executes.
# Remember:
# `.` doesn't stand for the same line inside a range passed to `:g`, and inside
# a range passed to a command executed by the same `:g`.
# Also, if `:Ex`  is a command executed by `:g`  (`:g/pat/Ex`), inside `:Ex` you
# can use `''` to refer to the initial line from which `:g` was started.


# `:g` will cycle through the lines of the 1st block, and always move + join
# the SAME line:
#
#         the 1st of the 2nd block
#
# But, the contents of this line will constantly change.  It will be successively:
#
#    - the 1st of the 2nd block
#    - the 2nd one (after the 1st has been joined)
#    - the 3rd one ("         2nd ")
#    - the 4th one ("         3rd ")
#    - the 5th one ("         4rd ")
#
# Why `-j`, and not simply `j` ?
# Because, when `:m` moves a line, the cursor doesn't stay where it is; it jumps
# onto the moved line.
# So, before joining the lines, we have to get back on the original line above
# (`-` = `.-1`).
#}}}

# This  command  isn't really  needed  (we  have `v_mj`),  but  we  keep it  for
# educational purpose.

com -bar -bang -nargs=1 JoinBlocks &l:fen = false
    | exe "sil keepp :.,.+<args>-1g/^/:''+<args>m . | :-j<bang>"
    | &l:fen = true

# OnlySelection {{{2

# This command deletes everything except the current visual selection (or any
# arbitrary range).
#
# Usage:
#
#     :'<,'>OnlySelection
#     :12,34OnlySelection

com -bar -range=% OnlySelection myfuncs#onlySelection(<line1>, <line2>)

# PluginsToCommit {{{2

com -bar -nargs=0 PluginsToCommit PluginsToCommit()

def PluginsToCommit()
    var script: string = 'commit-these-vim-plugins'
    if !executable(script)
        echom '[PluginsToCommit]: ' .. script .. ' is not available'
        return
    endif

    var my_plugins: list<string> = readfile($MYVIMRC)
    filter(my_plugins, (_, v: string): bool => v =~ '^\s*Plug\s\+''lacygoill/')
    map(my_plugins, (_, v: string): string => matchstr(v, 'lacygoill/\zs.\{-}\ze'''))
    sil var output: list<string> = systemlist('commit-these-vim-plugins ' .. join(my_plugins))
    # we may have removed a plugin, but not executed `:Plugclean` yet
    filter(output, (_, v: string): bool => v !~ 'No such file or directory')
    if output == []
        echom '[PluginsToCommit]: nothing to commit'
        return
    endif

    eval output
        ->filter((_, v: string): bool => v =~ '^\S')
        ->map((_, v: string): string =>
            glob($HOME .. '/.vim/plugged/' .. v .. '/*', false, true)[0]
            )
    setqflist([], ' ', {lines: output, efm: '%f', title: 'Plugins to commit'})
    cw
enddef

# PluginGlobalVariables {{{2

com -bar -nargs=? PluginGlobalVariables myfuncs#pluginGlobalVariables(<q-args>)

# PC    Plugin Clean {{{2

com -bar PC sil! PlugClean

# PI    Plugin Install {{{2

com -bar -nargs=1 PI myfuncs#pluginInstall(<q-args>)

# PUP   update Vim plugins {{{2

# Don't name the command `:PU`; it could shadow the default `:pu[t]`.
com -bar PUP PluginsUpdate()

def PluginsUpdate()
    # `:h spellfile-cleanup`
    # `sil!` to suppress `E108`.{{{
    #
    # The issue comes from this line:
    #
    #     # $VIMRUNTIME/spell/cleanadd.vim:30
    #     unlet s:fname
    #
    # The `s:fname`  variable may not exist  if the `for` loop  iterates over an
    # empty list; i.e. if this expression is empty:
    #
    #     globpath(&rtp, "spell/*.add")->split('\n')
    #}}}
    sil! runtime spell/cleanadd.vim

    # Install `wfrench` package.  Useful for dictionary completion.
    if system('aptitude show wfrench | grep "^State"')->trim("\n", 2) =~? 'state:\s*not\s\+installed'
        echom 'Need to install the wfrench package for the french dictionary.'
        var password: string = inputsecret('Enter sudo password:') .. "\n"
        sil var out: string = system('sudo -S aptitude install wfrench', password)
        echo out
    endif

    if !isdirectory($HOME .. '/.vim/tmp/snapshot')
        mkdir($HOME .. '/.vim/tmp/snapshot', 'p', 0o700)
    endif
    #                                                                                ┌ put the month before the day
    #                                                                                │ so that, in the output of `ls(1)`,
    #                                                                                │ the files are listed chronologically
    #                                                                                │
    exe 'PlugSnapshot! ' .. fnameescape($HOME .. '/.vim/tmp/snapshot/' .. strftime('%m-%d__%H-%M') .. '.vim')
    #                                                                                        │
    #                                             don't put a colon, it could be problematic ┘
    # Why a colon is a bad idea in a filename?{{{
    #
    # 1. It's not inside  the default value of 'isf'.  Which means  that Vim
    #   doesn't consider this character  to be a part  of a filename when
    #   using  `\f` in a pattern.
    #
    # 2. In most buffers, the local value of 'efm' probably uses the `%f` item
    #   to match a filename.  Here's what `:h error-file-format` says about
    #   the latter:
    #
    #     > The "%f" conversion may depend on the current 'isfname' setting.
    #
    #     So, if you try  to parse the output of a shell command,  or to read an
    #   error file/buffer  to populate  the qfl,  Vim will  fail to  recognize a
    #   filename containing a colon.  You'll get non-valid entries.
    #
    # 3. It's interpreted as a separator  in $PATH, so it can be dangerous if
    #   used in a directory.  And if we avoid the colon in a directory name,
    #   to stay consistent we should do the same in a filename.
    #
    # 4. It has a special meaning in  Windows, so if the file is copied on
    #   a different OS, it can cause an issue.
    #}}}
    # Which character are safe to use in a filename?{{{
    #
    #     [a-z]
    #     [A-Z]
    #     [0-9]
    #     .
    #     - (but not at the very beginning)
    #     _
    #
    # https://stackoverflow.com/a/458001/8243465
    # https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_282
    #}}}

    # wipe the Vim buffer containing the snapshot
    if getline(1) == '" Generated by vim-plug'
        bw
    endif
    PlugUpgrade
    PlugUpdate
enddef

# RemoveDuplicateLines {{{2

# Explanation:{{{
#
# Each  time awk  iterates over  a  new line,  it creates  an associative  array
# element with the entire line as the index and with the default value 0.
# The `!` operator negates 0, and the  final value is 1 (i.e. true); without any
# action, awk performs `{ print $0 }`, and the entire line gets printed.
#
# Then, the `++` operator is processed and  1 is added to the array value, which
# now becomes 1; this way, the next time the same line is encountered, the value
# returned by the array will be 1, which will  then be negated to 0 by `!`; as a
# result, the  default action won't be  executed (i.e. the duplicate  line won't
# get printed).
#
# See also: https://www.gnu.org/software/gawk/manual/html_node/History-Sorting.html#History-Sorting
#}}}
com -bar -range=% RemoveDuplicateLines sil :<line1>,<line2>!awk '\!x[$0]++'
#                                                                │{{{
#                                                                └ `:h :!`:
# `!` is replaced by the previous external command
# But not when there is a backslash before the '!', then that backslash is removed.
#}}}

# RemoveSwapFiles {{{2

com -bar RemoveSwapFiles glob($HOME .. '/.vim/tmp/swap/*', true, true)
    \ ->mapnew((_, v: string) => delete(v))

# RemoveTabs {{{2

# The purpose of this command is to replace all tab characters in the buffer
# with a nr of spaces which will occupy the same nr of cells.
#
# Before using it, set 'ts' (2, 4, 8) so that the text is aligned.
com -bar -range=% RemoveTabs myfuncs#removeTabs(<line1>, <line2>)

# Retab {{{2

# `:retab` substitutes all the tabs from a file to spaces.
# We don't want that.  We want a command which substitutes only leading tabs.
#
# Besides, `:retab` automatically chooses which  substitution to do based on the
# value  of `'expandtab'`.   That is,  if the  latter is  set, then  it replaces
# tabs into spaces.  Otherwise, it does the reverse substitution.
# We prefer to manually decide the type of substitution.
#
# So, we define `:Retab` which accepts a bang:
#
#     " tabs → spaces
#     :Retab
#
#     " spaces → tabs
#     :Retab!
#
# Mnemonic: we use spaces as the default way to indent, so it makes sense to
# to use a bang only for the less useful conversion: spaces → tabs

com -bar -bang -range=% Retab Retab(<line1>, <line2>, <bang>0)

def Retab(line1: number, line2: number, bang: bool)
    var view: dict<number> = winsaveview()
    var range: string = ':' .. line1 .. ',' .. line2
    var mods: string = 'sil keepj keepp '
    if !bang
        exe mods .. range .. 's:^\t\+:\=repeat(" ", &ts * submatch(0)->strlen()):e'
    else
        exe mods .. range .. 's:^\( \{' .. &ts .. '}\)\+:\=repeat("\t", submatch(0)->strlen()/&ts):e'
    endif
    winrestview(view)
enddef

# ReverseEveryNLines {{{2

com -bar -range=% -nargs=1 ReverseEveryNLines ReverseEveryNLines(<args>, <line1>, <line2>)

def ReverseEveryNLines(n: number, line1: number, line2: number)
    var mods: string = 'sil keepj keepp lockm '
    var range: string = ':' .. line1 .. ',' .. line2
    exe mods .. range .. printf('g/^/exe "m .-" .. Offset(%d, %d)', line1, n)
enddef

def Offset(line1: number, n: number): number
    var offset: number = (line('.') - line1 + 1) % n
    return offset != 0 ? offset : n
enddef

# ShowLongLines {{{2

# This command highlights in red the character after a given column.
# Repeat the command toggles the highlighting.

com -bar -nargs=? ShowLongLines echo ShowLongLines(<args>)

def ShowLongLines(n = 80): string
    if !exists('w:_showlonglines')
        w:_showlonglines = matchadd('Error', '\%' .. (n + 1) .. 'v', 0)
    else
        matchdelete(w:_showlonglines)
        unlet! w:_showlonglines
        if n != 80
        # we've executed 2 `:ShowLongLines` commands, probably with different arguments
        # we just got rid of the old match of the previous command,
        # now we need to create a new one for the 2nd command
            ShowLongLines(n)
        endif
    endif
    return ''
enddef

# SortLines {{{2

# Commented for the moment.  Keep it for educational purpose.

# We define the `:SortLines` command which moves lines containing `foo` or `bar` at
# the bottom.  Lines containing `foo` are put before the ones containing `bar`.

#     com -bar -range=% SortLines SortLines(<line1>, <line2>)
#
#     def SortLines(lnum1: number, lnum2: number)
#         getline(lnum1, lnum2)
#             ->sort(Compare_lines)
#             ->setline(lnum1)
#     enddef
#
#     def CompareLines(line1: string, line2: string): number
#         # The greater the score, the further to the right in the sorted list
#         var score1: number = line1 =~ 'bar' ? 2 : line1 =~ 'foo' ? 1 : 0
#         var score2: number = line2 =~ 'bar' ? 2 : line2 =~ 'foo' ? 1 : 0
#         return score1 - score2
#     enddef

# SumColumn {{{2

com -bar -range SumColumn sil! keepj keepp <line1>,<line2>g/=\s*$/ t. | s/// | exe '.!bc' | -j

# Tldr {{{2

com -bar -nargs=1 -complete=custom,TldrCompletion Tldr Tldr(<q-args>)

def TldrCompletion(...l: list<any>): string
    sil return system('tldr --list 2>/dev/null | tr -s "[ \t]" "\n"')
enddef

def Tldr(shellcmd: string)
    sil var out: list<string> = systemlist('tldr ' .. shellcmd)
    if get(out, 0, '') =~ '^tldr page.*not found$'
        echo out[0]
        return
    endif
    out
        ->map((_, v: string): string => substitute(v, '\e.\{-}m\|\%x0f', '', 'g'))
        ->map((_, v: string): string => substitute(v, '^-', '#', ''))
        ->map((_, v: string): string => substitute(v, '^  ', '    ', ''))
    sp /tmp/.tldr.md
    keepj :%d _
    setline(1, out)
    keepj keepp g/^#/append('.', '')
    update
    norm! gg
    nno <buffer><expr><nowait> q reg_recording() != '' ? 'q' : '<cmd>q<cr>'
enddef

# TW {{{2

com -bar -range=% TW TrimWhitespace(<line1>, <line2>)

def TrimWhitespace(line1: number, line2: number)
    var view: dict<number> = winsaveview()
    sil exe 'keepj keepp :' .. line1 .. ',' .. line2 .. 's/\s\+$//e'
    winrestview(view)
enddef

# WebPageRead {{{2

# this command opens a new tab page, loads a temporary buffer, and dumps
# the contents of a webpage inside the latter
com -bar -nargs=1 WebPageRead myfuncs#webpageRead(<q-args>)

# WordFrequency {{{2

# Display words in the current buffer sorted by frequency

com -bar -nargs=? -range=% -complete=custom,myfuncs#wfComplete
    \ WordFrequency
    \ myfuncs#wordFrequency(<line1>, <line2>, <q-args>)
# }}}1
# Autocmds {{{1
# Command Window {{{2

# Form more ideas:
# http://vim.wikia.com/wiki/Enhanced_command_window

augroup MyCmdlineWindow | au!
    # Purpose:{{{
    #
    # By default, `Tab` is mapped to `C-x C-v` in the command-line window.
    # This shadows our custom `Tab` mapping which can expand a snippet.
    #
    # This  local mapping  is not  installed in  the search  command-line window
    # (`q/`, `q?`), which is why we use the pattern `:` instead of `*`.
    #
    # Note that  for some  reason, UltiSnips  fails to expand  a snippet  in the
    # search command-line window.
    #}}}
    au CmdWinEnter : sil! iunmap <buffer> <tab>

    au CmdWinEnter * nno <buffer><expr><nowait> q reg_recording() != '' ? 'q' : '<cmd>q<cr>'
    au CmdWinEnter * nno <buffer><nowait> ZZ <cr>
    # Purpose:{{{
    #
    # By default, `C-c` is useful to  quit the command-line window, and populate
    # the command-line with the command which was being edited in the window.
    # But, it doesn't erases the command-line window.
    # Our `C-c` mapping takes care of that.
    #}}}
    au CmdWinEnter * nno <buffer><nowait> <c-c> <c-c><cmd>redraw<cr>
augroup END

# Create Missing Directory {{{2

def MakeMissingDir(file: string, buf: number)
    # Before creating a directory, make sure that the current buffer:{{{
    #
    #    - is not a special one    `:h special-buffers`
    #    - is not a remote file    ftp://...
    #
    # Found here: http://stackoverflow.com/a/4294176
    #}}}
    if !getbufvar(buf, '&buftype')->empty() || file =~ '^\w\+:/'
        return
    endif
    var dir: string = fnamemodify(file, ':h')
    # if the directory already exists, nothing needs to be done
    if isdirectory(dir)
        return
    endif
    try
        mkdir(dir, 'p')
    catch /^Vim\%((\a\+)\)\=:E739:/
        # If the directory is in a root directory, `mkdir()` will fail.
        # We need to run `$ sudo mkdir`.
        var pass: string = inputsecret('[sudo] password for ' .. $USER .. ': ')
        sil system('sudo -S mkdir ' .. dir, pass .. "\n")
        #                 │{{{
        #                 └ read the password from the standard input
        #                   instead of using the terminal device.
        #                   The password must be followed by a newline character.
        #}}}
        # Write the file  as root, so that the next  `:update` (executed when we
        # press `C-s`) does not fail.
        exe 'w !sudo tee >/dev/null ' .. shellescape(file, true)
        setl nomod
    endtry
enddef

augroup MakeMissingDir | au!
    au BufWritePre * expand('<afile>:p')->MakeMissingDir(expand('<abuf>')->str2nr())
augroup END

# Default Extension {{{2

# Temporarily commented, because I find it annoying now with `.vim`.
# Keep it, because it could still be useful for other extensions.

#     augroup DefaultExtension | au!
#         au BufNewFile * ++nested expand('<afile>:p')->DefaultExtension()
#     augroup END
#
#     def DefaultExtension(fname: string)
#         # If the buffer name ends with a dot, it's probably a mistake.
#         # We don't want to add a default extension.
#         # We  would  end  up  with  a  buffer whose  name  contains  a  sequence  of
#         # consecutive dots.
#         if fname[-1] == '.'
#             return
#         endif
#
#         # If the buffer is created inside `/tmp` and has no extension
#         if fnamemodify(fname, ':p:h')[: 3] == '/tmp' && fnamemodify(fname, ':e')->empty()
#             # ... make  sure it  will be  wiped when it's  hidden which  will happen
#             # after the next command
#             setlocal bufhidden=wipe
#
#             # edit a new buffer with the same name + the `.vim` extension
#             exe 'keepalt edit ' .. fnameescape(fname) .. '.vim'
#
#             # If  the  previous  command  fails,  with or  without  error,  we  want
#             # `'bufhidden'` to be reset to its default value.
#             set bufhidden<
#         endif
#     enddef

# Delete Noname Buffers {{{2

# We want to automatically delete buffers which are empty and don't have a name.

var noname_buffers: list<number>

augroup WipeNonameBuffers | au!
    # Do *not* try to wipe the noname buffer right away!{{{
    #
    # We tried in the past, but it conflicted with other plugins in subtle ways,
    # creating  hard-to-debug issues.   We also  tried to  delay until  the next
    # `BufEnter`, which fixed some issues, like this one:
    #
    #     $ vim -Nu NONE +'set hidden | au BufHidden * exe "bw! " .. expand("<abuf>")->str2nr()'
    #     :new
    #     :q
    #     Error detected while processing BufHidden Autocommands for "*":~
    #     E937: Attempt to delete a buffer that is in use: [NULL]~
    #
    # but not all  issues can be fixed  like that.  In particular,  we still had
    # this issue:
    #
    #     $ vim +h +q +'call feedkeys("\<space>U")'
    #     Error detected while processing function window#unclose#restore:~
    #     line   20:~
    #     E16: Invalid range: 2wincmd w~
    #
    # So now, instead, we just register the buffer number in a list, and we wipe
    # all buffers in that list on  the next `CursorHold`.  It's good enough.  We
    # don't need to wipe a noname buffer *immediately*.
    #}}}
    au BufHidden * RegisterNonameForWiping()
    au CursorHold * WipeNoname()
augroup END

def RegisterNonameForWiping()
    var buf: number = expand('<abuf>')->str2nr()
    if buflisted(buf) && bufname(buf)->empty()
        add(noname_buffers, buf)
    endif
enddef

def WipeNoname()
    for buf in noname_buffers
        if buflisted(buf) && bufname(buf)->empty()
            # we might have redisplayed the buffer in a window; don't wipe it then
            if win_findbuf(buf)->empty()
                sil! exe 'bw! ' .. buf
            endif
        else
            filter(noname_buffers, (_, v: number): bool => v != buf)
        endif
    endfor
enddef

# Filetype Linter {{{2

# TODO:
# Instead of using a match, automatically populate the qfl, and place signs.
# https://gist.github.com/BoltsJ/5942ecac7f0b0e9811749ef6e19d2176

# Purpose: get a warning when we make a typo in a filetype detection script {{{
#
# We often write something like this:
#
#     set sh
#
# Instead of:
#
#     set ft=sh
#}}}
augroup FiletypeLinter | au!
    au VimEnter,WinEnter filetype.vim,*/ftdetect/*.vim FiletypeLinter('enable')
    au BufWinLeave filetype.vim,*/ftdetect/*.vim FiletypeLinter('disable')
augroup END

def FiletypeLinter(action: string)
    if exists('w:my_filetype_linter')
        sil! matchdelete(w:my_filetype_linter)
        unlet! w:my_filetype_linter
    endif
    if action == 'enable'
        var pat: string = '\m\C\%(^\%(\s*"\)\@!.*\)\@<=\mset\s\+\%(ft\|filetype\)\@!'
        w:my_filetype_linter = matchadd('ErrorMsg', pat, 0)
    endif
enddef

# Fire *Leave events on startup {{{2

# Purpose:{{{
#
# When Vim starts up, none of these events seem to be fired:
#
#    - `BufLeave`
#    - `BufWinLeave`
#    - `WinLeave`
#
# This may give unexpected results when Vim has just finished its startup.
#
# MWE:
#
#     $ vim -Nu NONE --cmd 'au BufWinEnter,WinEnter * setl stl=active' \
#       --cmd 'au BufWinLeave,WinLeave * setl stl=NOT\ active' \
#       -O /tmp/file{1..2}
#
# The status line in the right window displays `active`; I would expect it to display `inactive`.
#}}}
# https://github.com/vim/vim/issues/5243
augroup FireLeaveEventsOnStartup | au!
    au VimEnter * timer_start(0, () => FireLeaveEvents())
augroup END

def FireLeaveEvents()
    if match(v:argv, '\C^-[doO]$') >= 0
        var curwin: number = win_getid()
        windo #
        win_gotoid(curwin)
    endif
enddef

# Highlight ansi codes {{{2

augroup HighlightAnsi | au!
    # useful when we run sth like `$ trans word | vim -` or `$ trans word | vipe`
    # Why the guard?{{{
    #
    # When Vim is invoked  inside a Vim terminal, we run  some custom code which
    # quits  the nested  Vim instance,  and re-opens  the file(s)/buffer  in the
    # outer instance.
    #
    # But if `#ansi()` has removed the ansi escape codes when Vim was invoked in
    # the nested instance, then they will be absent in the outer one.
    # We don't want that, we need these escape codes for `#ansi()` to do its job
    # properly in the outer Vim instance.
    #}}}
    if empty($VIM_TERMINAL)
        au StdinReadPost * runtime macros/ansi.vim
        au VimEnter * if $_ =~ '\C/vipe$' | runtime macros/ansi.vim | endif
    endif
augroup END

# Include shell cwd in 'path' {{{2

augroup IncludeShellCwdInPath | au!
    # Rationale:{{{
    #
    # We want to be able to press `ZF` to  open a file path in a Vim split, when
    # the buffer has been populated with a shell command such as:
    #
    #     $ find -name '*.rs' | vipe
    #     $ find -name '*.rs' | vim -
    #}}}
    #   Wait.  Doesn't Vim look in the cwd by default?{{{
    #
    # Yes it does, regardless of the value of `'path'` (even if you empty it).
    # But we have an autocmd in `vim-cwd` which may change the cwd (to `~/.vim`).
    # So, to be sure `ZF` works all the time, we need to tell Vim – explicitly –
    # to look into the cwd of the parent shell.
    #}}}
    au VimEnter * if $_ =~ '\C/vipe$' | set path+=$PWD | endif
    au StdinReadPost * set path+=$PWD
augroup END

# Indent settings {{{2

augroup IndentSettings | au!
    # Vim test files are indented with 2 spaces (see their modelines)
    au BufReadPost */vim/src/testdir/*.vim setl sw=2
augroup END

# No syntax in diff mode {{{2

augroup NoSyntaxInDiffMode | au!
    # Why do you clear the syntax in a diff'ed buffer?{{{
    #
    # When  you're  comparing  the  differences between  two  files,  you're
    # interested in the text which has changed.
    # You're not interested in the semantics of the code.
    #
    # IOW, the syntax  adds visual clutter, which makes it  hard to focus on
    # what is really important.
    #}}}
    au OptionSet diff exe v:option_new == '1' ? 'syn clear' : 'do Syntax'
    # We need this when we start Vim in diff mode right from the shell.{{{
    #
    #     $ vimdiff file1 file2
    #
    # This is because the previous autocmd is not fired in that case.
    # Maybe because the option is set  before the autocmd is installed, or maybe
    # because `OptionSet` is not fired at startup.
    #}}}
    au VimEnter * IfDiffSynClear()
    :def IfDiffSynClear()
        if !&l:diff
            return
        endif
        getwininfo()
            ->mapnew((_, v: dict<any>) => win_execute(v.winid, 'syn clear'))
    enddef
augroup END

# Persistent clipboard {{{2

# Which issue is solved by this autocmd?{{{
#
# Start a terminal (not urxvt).
# Start Vim and copy some text in the clipboard (`""y...`).
# Quit Vim.
# Try to paste the clipboard in the terminal: it doesn't work.
#}}}
#   What's the cause of the issue?{{{
#
# A text copied in the clipboard is called a "selection".
#
# When you yank some  text in the clipboard selection, Vim  becomes the owner of
# the latter.
#
# Later, in the terminal, when you ask for the clipboard selection to be pasted,
# the terminal  sends a  request to  the X  server, and  asks for  the clipboard
# selection from whoever currently owns it.
# The X  server will then relay  this request to  the other X client,  here Vim,
# that owns the clipboard selection.
#
# Now, if you've quit Vim, then no one owns the clipboard selection anymore, and
# so the request of the terminal fails.
# The same is true for any other application, like the web browser.
# So,  if you've  yanked some  text in  the clipboard  from Vim,  then quit  the
# latter, you won't be able to paste it in Firefox.
#
# This is explained at `:h x11-selection`.
#
#    > ... selections  are "owned" by  an application, and disappear  when that
#    > application (e.g., Vim) exits, thus losing the data ...
#}}}
#     How do you fix it?{{{
#
# Before quitting Vim, we call `xsel(1x)`.
# We pass  it the contents  of Vim's clipboard, and  we make `xsel(1x)`  its new
# owner.  You  can check this  by yanking some  text in the  clipboard, quitting
# Vim, then running:
#
#     $ ps aux | grep xsel
#     user 1234 ... xsel -ib~
#
# The `xsel(1x)` process will  persist for as long as you  don't yank some other
# text in the clipboard.
# For example, if  you copy sth from Firefox, then  re-run the previous `ps(1)`,
# you won't find `xsel(1x)` anymore.
#}}}

#     Why doesn't it affect urxvt?{{{
#
# It *does* affect urxvt.
#
# But if you have this code in `~/.Xresources`:
#
#     URxvt.perl-ext-common: selection-to-clipboard,pasta
#     URxvt.keysym.Control-Shift-V: perl:pasta:paste
#
# And this code in `~/.urxvt/ext/pasta`:
#
#     #! /usr/bin/env perl -w
#     # Usage: put the following lines in your .Xdefaults/.Xresources:
#     # URxvt.perl-ext-common           : selection-to-clipboard,pasta
#     # URxvt.keysym.Control-Shift-V    : perl:pasta:paste
#
#     use strict;
#
#     sub on_user_command {
#       my ($self, $cmd) = @_;
#       if ($cmd eq "pasta:paste") {
#         $self->selection_request (urxvt::CurrentTime, 3);
#       }
#       ()
#     }
#
# Then, the issue is partially mitigated.
# That is, you  can paste the clipboard  in an urxvt terminal  even after quitting
# the Vim instance from which you copied it, but you still can't paste it anywhere
# else.
#
# BTW, I can't  find the perl script at  the address given in the  file, but you
# can still find it here:
# https://wiki.gentoo.org/wiki/Rxvt-unicode#Copy.2FPaste_and_URL_handling
#}}}
#     Does it affect all applications?{{{
#
# No, for example, zathura is not affected.
# I don't know why.  Maybe it gives  the ownership of its clipboard selection to
# another program before quitting...
#
# OTOH, the issue does affect libreoffice.
#}}}

# Warning: If you change the name of the augroup, do the same in `tmux#capture_pane#main()`:{{{
#
#     ~/.vim/plugged/vim-tmux/autoload/tmux/capture_pane.vim
#}}}
augroup MakeClipboardPersistAfterQuittingVim | au!
    au VimLeave,VimSuspend * MakeClipboardPersistAfterQuittingVim()
augroup END

def MakeClipboardPersistAfterQuittingVim()
    # Why the `strlen()` guard?{{{
    #
    # If the clipboard selection is too big, we don't want Vim to be slow when we quit.
    # If you find the current limit too low, you may increase it, after doing some tests:
    #
    #     :let @+ = repeat('a', 999999)
    #     :10Time call system('xsel -ib', @+)
    #}}}
    if !executable('xsel') || strlen(@+) == 0 || strlen(@+) > 9999
        return
    endif
    # Why do you pass the text via the second argument of `system()`?{{{
    #
    # There are two other alternatives.
    #
    # You could write the clipboard in a temporary file:
    #
    #     var tempfile: string = tempname()
    #     split(@+, '\n')->writefile(tempfile, 'b')
    #     system('xsel -ib ' .. tempfile)
    #
    # But it would be cumbersome, and maybe brittle.
    # What if for some reason the file is removed before `xsel(1x)` has a chance
    # to read it, or it does not have the right permissions (`writefile()` can't
    # write into it, `xsel(1x)` can't read it)?
    #
    # ---
    #
    # Or, you could use a pipe:
    #
    #     system('printf -- ' .. shellescape(@+) .. ' | xsel -ib')
    #
    # But note that we already have 3 pitfalls to avoid.
    # We  don't want  a trailing  newline  to be  appended,  so we  have to  use
    # `printf` instead of `echo` (you could use `echo -n`, but in general `echo`
    # is not reliable).
    #
    # We don't the  beginning of the text  to be interpreted as an  option if it
    # begins with a hyphen, so we need `--`.
    #
    # We  don't want special  characters to be interpreted  by the shell,  so we
    # need `shellescape()`.
    # But even with all those precautions, it would still not be reliable.
    # For example, in Vim, try to copy this text in the clipboard:
    #
    #     +some str%nge|name'with"quotes!bang$dollar
    #
    # Then quit Vim, and paste it in the terminal:
    #
    #     +some strge|name'with"quotes!bang$dollar~
    #              ^
    #              ✘ where is `%n`?
    #}}}
    # TODO: Doesn't work in the GUI.
    sil system('xsel -ib', @+)
enddef

# Read special files {{{2

# The following autocmd lets us read special files like a pdf or an odt.
# They use a few shell utilities as filter:
#
#    - antiword
#    - odt2txt
#    - pandoc
#    - pdftotext
#    - unrtf

augroup FilterSpecialFile | au!
    # Why not use `BufReadPost`?{{{
    #
    # It would indeed be more appropriate than `BufWinEnter`.
    # But  for some  reason,  Vim doesn't  fire `BufReadPost`  when  it reads  a
    # `.docx` or `.epub` file.
    #
    #     au BufReadPost *.docx  sil %!pandoc -f docx -t markdown <afile>:p:S
    #        ^
    #        ✘
    #
    # We could use `FileType tar`:
    #
    #     au FileType tar sil %!pandoc -f docx -t markdown <afile>:p:S
    #
    # ...  but  `$VIMRUNTIME/plugin/tarPlugin.vim`  would leave  some  undesired
    # messages inside the buffer; it's noise.
    # Maybe it's because the event is fired too early, and the built-in tar plugin
    # processes the buffer after the event.
    #}}}
    au BufWinEnter *.{doc,docx,epub,odp,odt,pdf,rtf} FilterSpecialFile()
augroup END

def FilterSpecialFile()
    # TODO: We once had a huge pdf undo file in `~/.vim/tmp/undo`.
    # Should we reset some options like `'undofile'` and `'swapfile'`?
    if get(b:, 'did_filter_special_file', 0)
        return
    endif

    var fname: string = expand('<afile>:p:S')
    var ext: string = expand('<afile>:e')
    var ext2cmd: dict<string> = {
        doc: '%!antiword ' .. fname,
        docx: '%!pandoc -f docx -t markdown ' .. fname,
        epub: '%!pandoc -f epub -t markdown ' .. fname,
        odp: '%!odt2txt ' .. fname,
        odt: '%!odt2txt ' .. fname,
        pdf: '%!pdftotext -nopgbrk -layout -q -eol unix ' .. fname .. ' -',
        rtf: '%!unrtf --text',
        }

    if has_key(ext2cmd, ext)
        var filter: string = matchstr(ext2cmd[ext], '%!\zs\S*')
        if !executable(filter)
            echom 'cannot filter ' .. expand('<afile>:p') .. '; please install ' .. filter
            return
        endif

        setl modifiable noreadonly
        # About: '%!pdftotext -nopgbrk -layout -q -eol unix ' .. fname .. ' -'{{{
        #                                                                   │
        #                                                                   └ write output on STDOUT,
        #                                                                     which is piped to `par(1)`
        #}}}
        # FIXME: Initially, we used the shell utility `fmt`:{{{
        #
        #     '%!pdftotext -nopgbrk -layout -q -eol unix ' .. fname .. ' - | fmt -w78'
        #
        # The formatting was awful (too much random spacing everywhere).
        # `par(1)` gives a more readable text:
        #
        #     '%!pdftotext -nopgbrk -layout -q -eol unix ' .. fname .. ' - | par -w80rjeq'
        #
        # However, there are still errors.
        # Look at the bottom of a `pdf` file filtered by `par(1)`, to find error
        # messages.  It's  often due to a  too long “word” (more  precisely what
        # `par(1)`  considers  a  word).   Because  of  this,  a  pdf  is  often
        # truncated.  So, we don't use it atm.
        #
        # Try to fix these errors by  learning how to better configure `par(1)`,
        # through  command-line options,  and/or through  `$PARINIT`.  Then  use
        # `par(1)` to format a pdf.
        #}}}
        exe 'sil :' .. ext2cmd[ext]
        b:did_filter_special_file = 1
        setl buftype=nofile nomodifiable noswapfile readonly
    endif
enddef

# Regenerate helptags {{{2

augroup RegenerateHelptags | au!
    au BufWritePost ~/.vim/plugged/*/doc/*.txt exe 'helptags ' .. expand('<afile>:p:h')
augroup END

# Reload config {{{2

augroup SourceFiles | au!
    # Why no `-merge`?{{{
    #
    # If you pass the `-merge` option to `xrdb`, the background color you choose
    # for urxvt won't be applied in xterm, because of this existing resource:
    #
    #         *customization: -color
    #
    # See `xrdb -query` to get a list of all existing resources.
    #}}}
    au BufWritePost ~/.Xresources sil system('xrdb ~/.Xresources')

    # Do *not* resource the vimrc automatically.  It creates too many issues.{{{
    #
    # First, you will need to make sure that – out of all the autocmds listening
    # to `BufWritePost` – the one resourcing the vimrc is always the last one.
    #
    # Otherwise, if the pattern is `$MYVIMRC`,  it won't work, probably because when
    # the vimrc is re-sourced, the augroup it cleared.
    # Yes, the autocmd is re-installed, but it's  a new one, which won't take effect
    # immediately for the current `BufWritePost` event.
    # It will be executed only for the next `BufWritePost`.
    # At that point, the issue will repeat.
    #
    # MWE:
    #
    #     $ cat /tmp/vim.vim
    #         augroup TestSth | au!
    #             au BufWritePost /tmp/vim.vim exe 'so ' .. expand('<afile>:p')
    #             au BufWritePost * let g:d_ebug = get(g:, 'd_ebug', 0) + 1
    #         augroup END
    #
    #     $ vim -Nu /tmp/vim.vim /tmp/vim.vim
    #     :w
    #     :echo d_ebug
    #     ✘ E121~
    #
    # The issue disappears if you change the order of the autocmds.
    #
    # ---
    #
    # Second, after some time (after visiting  or writing many buffers), Vim may
    # be  slow  whenever  you  write  the  vimrc.   As  a  workaround,  you  can
    # *temporarily* disable the autocmd; but that's cumbersome to do every time.
    #
    # ---
    #
    # Finally, you'll need  to write a bunch of  `has('vim_starting')` guards in
    # various places to avoid issues which are hard to understand.
    #
    # This shows  that the vimrc  is not really  meant to be  re-sourced; forget
    # about it; it's not  worth it, especially now that you  can restart Vim and
    # not lose your session thanks to `vim-session`.
    #}}}
    # Same thing for `myfuncs.vim`.{{{
    #
    # For example, once  we had an issue where a  regular buffer was wrongly
    # transformed into a qf  buffer: https://github.com/vim/vim/issues/7352
    #}}}
augroup END

# Restrict Abbreviations {{{2

# Purpose:{{{
#
# An abbreviation may sometimes be unexpectedly expanded at the end of a word:
#
#     $ vim -Nu NONE -S <(cat <<'EOF'
#         set bs=start
#         inorea ab cd
#         pu!='yyyy'
#         norm! 3|
#         call feedkeys("i\<c-u>xxab ", 't')
#     EOF
#     )
#
# The buffer contains the line:
#
#     xxcd yy
#
# Notice how `ab`  has been expanded into  `cd`, even though `ab` was  part of a
# bigger word `xxab`.
#
# Not sure what's the rationale behind this behavior but it's documented at
# `:h abbreviations /rule`:
#
#    > full-id   In front of the match is a non-keyword character, **or this is where**
#    >           **the line or insertion starts.**
#
# In any case, we never want this,and when that happens we have to roll back the
# expansion which is distracting.  Let's try to disable it.
#}}}
augroup RestrictAbbreviations | au!
    au InsertEnter * start_insertion = {lnum: line('.'), col: col('.')}
    au InsertCharPre * RestrictAbbreviations()
augroup END
var start_insertion: dict<number>

def RestrictAbbreviations()
    # Purpose:{{{
    #
    # Suppress  a  possible abbreviation  expansion  by  preceding a  triggering
    # non-keyword (typically a space) with `C-v`.
    #
    # MWE:
    #
    #     $ vim -Nu NONE -S <(cat <<'EOF'
    #         set bs=start
    #         inorea ab cd
    #         pu!='yyyy'
    #         norm! 3|
    #         call feedkeys("i\<c-u>xxab ", 't')
    #     EOF
    #     )
    #
    # The buffer contains the line:
    #
    #     xxcd yy
    #
    # Notice how `ab` has been expanded into `cd`.
    #}}}

    # Why the `- 1` in `start_insertion.col - 1`?{{{
    #
    # To handle  the case where  we enter insert mode  right after a  space, and
    # type an abbreviation immediately.
    #}}}
    var curlnum: number = line('.')
    # if  the  inserted  char  is  a  keyword  character,  there  can't  be  any
    # abbreviation expansion; no need to do anything
    if v:char =~ '\k'
        # there must be a non-keyword between the cursor and the point where we entered insert mode
        # if not, bail out
        || start_insertion.col - 1 <= searchpos('[^[:keyword:]]', 'bn', curlnum)[1]
        # we should be still on the same line where we entered insert mode
        || curlnum != start_insertion.lnum
        # we probably don't need this to be run when keys are pressed from the rhs of a mapping;
        # the less frequently we run this code, the lower the risk we encounter some unexpected side-effect
        || state() =~ 'm'
        return
    endif
    # Do *not* pass the `i` flag to `feedkeys()`!{{{
    #
    # If you do, the keys returned by an insert mode mapping whose rhs evaluates
    # an expression would be reversed:
    #
    #     $ vim -Nu NONE -S <(cat <<'EOF'
    #         au InsertCharPre * call feedkeys("\<c-v>" .. v:char, 'i') | let v:char = ''
    #         ino X <c-r>='abc'<cr>
    #         call feedkeys('iX')
    #     EOF
    #     )
    #
    #     " resulting buffer:  cba
    #     " expected buffer:   abc
    #
    # ---
    #
    # This issue should be avoided thanks to the previous `state()` guard, but still...
    #}}}
    feedkeys("\<c-v>" .. v:char)
    v:char = ''
enddef

# Send to server {{{2

# Install a  mapping to  send the  current Vim buffer/file  to a  remote running
# server.   This is  useful –  in particular  – to  send the  output of  a shell
# command to our main Vim instance.
nno ]<c-s> <cmd>call myfuncs#sendToServer()<cr>

# Standard Input {{{2

augroup MyStdin | au!
    au StdInReadPost * if (line('$') + 1)->line2byte() <= 2 | cquit | endif
augroup END

# Spell files {{{2

# When spell checking is enabled, and we mark  a word as good or bad, we make an
# addition into `~/.vim/spell/fr.utf-8.`.
# But,  for  Vim to  take  this  addition into  account,  it  has to  perform  a
# successful check on the corresponding binary file `fr.utf-8.add.spl`.
#
# Versioning  those binary  files with  git  could cause  pb (conflicts  between
# different versions).

# When  we switch  to  another  machine, we  should  regenerates  them with  the
# `:mkspell!` command.
# The bang asks to overwrite an old binary if there's already one.
# So  we do  it  here, for  every  spell binary  file, but  only  if the  binary
# (.add.spl) is older than the original addition file (.add).

augroup MyMkspell | au!
    # Why `mapnew()`?{{{
    #
    # Because there can  be several spell files (one per  language), in which we
    # made additions.
    #
    # http://vi.stackexchange.com/a/5052/6960
    #}}}
    au VimEnter * glob($HOME .. '/.vim/spell/*.add', true, true)
        \ ->mapnew((_, v: string) => filereadable(v)
        \     && !filereadable(v .. '.spl') || (getftime(v) > getftime(v .. '.spl'))
        \     && !!execute('mkspell! ' .. fnameescape(v)))
augroup END

# Swap file handling "{{{2

# What does this autocmd do?{{{
#
# It answers automatically to the question asked when a swap file is found.
# If the swap file is older than the file, it's removed because useless, and the
# file is editd as if nothing happened.
#
# If the swap  file is newer, the file  is opened in readonly mode,  so that you
# can see its contents, but not change it (without being warned).
#}}}
# Which pitfall does it fix?{{{
#
#     $ vim /tmp/file
#     $ vim (a 2nd instance)
#     :try | e /tmp/file | catch | endtry
#
# If the  file is already  loaded in another instance,  it will raise  the error
# `E325` ("Attention: Found a swap file ...").
#
# But the error won't  be catched because Vim prompts us  with a question to
# know what we want to do (edit, quit, ...).
# Worse, the question is not visible.
#
# This can happen when  a plugin tries to edit a file  with a `try` conditional,
# and Vim finds out that a swap file exists.
#}}}
# Why don't you use `set shm+=A`?{{{
#
# `set shm+=A` would completely bypass the question, and the existence of a swap
# file would never be brought to our attention.
#
# In contrast, this  autocmd will still warn  us whenever a swap  file is found,
# and write the  warning in the messages, so  that we can review it  later if we
# need to debug some unexpected behavior from Vim.
#
# Besides, it won't let us edit a file for which a newer swap file exists.
# There could be valuable information in there.
#}}}

# A swap file has been found, and the file has been loaded in readonly mode!  What should I do?{{{
#
# If you only need to read the file, nothing.  Just read it.
#
# If you need to edit the file, you have an issue.
# Indeed, if  the autocmd hasn't  removed the swap file,  it means the  latter is
# more recent than the file (or has the same timestamp).
#
# So, it  could contain valuable information  that you need to  recover *before*
# doing  any further  change (because  this valuable  information may  radically
# alter the change you intend to do).
#}}}
# How do I recover the contents of a swap file?{{{
#
#     # recover swap file
#     $ vim -r file
#
#     " save the result in another file
#     :write file.recovered
#
#     " load the original (unrecovered) file in readonly mode
#     " (this works thanks to our autocmd which should answer the question)
#     :e!
#
#     " show the differences between the original file and its recovered version
#     :diffsp file.recovered
#
# We have encapsulated this procedure in a zsh function (`vim_recover()`).
#
# If the recovered file looks good, you still have to execute:
#
#     $ mv file.recovered file
#
# See `:h 11.1` for more info.
#}}}

augroup SwapfileHandling | au!
    au SwapExists * expand('<afile>:p')->HandleSwapfile()
augroup END

def HandleSwapfile(fname: string)
    # If the swap file is older than the file itself, just get rid of it.
    if getftime(v:swapname) < getftime(fname)
        Warn('Old swap file detected, and deleted:  ' .. fname)
        delete(v:swapname)
        v:swapchoice = 'e'
    else
        Warn('Swap file detected, opening read-only:  ' .. fname)
        v:swapchoice = 'o'
    endif
enddef

def Warn(msg: string)
    echohl WarningMsg
    # It seems that when `SwapExists` is fired, Vim executes `:echom` silently.
    unsilent echom msg
    echohl NONE
enddef

# Trailing Whitespace {{{2

# Trailing whitespace in red but not if the filetype is blacklisted:
var NO_TRAILING_WHITESPACE_FT: list<string> =<< trim END

    fzf
    git
    help
    qf
    text
END

augroup TrailingWhitespace | au!
    au VimEnter,WinEnter,BufWinEnter,InsertLeave * TrailingWhitespace(true)
    au InsertEnter * TrailingWhitespace(false)
    # We don't want a match in a preview window.{{{
    #
    # The match is useful to let us  know that we should probably remove useless
    # trailing whitespace.
    # However, a preview window is not opened to *edit* text, but to *read* text.
    # In this context, the match is just noise.
    #}}}
    au WinLeave * if &l:pvw | TrailingWhitespace(false) | endif
    # We don't want a match in a terminal buffer when we quit Terminal-Job mode.{{{
    #
    # In  Vim,  the match  is  installed  when  we  open a  terminal  window
    # (`WinEnter`).
    # After that, it's not removed, because  `InsertLeave` is not fired in a
    # terminal, so our autocmd which deletes the match is not triggered.
    #
    # ---
    #
    # You may wonder why the match is  installed in a Vim terminal buffer, since
    # its filetype  is empty, and  we check the  filetype is *not*  empty before
    # installing any match.
    # I think that's because when `WinEnter`  is fired, the filetype has not yet
    # been correctly set.
    #}}}
    au TerminalWinOpen * TrailingWhitespace(false)
    # Why `BufWinEnter`?{{{
    #
    #     :term
    #     " write /etc/hosts in the buffer
    #     " press:  C-\ C-n
    #               gf
    #               i Esc
    #               C-^
    #
    # Without `BufWinEnter`, trailing whitespace is highlighted.
    #
    # ---
    #
    # BTW, `BufWinEnter`  can't replace `TerminalWinOpen`;  probably because
    # `'buftype'` has not been set when  the first `BufWinEnter` is fired in
    # a terminal buffer.
    #}}}
    au BufWinEnter * if &bt == 'terminal' | TrailingWhitespace(false) | endif

    # Why do you delay the call to `TrailingWhitespace()`?{{{
    #
    # When `UltiSnipsExitLastSnippet` is  fired, `g:expanding_snippet` may still
    # exist (it probably depends on the order of our custom autocmds).
    # In that case, the match won't be re-installed; we want it to be re-installed.
    #}}}
    # Why the `mode()` guard?{{{
    #
    #    1. Expand the `vimrc` snippet.
    #    2. Press Tab repeatedly to traverse all the tabstops.
    #    3. Insert `fu`.
    #
    # The `fu` snippet is automatically expanded (✔); the trailing whitespace is highlighted (✘).
    #}}}
    au User UltiSnipsExitLastSnippet au SafeState * ++once
        \ if mode() == 'n' | TrailingWhitespace(true) | endif

    # An undesirable match will be installed in a help buffer, even with `help` in `NO_TRAILING_WHITESPACE_FT`.{{{
    #
    # Execute `:h :as` twice, and you'll see it.
    # This is because when `WinEnter` is fired, `&filetype` has not been correctly set yet.
    #
    # So, we must make sure to remove this match with an additional autocmd.
    #
    # ---
    #
    # You may wonder why we don't listen to `Filetype help`:
    #
    #     au FileType help TrailingWhitespace(0)
    #
    # It's not always fired.
    #
    # MWE:
    #
    #     $ vim +'LogEvents filetype'
    #     :h :as
    #     :q
    #     :h :as
    #
    # Note that if you reset `'hidden'`, `FileType` is always fired.
    # This is because when  you close the help window, the  help buffer can't be
    # hidden (`BufHidden`), and Vim has to unload it (`BufUnload`).
    # As a result, the next time you ask to see the same help file, Vim has to read
    # the file again, which triggers `BufReadPre`, `FileType` and `BufReadPost`.
    #}}}
    au BufWinEnter {$VIMRUNTIME,$HOME/.vim,$HOME/.vim/*}/doc/*.txt TrailingWhitespace(false)
    # Same issue when we split a window to read a text file:{{{
    #
    #     :e /tmp/vim.vim
    #     :sp /tmp/txt.txt
    #     " when `WinEnter` is fired, the filetype is still 'vim', not 'text'
    #
    # In particular, we don't want a match after running `:VimPatches 8.1`; it's
    # noise.  More  generally, trailing whitespace  in a text file  is harmless,
    # because it's not code; so we don't care about its presence.
    #}}}
    exe 'au FileType '
        .. copy(NO_TRAILING_WHITESPACE_FT)
            ->filter((_, v: string): bool => v != '')
            ->join(',')
        .. ' TrailingWhitespace(false)'
    # we still have an undesired match when we run `:VimPatches 8.1` *twice*
    au BufWinEnter * if &ft == 'text' | TrailingWhitespace(false) | endif
augroup END

def TrailingWhitespace(create_match: bool)
    if exists('g:expanding_snippet')
        return
    endif
    if !create_match && exists('w:my_trailing_whitespace')
        # `sil!` because the match might not exist anymore.
        # For example, a plugin could have executed `clearmatches()`.
        sil! matchdelete(w:my_trailing_whitespace)
        unlet! w:my_trailing_whitespace
    elseif create_match
        && !exists('w:my_trailing_whitespace')
        && index(NO_TRAILING_WHITESPACE_FT, &filetype) == -1
        && &bt == ''
        # Why the `&bt == ''` guard?{{{
        #
        #     $ vim +term
        #     " run `$ ls` in the terminal buffer
        #     " press `gf` on a file path to open a regular file in the window
        #     " press `C-w w` twice to focus the other split window and get back
        #     " press `C-^` to load back the terminal buffer
        #
        # Trailing whitespace is highlighted.
        #
        # ---
        #
        # Don't try to move the guard earlier:
        #
        #     if &bt != ''
        #         return
        #     endif
        #
        # It wouldn't  work; probably because  the match is installed  no matter
        # what, and needs to be removed.
        #}}}
        w:my_trailing_whitespace = matchadd('Error', '\s\+$', 0)
    endif
enddef
# }}}1
# To_Do {{{1

#     *s/^\%V#\s\=\zs\d\+\ze\s*-/\=submatch(0) - 1/c
#
# 1 - Vimcast, Episode 50, An introduction to vspec
#
# https://github.com/junegunn/vader.vim (927 sloc)
#
# http://whileimautomaton.net/2013/02/13211500
# https://github.com/kana/vim-vspec
# https://github.com/kana/vim-flavor
# http://www.relishapp.com/kana/vim-flavor/docs
#
# https://github.com/dhruvasagar/vim-testify
#
# 2 - Implement the concept of "narrowing region".
#
# A mapping, or command which would copy a range of lines in a temporary buffer.
# We could edit this temp buffer, and after writing it, the original selection
# would be replaced by it.
# There's a plugin for that:
#
# https://github.com/chrisbra/NrrwRgn
#
# ... but the source code is too long (1500 sloc).
# Take inspiration from it.
#
# 3 - Implement ]n, ]s, ]u, ]x, ]y from unimpaired.vim
#
# 4 - tmux navigation
# La navigation entre les panes de tmux et les viewports de Vim n'est pas
# cohérente.
# Pour aller dans un pane tmux depuis Vim, on peut taper C-{hjkl}.
# Mais en sens inverse (tmux → Vim), il faut passer par le préfixe tmux, `pfx + hjkl`.
# On a fait ça pour ne pas perdre les raccourcis readline dans le shell.
# On devrait peut être associer un  key code modificateur (Hyper?) sur la touche
# Super  (ou la  touche  ctrl gauche?),  et  se servir  de  cette dernière  pour
# naviguer entre tmux et Vim: Super + {hjkl}.
#
# Plus généralement, revoir tout le code tmuxnavigator et repenser la
# navigation.
# Trop d'incohérences.
# Navigation entre onglets  Vim, viewports Vim, panes tmux,  fenêtres tmux, tmux
# <-> Vim ...
# C'est un gros bordel:
#
#     AltGr-hl, C-hjkl, pfx-hjkl, M-hl
#
# Autre Idée:
#
#     C-hjkl             pour naviguer entre viewports et onglets  Vim.  (facile?)
#     Left Right Down Up "                   panes     et fenêtres tmux. (difficile?)
#
# For the tmux part, we would need to define conditional mappings.
# Maybe draw inspiration from here:
# http://stackoverflow.com/a/12380693
#
# Autres liens intéressants:
# https://sunaku.github.io/tmux-select-pane.html
# https://github.com/sunaku/tmux-navigate
# https://silly-bytes.blogspot.fr/2016/06/seamlessly-vim-tmux-windowmanager_24.html
# https://github.com/urbainvaes/vim-tmux-pilot
#
# 5 -
#
# https://github.com/hunspell/mythes
# https://hunspell.github.io/
# http://icon.shef.ac.uk/moby/mthes.html
#
# Lire le code de:
#
# https://github.com/beloglazov/vim-online-thesaurus/
#
# Ajoute ça dans le vimrc:
#
#     plug 'beloglazov/vim-online-thesaurus'
#     let g:online_thesaurus_map_keys = 0
#
# Très court (144 sloc).
# Comme le plugin est court, on pourrait peut-être l'adapter pour le support
# du français.
# Chercher un site équivalent à thesaurus.com pour le français.
# Ou chercher une bdd de synonymes, et écrire un algo qui l'analyse:
#
# http://www.dicollecte.org/download.php?prj=fr
#
# On pourrait aussi s'inspirer de la méthode du plugin pour ouvrir un split de
# taille dynamique, adapté à la taille des données à afficher.
#
# Jeter un oeil aux liens suivants :
#
# https://hyperdic.net/en/doc/antonyms
# (trouvé en cherchant "where can i download antonym file" page 3)
# https://github.com/emugel/vim-thesaurus-files
#
# character-wise visual mode word lookup
# https://github.com/beloglazov/vim-online-thesaurus/pull/31
#
# Créer une méthode mucomplete qui s'en sert.
#
# 6 -
#
# Why `:FzRg!` + `foobar` (in interactive mode) gives much more results than
# `:FzRg! foobar`?
# More generally, I don't know how `:Rg` and `rg(1)` interpret metacharacters.
# Make some tests, read doc.
# Example: compare `:FzRg! foo.*bar` and `:FzRg!` + `foo.*bar`
#
# I think `:FzRg! pattern` does not fuzzy search pattern, it performs
# a standard search (not fuzzy).
# OTOH, `:FzRg!` + `pattern` performs a live fuzzy search.
#
# 7 -
#
# Extract big chunks of code from `myfuncs.vim` into separate plugins.
#
# 8 -
#
# Read and integrate `:h slow-start` in our notes.
#
# Update: Could we remove `!` from `'vi'`?
# If so,  maybe it  would make Vim  start faster;  it would not  have to  load a
# possibly big dictionary saved in a global variable.
#
# 9 -
#
# Integrate `~/wiki/diff.md` into `~/wiki/vim/vim.md`.
# Or into `~/wiki/admin.md`.
# Yeah... maybe everything which is related to diff or vimdiff, put it inside
# admin.
#
# 10 -
#
# In a temporary directory, execute these shell commands:
#
#     touch file{1..3}; mkdir -p foo/{bar,baz}/{qux,norf}
#     tree -a | vipe
#
# Look at  the diagram.   Implement a  mapping / command  which would  expand an
# abbreviation into this kind of diagram.
# For  the abbreviation,  we  could  take inspiration  from  the shell  commands
# themselves.  Or sth else?
#
# A simple way of doing this would be to call just the `tree` command:
#
#     r !touch file{1..3}; mkdir -p foo/{bar,baz/qux}/{norf,abc}; tree -a
#
#     during the shell expansion `bar` and `baz/qux` are appended to `foo`
#     and `norf` and `abc` are appended to `foo/bar` and `foo/baz/qux`
#     so we end up with 4 (2 * 2) leaf directories + 4 intermediate directories
#     (foo, bar, baz, qux)
#
# But we would have to create a temporary directory, and temporarily `cd` to it
# to avoid polluting the current working directory.
# Besides, we would have to protect all kind of special characters which could
# be present in the text we want to insert in the diagram.
#
# However, mkdir seems limited to produce a complex hierarchy.
# A better way would be to look at the syntax used by emmet to expand html
# tags.  Our mapping/command would parse a similar command to produce
# a hierarchy of items of an arbitrary complexity.
#
# Also, have a look at the diagram in `:h syntax-loading`.  Very interesting.
# Without this diagram, the explanations would be much more verbose, and less
# readable.  Implement a visual mapping, which would automatically draw the
# right diagram in front of the lines inside the selection (drawing `+`, `-`, `|`).
#
#     ~/Desktop/diagram
#
# Also, install mappings to draw vertical diagrams instead of horizontal ones.
# Have a look at our notes about the `try` conditional for an example where it
# would be useful.
#
# Try this:
#
#     $ sudo aptitude install libgraph-easy-perl
#
# Write this in a file:
#
#     digraph {
#         start -> adsuck;
#         adsuck -> block;
#         block -> noop[label="yes"];
#         block -> unbound[label="no"];
#         noop -> serve_noop[label="yes"];
#         noop -> serve_empty[label="no"];
#     }
#
# Visually select it, and type:
#
#     :'<,'>!graph-easy --as ascii
#                                  ^
#                                  don't add `%`
#                                  it would work, but if you have several digraph codes
#                                  in the current file, they will all be expanded, even
#                                  if you only select one in particular
#
# Interesting links:
# https://vi.stackexchange.com/a/541/13370
# http://melp.nl/2013/08/flow-charts-in-code-enter-graphviz-and-the-dot-language/
# https://github.com/wannesm/wmgraphviz.vim
# `man graph-easy`
#
# Update:
# This is really useful with vim-movesel, and vim-draw.
# You create  the skeleton of  the diagram with  graph-easy, then tweak  it with
# vim-movesel + vim-draw.
#
# Also, remember we've created the  `:BoxPrettify` command.  Useful to convert a
# raw ascii diagram, in a more polished one.
#
# Update: This utility could be very useful: https://github.com/jez/as-tree
#
# 11 -
#
# Look  for mappings  which would  benefit from  being made  dot/semicolon/comma
# repeatable.
#
# 12 -
#
# Document the fact that the tmux buffers are especially useful when you work in
# a vim which wasn't compiled with the clipboard support (no `+` register).
#
# Think docker ultisnips:
#
# https://github.com/sirver/ultisnips/blob/master/contributing.md#running-using-docker
# https://github.com/sirver/ultisnips/blob/master/contributing.md#reproducing-bugs
#
# 13 -
#
# Protect all temporary change of option with `try|catch|endtry`.
# Look for the pattern:
#
#     _save\|save_\|old_\|_old
#
# Do it in vimrc, myfuncs, plugins.
#
# For the replacement, use this construct:
#
#     preparations (like saving options)
#     try
#         do sth which can fail
#
#     catch
#         return Catch()
#
#     finally
#         mandatory conclusion (like restoring options)
#     endtry
#
# 14 -
#
# Create a mapping to populate command-line with `:ltag /`, then open the
# location window.  Ex:
#
      nno <expr> <c-g>t <sid>Ltag()
      def Ltag(): string
          augroup MyLtag | au!
              au CmdlineLeave : execute(['au! MyLtag', 'aug! MyLtag'], 'silent!')
          augroup END
          return ':ltag / | lw' .. repeat("\<left>", 5)
      enddef
#
# We need to execute `:lw` manually, because `QuickFixCmdPost` is not fired.
# Vim bug: https://github.com/vim/vim/pull/3001
#
# Update:
# It should probably be implemented as a cycle in `vim-cmdline`.
#
# Also:
# Play with `:tj / c-d`.
#
# It seems that `<space>ft` (fzf.vim) is identical to `:tj /`.
#
# 15 -
#
# Shell function to grep a pattern and populate the qfl.
# This one doesn't send the results to a vim server, and allows to pass
# arbitrary flags to grep.
# https://www.reddit.com/r/vim/comments/6oj6gg/what_are_some_lesser_know_tips_and_tricks_in_vim/dki09wt/
# https://www.reddit.com/r/vim/comments/6oj6gg/what_are_some_lesser_know_tips_and_tricks_in_vim/dkiw87v/
#
# Difference compared to our `nv()` shell function?
#
# 16 -
#
# Read `:h cscope` (useful to list tags in qfl?)
# https://www.reddit.com/r/vim/comments/6p6uch/how_to_refactor_by_tags/dkn30bd/
#
# 17 -
#
# Use `:[c|l]bottom` in your jobs plugins (if they populate a qfl asynchronously)
#
# 18 -
#
# Re-implement these mappings to open the file you're editing on github.
# It could be handy when you want to see a commit you've just pushed.
#
#     nno <space>og V<cmd>call <sid>OpenCurrentFileInGithub()<cr>
#     xno <space>og <c-\><c-n><cmd>call <sid>OpenCurrentFileInGithub()<cr>
#
#     def OpenCurrentFileInGithub()
#         var file_dir: string = expand('%:h')
#         sil var git_root: string = system(
#             'cd ' .. file_dir .. '; git rev-parse --show-toplevel | tr -d "\n"'
#             )
#         var file_path: string = expand('%:p')->substitute(git_root .. '/', '', '')
#         sil var branch: string = system('git symbolic-ref --short -q HEAD | tr -d "\n"')
#         sil var git_remote: string = system(
#             'cd ' .. file_dir .. '; git remote get-url origin'
#             )
#         var repo_path: string = matchlist(git_remote, ':\(.*\)\.')[1]->matchstr('github\.com/\zs.*')
#         var url: string = 'https://github.com/' .. repo_path .. '/blob/' .. branch .. '/' .. file_path
#         var first_line: number = getpos("'<")[1]
#         url ..= '#L' .. first_line
#         var last_line: number = getpos("'>")[1]
#         if last_line != first_line
#             url ..= '-L' .. last_line
#         endif
#         sil system('xdg-open ' .. url)
#     enddef
#
# Source:
# https://www.reddit.com/r/vim/comments/9r3rcd/open_current_file_in_github/
#
# Update:
# `:Gbrowse` does sth similar.
#
# 19 -
#
# Refactor all our functions which populate the qfl to offload work to a single
# function in `vim-qf`?
#
#     :vim /set\%(qf\|loc\)list/gj $MYVIMRC ~/.vim/**/*.vim ~/.vim/**/*.snippets ~/.vim/template/**
#
# 20 -
#
# Look for  functions containing  the keyword  `maybe` or  `later` (or  look for
# `aug\%[roup]!`).
# These functions probably execute code which must be delayed.
# Make sure they are not called by yet another function:
#
#     def Func()
#       ...
#       Func_later()
#       ...
#     enddef
#
# There is no need to:
#
#     def Func(later)
#       ...
#       if later
#           Func(0)
#       endif
#       ...
#     enddef
#
# 21 -
#
# https://github.com/chrisbra/vim_faq
# We've  stopped  reading  at  `faq-4.2`,  because we  need  time  to  integrate
# `:tselect` in our workflow.
# Indeed there are many similar commands:
#
#    - `g]`
#    - `:stselect`
#    - `:tselect`
#    - `:ptselect`
#
#    - `g C-]`
#    - `:tjump`
#    - `:stjump`
#    - `:ptjump`
#
# 22 -
#
# No  need  to  check  `if  &bt ==  'quickfix'`  before  applying  conceal,  try
# conditional is enough.  Sure?
#
#     :vim /if\s\+&bt\s\+==\s\+'quickfix'/gj $MYVIMRC ~/.vim/**/*.vim ~/.vim/**/*.snippets ~/.vim/template/**
#
# 23 -
#
# https://github.com/justinmk/vim-dirvish/issues/62
# https://github.com/bounceme/remote-viewer/
#
# Alternative:
# fuse/sshfs provides an abstraction at the filesystem layer (as opposed to some
# other "middleware"),  so that  any dumb local  navigator (like  dirvish) works
# without adding special-case support for scp, ftp, webdav, ..., netrw does.
#
#
# See also "Editing Remote Files with SSHFS":
# https://www.youtube.com/watch?v=0fAygjWHpdM
#
# 24 -
#
# Create mapping to send current line to terminal, and execute it
# Use `g>` for the lhs?
#
#     g> + text object
#     g> on visual selection
#     g>> for line
#
# 25 -
#
# Finish reviewing vim-math
# What insight can we gain from it?
#
# Also, look at this:
#
# https://github.com/sk1418/howmuch
#
# Is there any functionality we could steal?
#
# 26 -
#
# Finish reviewing `~/Dropbox/vim_plugins/pair_complete.vim`.
#
# 27 -
#
# We use `cml`, `cms`, in vimrc, myfuncs and in some of our plugins:
#
#    - iabbrev
#    - pair-complete
#    - titlecase
#
# It's  reliable  for programming  languages  where  the  cml must  be  repeated
# identically on every line of a multi-line comment.  What about the others (ex:
# `C`)?
#
# Update:
# We should distinguish 2 problems.
# (un)commenting a line vs detecting whether a line is commented.
# We solved the 1st problem in `vim-comment`.
# For the 2nd one, try this expression:
#
#     synID('.', col('.'), 1)->synIDtrans()->synIDattr('name') != 'comment'
#
# 28 -
#
# Check whether some Ex commands would be better suited as mappings.
#
# And check whether some mappings would be better suited as Ex commands.
# Tip: if you keep forgetting the lhs of a mapping, turn it into an Ex command.
#
# 29 -
#
# Install autocmd listening to `BufReadPost */after/ftplugin/*.vim`
# which would install a buffer-local autocmd listening to `bufwritepost`
# which would give us a warning when we forget to undo a
# mapping/abbreviation/command/autocmd/variable
#
# or when we undo a non-existing ...
#
# 30 -
#
# Normalize underscore/hyphen in plug mappings, and function names in shell init
# files.
#
# 31 -
#
# Update the position of the mark in `vim-readline`.
#
# MWE:
#
#     $ echo 'h|ello'
#              ^
#              cursor
#
#     press c-spc  (sets the mark right after the `h`)
#
#     $ |echo 'jjjjjjjjjjjjjjjjjjjhello'
#       ^      ├─────────────────┘
#       │      └ insert all of these
#       │
#       new cursor position
#
#     press c-x c-x  (exchange cursor and mark position)
#
# Result:
# in bash:
#
#     $ echo 'j|jjjjjjjjjjjjjjjjjjhello'
#              ^
#              ✘
#
# in zsh:
#
#     $ echo 'j|jjjjjjjjjjjjjjjjjj|hello'
#                                 ^
#                                 ✔
#
# Emulate `zsh` behavior.
#
# Look for other mappings to implement, add them to a todo.
#
# 32 -
#
# Should we add `:noa` every time we use `:wincmd`?
#
#     :vim /wincmd p\|call win_gotoid/gj $MYVIMRC ~/.vim/**/*.vim ~/.vim/**/*.snippets ~/.vim/template/**
#     :Cfilter! -not_my_plugins
#     :Cfilter! -not_relevant
#     :Cfilter! \<noa\>
#
# Same question for `:[cl]open`, `:[cl]window`?
# Why this 2nd question?
# `noa` was  useful in  `vim-interactive-lists` to  prevent the  original window
# from being  minimized when  it's a  middle horizontal viewport  (2nd of  3 for
# example).
# The issue, if there's one, may be with `:l[open|window]` only.
#
# Update:
# Whenever you  need to *temporarily*  change the  focus to another  window, you
# should try to use `win_execute()`.
#
# Changing the focused window can  lead to hard-to-debug issues, especially from
# an autocmd; `win_execute()` does not trigger autocmds when changing the focus.
# Also, it  preserves the previous window (`winnr('#')` and  `wincmd p` have the
# same result).
#
# 33 -
#
# Check that whenever we use `wincmd p` we get to the right window.
# Maybe we should use this instead:
#
#     var id: number = win_getid()
#     ...
#     win_gotoid(id)
#
# Update: We definitely should *not* be using `wincmd p`.
# It could raise `E366` if you've just created a popup window.
#
#     $ vim -Nu NONE +'set previewpopup=height:11,width:59' +'pedit ~/.shrc'
#     :wincmd p
#     E366: Not allowed to enter a popup window~
#
# The issue is that `wincmd p` seems too unpredictable...
#
# 34 -
#
# Read:
# https://dev.to/idanarye/omnipytent-5g5l
# https://www.reddit.com/r/vim/comments/7kwlxc/omnipytent_plugin_explained/
# https://github.com/idanarye/vim-omnipytent
#
# 35 -
#
# Read:
# https://github.com/luchermitte/lh-vim-lib/blob/master/doc/oo.md
# (oop in viml)
#
# 36 -
#
# Use syntax hl in `vim-qf` instead of complex mechanism using matches.
# Once done, try to use this mechanism for the issue we have in `Ltag()`.
#
# 37 -
#
# Add syntax hl in toc menu, and make content more relevant in help toc.
#
# 38 -
#
# Move every function called from several scripts inside `vim-lg-lib`:
#
#     comment#object(
#     qf#createMatches(
#     qf#setMatches(
#
# Also, make  sure they  are self-contained.
# They must not call  functions from one of our other  plugins.
# If they do, move the latter inside `vim-lg-lib` too.
#
# 39 -
#
# Implement a search ring, and install mappings to cycle through it
# useful to search for an old pattern without having to do `/ up ...`
# (; and ,  would be more comfy)
#
# 40 -
#
# When you create a loclist, replace the  old one if its title is `breakdown` or
# `fix_me & to_do`.
# Also, maybe create a mapping to show  the stack of location lists, and another
# to remove the current one.
#
# Also,  if you  execute  `:WTF` several  times consecutively,  `vim-stacktrace`
# keeps recreating  and adding the same  qfl.  It shouldn't.  It  should replace
# the old one, or better leave it alone.
# To do so, it should remember the last qfl it produced, or the last `:messages`
# it parsed, or any information sufficient to know that there's no need to
# recreate a qfl.
#
# 41 -
#
# Create a submode to insert numbers more easily.
#
# Ex:
#
#     ┌ enter “easy-number” submode
#     ├───┐
#     c-g n u  →  1
#           i  →  2
#           o  →  3
#           j  →  4
#           k  →  5
#           l  →  6
#           ,  →  7
#           ;  →  8
#           :  →  9
#           !  →  0
#
# Edit:
# Maybe a submode is not the right concept, because of the timeout.
# Maybe you should take inspiration from `vim-capslock`.
# Create a mapping, which would toggle temporary mappings.
#
#     ino <c-g>n <cmd>call <sid>EasyNumber()<cr>
#
#     def EasyNumber(): string
#         if !maparg('!', 'i')->empty()
#             for key in ['!', 'u', 'i', 'o', 'j', 'k', 'l', ',', ';', ':']
#                 exe 'iunmap <buffer> ' .. key
#             endfor
#         else
#             var i: number = 0
#             for key in ['!', 'u', 'i', 'o', 'j', 'k', 'l', ',', ';', ':']
#                 exe 'ino <buffer> ' .. key .. ' ' .. i
#                 i += 1
#             endfor
#             au InsertLeave <buffer> ++once EasyNumber()
#         endif
#     enddef
#
# 42 -
#
# Prevent vim-session from checking swap files.
# Annoying when a session crashed, and we can't restore a session.
# Or disable swap files entirely:
#
#     set noswapfile
#
# Update:
# I don't think you should disable swap files.
#
# 43 -
#
# Read:
#
#     :h popup.txt
#     :h sign.txt
#     :h textprop.txt
#
#     :h channel.txt
#
#     :h tagsrch.txt
#
#     :h syntax.txt
#                      only 2400 lines once you remove part 4, and part 5: `:h syn-file-remarks`
#                      you're not supposed to read part 5 entirely anyway, only the tags
#                      relevant to the types of files you use frequently;
#                      to get a list:  :h ft-*-syn c-d
#
#     :h recover.txt
#     :h diff.txt
#     :h tips.txt
#
#     :h pattern.txt
#     :h indent.txt
#
#     :h terminal.txt
#     :h vim9-script
#
# Note that LSP is not a replacement for tags:
# https://www.reddit.com/r/vim/comments/fj9tsz/do_lsps_make_tag_generating_tools_obsolete/fkmna6k/
# https://www.reddit.com/r/vim/comments/fj9tsz/do_lsps_make_tag_generating_tools_obsolete/fkmvji3/
#
# 44 -
#
# In `~/wiki/vim/funcref.md`, look for the pattern `funcref(`.
# There are 2 codes side-by-side.
# They are separated with `┊` characters.
# If you press `+sip` on the code, only the one on the left is sourced.
#
# This is neat.
# Try to develop this mechanism.
# For example, we could have a mapping which toggles which part is sourced,
# the one on the left or the one on the right.
#
# Also, when we  source the code on the  right, in a line ending with  `┊ "`, we
# could make `vim-source` replace the double quote  with the code on the left of
# `┊`. This would allow us to use `"` instead of repeating a whole command.
#
#
# 45 -
#
# Document `:spellinfo`, and `:h spellfile-cleanup`.
# Also, try to fix this item in the user manual:
#
#    > There should be something about spell checking in the user manual.
#
# 46 -
#
# Document `paste(1)` as a filter:
# https://vi.stackexchange.com/a/16096/17270
#
# Also, make some cleaning in our mappings:
#
#    - x_mJ      join two blocks
#    - x_m C-j   join two blocks in reverse order
#
# Are they consistent with other similar default commands (like `v_J` and `v_gJ`)?
# Could we make them easier to remember?
#
# 47 -
#
# Implement a mapping/command to extract the lines which are present in a block,
# but not in the other.  `:InAButNotInB` is too cumbersome.
#
# 48 -
#
#     $ shell_cmd | vim +'setf dirvish' -
#
# `q` doesn't work and there's no conceal.
#
# Solution:
#
#     $ shell_cmd | vim +'call dirvish#open("")' -
#
#
# There's no `b:undo_ftplugin`: there should be.
#
# Update: too hard; it breaks the code (some autoloaded function
# needs `b:dirvish` for example)
#
#
# Use `CmdlineLeave` instead of remapping `/` and `?`.
# This way the anchor at the end is never visible (noise, distracting).
# Hide it behind an option for a pr.
#
# Update:
# Two issues:
#
#    1. you can't prevent the initial search (the one without `\ze`)
#
#    2. you can't make the autocmd local to a buffer;
#    you can only inspect `get(b:, 'current_syntax', '')` and compare it to 'dirvish'
#    but the autocmd will still be global.
#
# 49 -
#
# Try to remove as many `virtcol()` as possible everywhere.
# Same thing for `\%v`; they don't mean what we thought.
#
# `virtcol('.')` and `\%v` take into account cells between the last character on
# a screen line of a long wrapped text line, and the first character of the next
# screen line (this includes 1 cell for the "virtual" newline).
# And so,  `virtcol()` and  `\%v` are  influenced by  `'wrap'` (and  all options
# related to the latter like `'linebreak'` and `'showbreak'`).
#
# Also, `virtcol('.')` outputs the index of  the last cell used by the character
# under the cursor:
#
#      literal control characters
#      vv vv
#     a^Bc^De
#      │  │
#      │  └ virtcol('.') is 6 not 4
#      └ virtcol('.') is 3 not 2
#
# ---
#
# The same can be true for `:norm! 123|`.
#
# If `123`  is obtained by `matchstr(line,  pat)->strchars()`), `:norm! 123|` will
# position the cursor unexpectedly on a long wrapped line.
#
# Solution: temporarily disable 'wrap'.
#
# Try to find other locations where we  have made a similar mistake; if you find
# anything, fix it.
#
# ---
#
# I  think  you  can  reliably  save  the column  position  of  the  cursor  via
# `virtcol()` and restore it with  `:norm`, because both take into consideration
# virtual characters which  are added when a long line  gets wrapped; they agree
# on what the position of a character is on a long wrapped line.
# However, it's much simpler to just save the cursor position with `getpos()` or
# `getcurpos()` and restore it via `setpos()`.
#
# ---
#
# What about `charcol()`?  How does it fit in all of this?
# When should we use `col()`, `virtcol()`, `charcol()`?
#
# 50 -
#
# Every time we populate a qfl from a script, we should save the command we used
# with the 'context' qf property.
# We could use it  to refresh a qfl, using a custom  mapping which would inspect
# the value of 'context'.
# The mapping would re-execute the command and  replace the old qfl with the new
# one.
#
# 51 -
#
# gf, c-w f, c-w gf should also be able to parse a column number.
# It would be useful in the qf window.
# See here for inspiration:
#
# https://github.com/wsdjeg/vim-fetch
#
# We could write a wrapper around these normal commands which would return
# the keys pressed, and start a timer which would execute `:norm` to position
# the cursor on the right column, if a column has been detected after the path.
#
# See also this:
#
# https://github.com/kana/vim-gf-user/blob/master/doc/gf-user.txt
#
# Also, they should be able to parse a reference link in a markdown buffer:
#
#     [description][123]
#     ...
#     [123]: link
#
# 52 -
#
# Finish implementing `!t` (timer info)
#
# Add syntax highlighting, additional info, mappings, ...
# also, create a mapping to interactively (un)pause/stop a timer.
#
# Also, do the same for matches (`getmatches()` + `matcharg()`).
# Use `! c-m` for the lhs of the mapping?
#          ^
#          getmatches
#
# Or, supercharge `!s`, so that when there's no syntax item under the cursor, it
# falls back on the matches.
# Also, do the same for these functions:
#
#     getbufinfo()		get a list with buffer information
#     gettabinfo()		get a list with tab page information
#     getwininfo()		get a list with window information
#     ch_info()                 get channel information
#     job_info()                get information about a job
#
# BTW:
# The 'lnum'  and 'windows' key in  the output of getbufinfo(...)[...]  are very
# interesting.
#
# Update:
# Maybe we should use `!i` as a prefix (i for **i**nfo).
#
#  - `!it` = timer
#  - `!ic` = channel
#  - ...
#
# 53 -
#
# Check which mappings could be supercharged using `v:count`:
#
#     nno cd <cmd>call <sid>Func(v:count)<cr>
#     def Func(cnt: number)
#         echo cnt ? 'hello' : 'world'
#     enddef
#
# And check which mappings could benefit from being passed a count.
# see what we did with `!w` (:wtf), and `spc t` (:tabnew).
# Basically,  any  mapping which  calls  an  ex  command accepting  a  numerical
# argument, or a bang, could be passed the latter via `v:count`.
#
# 54 -
#
# https://github.com/ardagnir/athame
# https://github.com/ardagnir/athame/issues/52
#
#    > full vim for your shell (bash, zsh, gdb, python, etc)
#
# Could be used to expand ultisnips snippets in the shell.
#
# 55 -
#
# Extract the code dedicated to templates from `vim-unix`.
# Make it able to evaluate viml (i.e. dynamic templates).
#
# See here for inspiration:
# https://github.com/aperezdc/vim-template
#
# 56 -
#
# In python files, we  can use multi-line comments with a  pair of triple double
# quotes.
# But they aren't properly concealed in a fold title, nor in the unfolded buffer.
#
# Also, should we use them more often?
# Review the comments in `~/.vim/plugged/vim-snippets/pythonx/snippet_helpers.py:442`.
#
# Also, finish restructuring our notes in `vim-snippets`.  Too many scattered files.
#
# Read:
# https://google.github.io/styleguide/pyguide.html?showone=comments#comments
# https://jeffknupp.com/blog/2016/12/09/how-python-linters-will-save-your-large-python-project/
#
# https://pylint.readthedocs.io/en/latest/
# https://pycodestyle.readthedocs.io/en/latest/
# http://www.pydocstyle.org/en/latest/
#
# Learn how to configure, use, integrate the following linters:
#
#    - pylint
#    - pycodestyle
#    - pydocstyle
#
# This command populates a default config file for `pylint`:
#
#     $ pylint --generate-rcfile >>~/.pylintrc
#
# 57 -
#
# We should use more abbreviations.
# Review the triggers:
#
#    - are they well chosen?
#    - should you remove some of them?
#    - should you add more?
#
#         use `:wordfrequency`, but if you find a frequent word (like 'result'),
#         it doesn't necessarily mean you should create an abbreviation just for
#         it;
#
#         maybe it's frequently  used in a group of words  (like 'as a result');
#         look for it  in your file, and  see in which context  it's used before
#         creating the abbreviation
#
# Maybe eliminate french.
# Move the functions in a dedicated file.
# Implement  a   `-A`  mapping   showing  the   available  abbreviations   in  a
# sidebar/cheatsheet.  Show only the less well known at any given time.
#
# 58 -
#
# Search for `[ SPC`, `SPc ]`, `{ SPC`, `SPC }`, `^\s*\\` everywhere.
# Refactor the style.
#
#     noa vim /\[ \| \]\|{ \| }\|^\s*\\/gj $MYVIMRC ~/.vim/**/*.vim ~/.vim/**/*.snippets ~/.vim/template/** | cw
#
# 59 -
#
# Every  time you open a  window, be aware that  an error may be  raised because
# you're in the command-line window.
# You may want to catch that error to avoid a stack trace.
#
# 60 -
#
# - remove `&l:` when it's not necessary?  (or the opposite: add it everywhere?)
# - use full name of commands and options?
# - switch from 4 spaces to 2 spaces for indentation?
#
# These are complex refactorings, because there will probably be a lot of matches.
# Try to write a custom command, which would refactor a script on-demand.
# Use it from time to time on a plugin you want to improve.
#
# But don't fuck up the alignment of our diagrams.
# So, before using your custom refactoring command, look for all the diagrams:
#
#     Vim /[─│]/j $MYVIMRC ~/.vim/**/*.vim ~/.vim/**/*.snippets ~/.vim/template/**
#
# And manually refactor everything you can around them.
# Then, you  should be able to  use your refactoring command  wherever you want,
# without breaking our diagrams.
#
# 61 -
#
# We often have errors when we import the contents of a file with `:r`,
# because the current buffer is not modifiable.
# Maybe we should always bail out in those cases...
#
# 62 -
#
#     % hash | vipe
#
#     press `gf` on a path
#     it takes several seconds, and the cpu load increases     ✘~
#
# The issue comes from 'set path=.,**' and from our current directory,
# when the latter has many subdirectories like `~`.
#
# MWE:
#
#     $ cd
#
#     $ vim -Nu NONE \
#       +'set path=.,**' \
#       +"set inex=substitute(v:fname,'.*=','','')" \
#       <(hash)
#
#     press `gf` on a path: it's slow
#
#     $ vim -Nu NONE \
#       +'cd ~/.vim/plugged/vim-awk' \
#       +'set path=.,**' \
#       +"set inex=substitute(v:fname,'.*=','','')" \
#       <(hash)
#     press `gf` on a path: it's quick
#
# We need to make `gf` smarter.
# When it sees a directory such as `~`, it should not search in it.
# Or, we should stop using such a broad 'path'... (vim-apathy to the rescue?)
#
# Update:
# Now we use a different value for 'path':
#
#     path=.,**5
#              ^
#
# This numeric prefix limits the depth of subdirectories in which Vim searches.
# It seems to help a lot in our previous MWE.
# Do we still have an issue? Or does the numeric prefix fix everything?
#
# 63 -
#
# The  `C-n` and  `C-p`  buffer-local  mappings installed  by  fugitive in  some
# buffers, conflict with our global mappings to cycle through tabpages.
# We're often distracted, because we wonder why our mappings are not working.
#
# 64 -
#
# Read:
#
# https://gist.github.com/yegappan/3b50ec9ea86ad4511d3a213ee39f1ee0
#    > Updating a quickfix/location list asynchronously without interfering with another plugin
#
# Also, study these plugins:
#
# https://github.com/yegappan/asyncmake (125 sloc)
# https://github.com/foxik/vim-makejob (197)
# https://github.com/prabirshrestha/async.vim (243)
# https://github.com/metakirby5/codi.vim (747)
#
# 65 -
#
# Supercharge `]e` and `[e` to move a fold when the cursor is on a line inside a
# closed fold.  Maybe do the same with `J` and `K` in visual mode.
#
# 66 -
#
# We don't version control our pdfs in `~/wiki`.
# Suppose one of our  notes has a link to a local pdf,  and we restore our notes
# on a new machine; the link will be broken.
# Improve `gx` so  that if it doesn't find  a pdf, it looks for  a `.tex` source
# code, compile it into a pdf, and open it.
# Also, make sure we do version control  the tex source code of all pdfs used in
# links.
#
# 67 -
#
# Review how we set folding ('fde', 'fdt') in all our plugins.
# If it makes sense, try to move as much code as possible in `vim-fold`.
#
# 68 -
#
# `[ SPC`  and `] SPC`  are not reliable  when we're on  a line inside  a closed
# fold.
# Maybe  you should  use other  keys to  handle folds,  so that  you can  decide
# yourself if you want Vim to add an empty line or an empty fold.
# Currently, I don't think we have an easy algo to teach Vim how to decide itself.
#
# 69 -
#
# Watch these videos about using Vim as a diff tool, and as a merge tool:
# https://www.youtube.com/watch?v=zEah_HDpHzc
# https://www.youtube.com/watch?v=VxpCgQyUXlI
#
# 70 -
#
# We have too many comments in this file about the bracketed paste mode.
# Move all of that in a dedicated file (vim notes, terminal notes, ...).
#
# 71 -
#
# In the  past, we have  had too many  issues by trying  to parse the  output of
# `execute('syn list ...')`, `execute('hi ...')`.
# Maybe we should ask for  some built-in functions (`getsynlist()`?, `gethi()`?)
# which would give this info in a nice dictionary.
#
# Also, `:verbose syn list ...` doesn't print the script location from which the
# syntax group was installed.  Maybe ask for an improvement of `:verb`.
#
# 72 -
#
# *Maybe*, our notes about plugins should be in help files.
# If so, *maybe* they should support folding.
#
# Also, document somewhere, that when you  try to assimilate a plugin, the first
# thing to do is to refactor its documentation.
# Remove  any documentation  about a  feature you find  useless (and  remove the
# associated code).
# Make  the explanations clearer,  and add explanations or  questions/answers if
# needed.
# Once you  fully understand the doc,  and it only contains  useful information,
# you know the plugin's interface.
# And  once  the  interface  has  entered your  muscle  memory,  you  can  start
# refactoring the code.
#
# 73 -
#
# We really need a library function to get a comment leader.
#
#     if &ft == 'markdown'
#         return ''
#     else
#         var cml: string = matchstr(&l:cms, '\S*\ze\s*%s')
#         return '\V' .. escape(cml, '\') .. '\m'
#     endif
#
# Vimgrep everywhere for `cml`.
#
# Update:
# We should probably define functions in our library (lg-lib), to:
#
#    - extract the comment leader
#    - detect whether a given line is commented
#    - return the commented version of a line (before pasting it somewhere)
#
# Update:
#
# I think we should not look at the comment leader to detect whether a line is commented.
# Instead, maybe we should just look at the syntax item at the end of the line:
#
#     :echo synID('.', col('$') - 1, 1)->synIDtrans()->synIDattr('name')
#
# Source: https://vi.stackexchange.com/a/18992/17449
#
# ---
#
# We  also need  a  library function  to  get  a commented  shell  command in  a
# codeblock (and maybe in a codespan).
#
# It should support continuation lines (see how we did it in vim-tmux for `|x`).
# I don't know how easy it will be  to write, but I think the integration *will*
# be  easy.  A  plugin  invoking this  library function  should  just receive  a
# string, with no newline inside.
# This way, the existing code in our plugins should not need any modification.
#
# Once you have the library function, use it in:
#
#     ~/.vim/plugged/vim-doc/autoload/doc/mapping.vim
#     ~/.vim/plugged/vim-tmux/autoload/tmux/run.vim:36
#
# Also, we need a library function to install this kind of `q` mapping:
#
#     nno <buffer><expr><nowait> q reg_recording() != '' ? 'q' : '<cmd>q!<cr>'
#
# 74 -
#
# We often make this error:
#
#     " insert this
#     getline()
#     " press M-b instead of C-b to get inside the parentheses
#
# What could be done to reduce the frequency of such errors?
#
# Idea: Every time you make such a mistake, undo, and re-insert `getline()` 3 times;
# each time make sure to press C-b.
#
# Other Idea: Make `M-b` inspect the 2 previous characters.
# If they are a pair of brackets, make it move the cursor as if `C-b` had been pressed.
#
# 75 -
#
# In a markdown file, `gc` should behave slightly differently.
# It  should  make sure  there  are  4 spaces  between  `>`  and the  first  non
# whitespace on each line; and reformat the quote with `par(1)`.
# Because that's what we do all the time; so better automate it.
#
# 76 -
#
# In a fugitive buffer, when we need to  stage many files, I would like to press
# `-` very fast.  We can't because – for some reason – it would trigger our `--`
# mapping which opens a dirvish buffer.
#
# 77 -
#
# The  interface of  your plugins  and custom  config should  be simplified  and
# exposed; review every custom mapping/command.
#
# **simplified** = for any mapping/command you never use, do any of these:
#
#    - remove it
#    - change its name to make it easier to remember/find
#    - merge the feature it provides with another mapping/command
#
# **exposed** =  for any feature  provided by  a mapping/command whose  name you
# keep forgetting, do any of these:
#
#    - include it in a cheatsheet
#    - include it in a help command (e.g. `g?`, `:MyCmd -help`)
#
#        If the help of a command gets too big, you could spread it across
#        several pages, using a `-help {keyword}` argument.
#
# 78 -
#
# Should we add the guard `if $MYVIMRC == '' | finish | endif` in all the files
# under `~/.vim/{after/}plugin`?
#
# ---
#
# Should we add the guard `if !exists('b:did_ftplugin')` in all the files under
# `*/after/ftplugin/{&ft}.vim`?
# https://github.com/andymass/vim-matchup/commit/0b780e9ae12ba913742356f4b7cedc52d3a15220
#
# 79 -
#
# Document a few things about debugging with breakpoints.
#
# No need to type the whole name of a variable, just run `:echo a:`, `:echo w:`, ...
#
# No need to compute the line number where to put a breakpoint; by default, line
# number 1  is used; from there,  just run `>next`  or `>step` to step  into the
# code which follows.
#
# Don't think that you enter debugging mode just at the breakpoint; you can stay
# in debugging mode  as long as Vim  has to process commands,  provided that you
# don't run `>cont` or `>quit`; those 2  only stop at the next breakpoint, while
# all the other ones come back to debug mode for some other command.
#
# `>next` and `>step` are similar (but not identical)
# `>interrupt` and `>quit` are similar (but not identical)
#
# `>finish`  lets  Vim  process  all  the  remaining  commands  in  the  current
# script/function;  after that  it makes  Vim come  back to  debug mode  for the
# command B which follows  the command A (A being the  command which had sourced
# the script/run the function in the first place).
# IOW,   `>finish`  is   useful  when   you've  stepped   into  a   long  called
# function/sourced script,  and you don't  want to  inspect it anymore,  but you
# still want to debug the outer function/script.
#
# Use `>s` only when necessary (i.e. only  when you need to step into a function
# or a sourced file).
# Right after executing `>s`, do *not* use any of your readline mappings.
# You would step into a readline function, which would create noise.
# The effect is  cumulative: for each of your custom  readline mapping you press
# right after  executing `>s`, you'll add  a new frame onto  the stacktrace (you
# can see it with `>bt`); you would then  need to run `>f` to quit each readline
# frame.
#
# Use `>f` as a shortcut to reach the line where the code breaks.
# Use it as many  times as possible; the more commands you have  run so far, the
# harder  it will  be to  reach the  vicinity of  your current  location in  the
# execution path (and you'll need to reach it yet another time because debugging
# is often an iterative process).
# In particular, if your buggy line is  run by a function, called by a function,
# called by a function... it may be tricky to find in which function you need to
# add a breakpoint.
# Don't  try  to find  the  right  function, just  add  your  breakpoint in  the
# interface function.   From there, inspect  the value of some  expression which
# you know will have – at some point – an unexpected value.
# Run `>f`, and inspect the same expression again; if the value is still the one
# you  expect, run  `>f` again;  if it's  not, you'll  know that  the issue  was
# somewhere in the previous function call.
# Repeat the process until the value is unexpected.
# Note somewhere  how many times  you had to  run `>f` – let's  call it N  – and
# restart a debugging session.
# Next, run `>f` (N-1) times, then run  `>n` as many times as possible until the
# value is unexpected.
# If the value  gets unexpected once you  reach a function call,  you'll need to
# step into it by running `>s`, then immediately run `>n` again.
# If you notice  that you've run `>n`  throughout the whole code  of a function,
# next time replace all the corresponding `n` with a single `f`.
# Build progressively the  shortest sequence of debugging  commands (`>f`, `>n`,
# `>s`) to  reach the buggy  line.  Update the  sequence somewhere in  a scratch
# buffer.
#
# You don't  need to make  a script-local function  temporarily public to  add a
# breakpoint into it.
# Just run `:fu *function_name`, then press Tab.
# The `*`  wildcard should be expanded  into sth like `<snr>123_`;  this assumes
# that the  function already exists,  which may  not be the  case if it's  in an
# autoloaded directory (in which case, run  the interface of the plugin to force
# the sourcing of the autoloaded directory).
# Now you can run `:breakadd func <snr>123_function_name`.
#
# 80 -
#
# Vim saves anything typed on the  command-line, regardless of how we've left it
# (including when we've pressed `C-c` or `Esc`).
#
# To prevent this, you could install these mappings:
#
#              necessary in Vim to not break readline mappings on the command-line
#              v---v
#     cno <esc><esc> <c-e><c-u><c-c>
#     cno <c-c> <c-e><c-u><c-c>
#
# The  reason why  we use  `C-c`  instead of  `Esc`,  is because  on the  search
# command-line, pressing `Esc` would search the pattern:
#
#     $ vim -Nu NONE +'cno <esc> <esc>' ~/.zshrc
#     /the
#     " press Escape: the cursor jumps to the next occurrence of `the`
#
# 81 -
#
# Look for `:windo` and `:wincmd` everywhere.
#
#     :vim /\m\C\<\%(windo\|wincmd\)\>/gj $MYVIMRC ~/.vim/**/*.vim ~/.vim/**/*.snippets ~/.vim/template/**
#
# Replace these commands with `win_execute()` whenever possible.
#
# 82 -
#
# Review all the custom motions you've installed.
# For each  of them, make  sure you can  jump back with  `C-o` (set mark  `'` on
# original position).
#
# Actually, maybe not for all of them.
# Think about which motions should add an entry in the jumplist.
#
# 83 -
#
# Install a `=rm`  mapping in Vim files to refactor  nested function calls using
# the method call operator (`->`).
#
# 84 -
#
#     $ cd ; vim
#     :echo getcwd() → /home/user
#     " press `--`
#     :echo getcwd() → /home/user/.vim (why did the cwd change?)
#     " press `q`
#     " press `--`
#     " press `q`: why isn't the dirvish buffer unloaded?
#
# 85 -
#
# Every time you've used sth like `norm! %` in the past, it was probably wrong.
# You should have used sth like:
#
#     searchpair('(', '', ')', 'W', 'synID(".", col("."), 1)->synIDattr("name") =~? "comment\\|string"')
#
# This is what the matchit plugin does, and it's more reliable.
# For example, position your cursor on the first open parenthesis on the following line:
#
#     if match(FUNCTION_NAMES, '^\V' .. funcname .. '\m\%((\|()\)') == -1
#             ^
#
# And run `:norm! %`: the cursor doesn't jump on the closing parenthesis.
# Now run `:call searchpair('(', ...)`: the cursor does jump on the closing parenthesis.
# Wrap this in a `lg#` function, and use it whenever you used `norm[!] %` in the past.
#
# Update:
# Actually, this is only an issue when you're dealing with code, not prose.
# In code, you may have an unbalanced closing brace inside a regex for example;
# it should be ignored, but `:norm! %` won't ignore it.
# Right  now, the  only places  where  that is  a  real issue  are in  `vim-vim`
# (`:RefHeredoc`, `:RefLambda`, `:RefMethod`).
#
# ---
#
# More generally, we often have issues with text-objects/motions related to braces.
# And we often have to perform refactorings in `vim-matchit`, which is a broken plugin.
# Enough is enough; we've removed `vim-matchit`, and installed `vim-matchup`.
# Read the documentation of the latter.
#
# 86 -
#
# Every time  we've "changed"  a buffer  in a way  that the  line count  did not
# change (`y` operator, `:y`, `:w`, `:update`,  ...), make sure we have used the
# `:lockmarks` modifier.
#
# In particular, it is useful to preserve the marks `'[` and `']`.
# This works since 8.1.2302:
# https://github.com/vim/vim/releases/tag/v8.1.2302
#
#     :vim /'\[\|'\]/gj $MYVIMRC ~/.vim/**/*.vim ~/.vim/**/*.snippets ~/.vim/template/**
#           ^------^
#           the pattern should look for more things (`:w` command, `:up` command, ...)
#
# ---
#
# Also, whenever we've used `:!`, maybe we should have used the `:keepmarks` modifier...
#
# 87 -
#
# Tweak our `= SPC` mapping so that it comments the added lines when we are on a
# commented line.
#
# Update:
#
# I'm not sure this is a good idea anymore.
# What's the use case?
# If you still think it's useful, then add this:
#
#     if getline('.') =~ '^\s*"'
#         for offset in range(1, v:count1)
#             setline(line('.') - offset, '"')
#             setline(line('.') + offset, '"')
#         endfor
#     endif
#
# at the end of `brackets#put_lines_around()`:
#
#     " ~/.vim/plugged/vim-brackets/autoload/brackets.vim
#
# 88 -
#
# I'm fed up with codespans being broken when formatting with `gq`.
#
# Find a way to prevent `par(1)` from breaking a codespan on multiple lines.
#
# Idea: If you can't,  then maybe you could temporarily replace  all spaces in a
# codespan with  C-b; this should prevent  `par(1)` from breaking a  codespan on
# multiple lines.  Then after the formatting, you would replace C-b with spaces.
#
# Also: Same issue with italics / bold style.
# Tweak syntax regexes?
#
# 89 -
#
# Integrate `~/Desktop/cwd.md` in our wiki notes.
#
# 90 -
#
# Remove all custom mappings/Ex commands you never use.
# They create "noise" which makes it harder to assimilate useful mappings/commands.
#
# 91 -
#
# Read:
# https://vimways.org/2019/indentation-without-dents/ (see `~/.vim/indent/[my]matlab.vim`, `~/Desktop/m.m`)
# https://vimways.org/2019/a-test-to-attest-to/
#
# 92 -
#
# Try to use `readdir()` whenever you've used `glob*()` + `filter()/match()` in the past.
# Example:
#
#     if !expand('%:p:h')
#         ->readdir((n: string): bool => n =~ 'some_name')
#         ->empty()
#         do sth
#     endif
#
# Also, check out `:h readdirex()`.
#
# 93 -
#
# Try to use `matchlist()` more often.
# In particular, whenever you've  used `matchstr()` several times consecutively,
# it may be an indication that `matchlist()` was better:
#
#     var text: string = 'hello world some text'
#     var foo: string = matchstr(text, '^\S\+')
#     var bar: string = matchstr(text, '^\S\+\s\+\zs\S\+')
#     ⇔
#     var text: string = 'hello world some text'
#     var foo: string
#     var bar: string
#     [foo, bar] = matchlist(text, '^\(\S\+\)\s\+\(\S\+\)')[1 : 2]
#
# 94 -
#
# Try to replace as many timers as possible:
#
#     timer_start(0, () => ...)
#     →
#     au SafeState * ++once ...
#
# Should we though?
#
# I mean, sometimes it helps:
# https://vi.stackexchange.com/a/22414/17449
# *prevents flickering*
#
# and sometimes, it doesn't work and you really need a timer:
# https://github.com/vim/vim/issues/5243#issuecomment-555250613
#
# In general, it seems that `SafeState` executes a command earlier compared to a
# timer (that would explain the behaviors observed in the previous 2 links).
#
# Do we want a delayed command to be executed earlier?
# Naively, I would say yes.  The longer a command is delayed, the longer we stay
# in an undesirable state...
#
# 95 -
#
# We refer to dirvish in several locations in `vim-fex`.
# I don't like that.
# dirvish and fex are two different plugins.
#
# 96 -
#
# Remove all invocations of `setenv()` and `getenv()`.
# Use global variables  instead; don't write them in uppercase  though; we don't
# want them to be saved/restored via viminfo.
#
# Document somewhere how `[gs]etenv()` can be used.
#
# 97 -
#
# Assimilate the `Sendtoclipboard()` function, and the `~/bin/sendtoclipboard` script.
    def Sendtoclipboard(text: string)
        # What's this `sendtoclipboard` ?{{{
        #
        # A custom script: `~/bin/sendtoclipboard`.
        # It writes the text in:
        #
        #    - a tmux buffer
        #    - the clipboard via `xsel(1x)` or `xclip(1)`
        #    - the clipboard via OSC 52
        #}}}
        sil var seq: string = system('sendtoclipboard', text)
        # Why this guard?{{{
        #
        # In the GUI, OSC 52 doesn't seem to be supported.
        #}}}
        #   Why don't you move it at the top?{{{
        #
        # In addition to producing an  OSC 52 sequence, `sendtoclipboard` copies the
        # text  in the  clipboard via  `xsel(1x)`; this  last feature  may still  be
        # useful in the GUI.
        #}}}
        if has('gui_running')
            return
        endif
        if v:shell_error
            Catch()
            return
        else
            # TODO: Document why this line is needed.{{{
            #
            # Hint: It's only needed when you're working on a remote machine.
            #
            # If   you're   not   convinced,   comment  the   line,   and   in   the
            # `sendtoclipboard` script, comment the line invoking `xsel(1x)`.
            # Then, try to use this function: it will fail.
            # It  should work  thanks to  the OSC  52 sequence,  but it  doesn't
            # without this `echoraw()` line.
            # I think  that's because the script  is called via `system()`  and thus
            # has no controlling terminal; so the sequence is written nowhere.
            #}}}
            echoraw(seq)
        endif
    enddef
    nno <space>y y<cmd>call <sid>Sendtoclipboard(@0)<cr>
#
# 98 -
#
# Write a refactoring command to convert a dictionary into its Vim9 literal form:
#
#     {'a': 1, 'b': 'string'}
#     →
#     {a: 1, b: 'string'}
#
# Idea:
# Inside the dictionary, iterate over all the colons which are outside a string.
# For each  of them, look  back for a string  (only whitespace can  separate the
# string from the colon); if you find such a string, press `sd'`.
#
# Warning: Read `:h vim9 /Dictionary literals`.
# You can  only omit the quotes for keys  which include alphanumeric characters,
# underscore and dash.
# Take that into consideration when writing your refactoring command.
# That is, if  some key contains characters which are  invalid, cancel the whole
# refactoring.
#
# 99 -
#
# Create a command to cycle between different buffer states.
# E.g.:
#
#    1. press some custom mapping to remember the current state (`:echo undotree().seq_cur`)
#
#    2. edit the buffer
#
#    3. press some custom mapping to get back to the original remembered state;
#       before that, remember the new current state to be able to cycle between the 2 states
#
# This would  be useful when  we bisect the  code in some  file, and we  need to
# temporarily remove a lot of code.
#
# Update: A command would be better.
#
#     " add current undo seq to a dictionary (key = undo seq, value = description of the buffer state)
#     " save the info in a file
#     :UndoSeq -save 'some description'
#
#     " removes undo seq 123 from the dictionary
#     :UndoSeq -del 123
#
#     " removes the file where the info contained in the dictionary is saved
#     :UndoSeq -del
#
#     " load list of undo seq into location window
#     " pressing Enter on an entry runs `:undo 123` in the associated buffer
#     :UndoSeq
#
# Update: 'undolevels' is set to 1000 by default.
# It means that beyond 1000 changes, old undo states start being lost.
# It's  easy to  reach the  limit when  refactoring a  script, especially  via a
# script.  Increasing the limit could have a bad impact on performance.
#
# To avoid losing an old undo state, maybe our custom command should also make a
# backup of the current version of the file...
#
# 100 -
#
# Consider adding `sil!` to unmap all buffer-local mappings from `b:undo_ftplugin`.
# We've lost some time  trying to understand why we sometimes  had an error when
# opening a dirvish buffer.  See:
#
#     ~/.vim/plugin/ultisnips.vim
#
# But we didn't learn  much in the process; not sure  it's worth avoiding `sil!`
# going forward.
#
# ---
#
# Also, in all other locations, try to remove as many `sil!` as possible.
# Replace them with `try/catch` if necessary (with an `echom v:exception` in the
# `catch` clause).
#
# `sil!` can shadow the real cause of a bug, and make the debugging more difficult.
# For  example,  once  we had  an  issue  where  a  regular buffer  was  wrongly
# transformed into a qf buffer: https://github.com/vim/vim/issues/7352
#
# 101 - Find a fix for these console-related issues:
#
# https://vi.stackexchange.com/questions/25151/how-to-change-vim-cursor-shape-in-virtual-console
# https://vi.stackexchange.com/questions/25093/how-to-use-16-color-colorscheme-in-tty
#
# 102 - Replace all `_save` with `save_`.
# That's what Bram seems to prefer (cf. `:h mapset()`).
# But tpope seems to use `_save`...
# What should we choose?
#
# 103 - In the past, did we use `len()` + `matchstr()` instead of `byteidx()`/`byteidxcomp()`?
#
# 104 -
#
# Study and document the new `flatten()` function.
# In particular, read the tests:
# https://github.com/vim/vim/commit/077a1e670ad69ef4cefc22103ca6635bd269e764
#
# Note that `flatten()` is disallowed in Vim9.
# Instead, you must use `flattennew()`:
# https://github.com/vim/vim/commit/3b690069730805a147d45d92eaca4dc838272d1d
#
# 105 -
#
# Adapt this for `:map` (& friends like `:nno`), `:[ic]norea`, `:au`, and `:set`:
# https://github.com/vim/vim/issues/6373#issuecomment-652664179
#
# AFAICT, those  are the only commands  which include a `Last  set from` message
# when the verbosity level  is increased, and thus they are  the only ones whose
# output can be converted into a qfl.
#
# Suggestion: Don't install a `:Verbose` command  (we already have one, it would
# need to be adapted).  Instead, install a `CmdlineLeave` autocmd which inspects
# the command-line.
#
# 106 -
#
# Make sure  we've never  written `line('.')`,  `line('$')`, `line("'x")`  (x is
# an  arbitrary  mark), `line('w0')`,  `line('w$')`,  `line('v')`,  when it  was
# unnecessary.
#
# Hint: It's only necessary for a function which can operate on arbitrary buffer
# (e.g. `setbufline()`, `prop_add()`, `screenpos()`, ...).
# For any function which can only operate  on the current buffer, you don't need
# `line()`.
#
# 107 -
#
# Autoload as  many functions as possible  out of the vimrc,  to improve startup
# time.
#
# 108 -
#
# Refactorings:
#
# There may be a lot more places where we could have used a method.
# Indeed, you can write this:
#
#     expr->Func()
#     expr->{x -> x + 1}()
#     expr->((x) => x + 1)()
#
# This is briefly mentioned at `:h method`:
#
#    > Example of using a lambda: >
#    >         GetPercentage()->{x -> x * 100}()->printf('%d%%')
#
# Note that when `Func()`  is a custom function or lambda, it  seems the base is
# always passed as the first argument.
#
# Check whether we could add one more `->` each time we've used a method.
#
#     \%(\S\|^\s*["#]\s*\\\s*\)\%\({\s*\%(\%\(\S\+\s*,\)\=\s*\S\+\)\=\s*\)\@<!->\a
#
# 109 -
#
# Consider doing this kind of refactorings:
#
#     var tempfile: string = tempname()
#
#     →
#
#     if tempfile != ''
#         sil! delete(tempfile)
#         tempfile = ''
#     endif
#     var tempfile: string = tempname()
#
# The purpose  would be  to prevent Vim  from piling up  tempfiles for  the same
# feature.  This is what junegunn does in `fzf#vim#helptags()`.
# Although, I didn't find this kind of precautions anywhere else...
#
# 110 -
#
# Install a mapping to toggle `'breakindent'` and `'linebreak'`?
#
# It  would help  when the  buffer contains  huge wrapped  lines, and  our vimrc
# autocmd has not been able to reset the options.
#
# ---
#
# Also, add an indicator in the status line when the options are reset?
#
# 111 -
#
# Make Vim  respect the XDG spec.   As a benefit, I  think it would let  us move
# `~/.vim` in `~/.config`, which would reduce clutter in our $HOME.
#
# See:
# https://tlvince.com/vim-respect-xdg
# https://blog.joren.ga/configuring/vim-xdg
#
# 112 -
#
# Leave a comment here  showing how problematic it is for  a popup filter to
# consume the keys coming from the expansion of a mapping:
# https://github.com/vim/vim/issues/7459
#
# Because of this issue, a plugin's author has no guarantee that their popup
# filter won't break  a user mapping.  And  if it breaks a  user mapping, it
# might cause  dangerous commands to  be executed.   Try to find  an example
# (e.g. with a mapping whose rhs executes `rm(1)` via `:!`).
#
# Also, a plugin's  author has no guarantee that their  popup filter will be
# executed intentionally.
#
# 113 -
#
# Should we have used the autocmd pattern `?*` instead of `*` in some autocmds?
# It could simplify some of them  (or maybe slightly improve their performance);
# because, then, there's no need to write sth like this:
#
#     if bufname('%') == ''
#         return
#     endif
#
# 114 -
#
# Check whether we should have sometimes  saved and restored `"0` in addition to
# `""`. Look for `setreg(` everywhere.
#
# The issue is a  bit complex because we've forgotten a  lot about how registers
# work.  Explain the issue to yourself in great detail.
#
# To help you, here is a start:
#
#     " write this in /tmp/t.vim
#     vim9script
#     set showcmd
#
#     nno <expr> <c-b> <sid>MyOp()
#
#     def MyOp(type = ''): string
#         if type == ''
#             &opfunc = expand('<SID>') .. 'MyOp'
#             return 'g@'
#         endif
#         var unnamed: dict<any> = getreginfo('"')
#         var zero: dict<any> = getreginfo('0')
#         normal! `[v`]y
#         echom strlen(@")
#         setreg('"', unnamed)
#         setreg('0', zero)
#         return ''
#     enddef
#
#     setreg('0', {regcontents: 'zero'})
#     setreg('a', {regcontents: 'aaa'})
#     setreg('"', {regcontents: 'zzz', points_to: 'z'})
#     setreg('*', {})
#     setreg('+', {})
#     repeat(['the quick brown fox jumps over the lazy dog'], 5)->setline(1)
#
#     # then, start Vim like this
#     $ vim -Nu NONE -i NONE -S /tmp/t.vim
#
# Did we say something wrong here?
# https://vi.stackexchange.com/questions/28354/reliably-saving-and-restoring-registers-across-a-function-call/28356#28356
#
# ---
#
# BTW, when we use `v_p`, what happens exactly regarding the registers?
# I think that:
#
#    - the selected text is written in `"-` or a numbered register (depending on whether it's big or not)
#    - if it's written into a numbered register, Vim perform a rotation on the stack of numbered registers
#    - the unnamed register is reconnected to `"-` or a numbered register
#
# ---
#
# In general, should we restore `"0` before or after `""`?
# Does  the answer  to  that  question depend  on  what  `""` points  to
# (especially `"0`)?
#
# ---
#
# Did we make some mistake when restoring `"0` in the past?
# Like maybe we should have restored it before or after `""`, or with a timer...
#
# ---
#
# In  our library  function  `Opfunc()`,  should we  save/restore  `"-` and  the
# numbered registers too?
#
# ---
#
# Use our saved qfl named `setreg`.





# sessions to finish:
#
#    1.  sandwich
#    2.  ultisnips
#    3.  markdown
#    4.  tag
#    5.  arglist (improve our arglist mappings)
#    6.  breakdown
#    7.  paragraph (master `par(1)`)
#    8.  tree
#    9.  keyboard
#    10. systemd
#    11. cron
#    12. swap
#    13. emmet
#    14. config
#    15. qf_issue (finish the last two questions)
#    16. completion
#    17. profiling
#    18. debug
#    19. try
#    20. async
#    21. unix
#    22. package
#
# Once finished, get back to studying the terminal and latex.
