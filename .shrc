# What are  the tools  useful to  accelerate the learning  of a  new programming
# language?
#
#     • snippets engine (stay focused)
#     • linter
#     • formatter (stay consistent; enforce styleguide)
#     • REPL/compiler (evaluate code to check it works)
#     • integrated documentation
#     • ?



# TODO:
# Remove this file.
# Merge it with `~/.zshrc`.
# It introduces way too much confusion.
# For example, we often define an alias/function  in one file, then a second one
# in another file, both  having the same name, and we  don't notice the conflict
# which makes debugging harder in case of a problem.
# We  don't  want  to  use  bash  interactively  anyway,  so  there's  no  point
# configuring it.

# TODO:
# It would be useful to be able to search for a pattern inside all configuration
# files with `:vimgrep`. Including the ones for the shell.
# We could create symlinks inside `~/.config` which would point to the config files
# that we can't (easily) move, like `~/.bashrc` or `~/.tmux.conf`.
# But there are still a lot of  irrelevant files in `~/.config` (cache of chrome
# for example).  Think about a better way of grepping all config files.

# TODO:
# In your functions, try to create as few temporary files as you can.
# Maybe you could eliminate some of them, using process redirection:
#
#         https://www.reddit.com/r/vim/comments/7czgrd/profiling_and_optimizing_vim/dpvzt9h/
#
# Example:
#
#                                                           ┌ last argument of the previous command,
#                                                           │ here it should be `/tmp/vim.log`
#                                                           ├┐
#         vim -c 'q' --startuptime /tmp/vim.log && tail -n1 $_
#             vs
#         vim -c 'q' --startuptime >(tail -n1)



# TODO:
# Recomment the aliases/functions we've recovered after the loss of this file.
# Also, re-read the rest of the file. Maybe some parts need to be re-factored again.
# Try to remember the fixmes/todos.

# Recovered Aliases:

alias checki='sudo rlwrap checkinstall -y'
alias fzo='sh -c "$(fc -ln -1)|fzf"'
alias gs='git log --all --source -p -S'

# ls folders only
#
# -1    list one file per line
# -d, --directory
#       list directory entries instead of contents,
#       and do not dereference symbolic links
#
# ls *        list everything
# ls */       list every folder and their contents
# ls -d */    list every folder (only their entries)
alias lsd='ls++ -1d */'
# n for new?
alias lsn='ls -Ggthr --time=ctime'
# o for owner?
alias lso='ls++ --potsf'
# s for size?
alias lss='ls++ --psf'
# ls by time/changes, newest at bottom
#
# -c    with  -lt:
#       sort  by,  and show, ctime (time of last modification of file status information)
#
# Mnemonic:    t for Time
alias lst='ls++ --ptsf'

alias mount='grc mount'
alias traceroute='grc traceroute'

# Warning:{{{
#
# This alias shadows the `nb` binary installed by the `nanoblogger` package.
#}}}
alias nb='newsboat -q'
alias zsh_prof='repeat 10 time zsh -i -c exit'
alias conky_reload='killall -SIGUSR1 conky'
alias xresources_reload='xrdb -cpp "$(command -v cpp) -traditional-cpp" ~/.Xresources'
alias web='WWW_HOME=duckduckgo.com w3m'


# Recovered Functions:
alert() {
  local icon summary
  icon='$([[ $? -eq 0 ]] && printf -- "terminal\n" || printf -- "error\n")'
  summary="$(history | tail -n1 | sed -e 's/^\s*[0-9]\+\s*// ; s/[;&|]\s*alert$//')"
  eval "notify-send --urgency=low -i " "${icon}" '"${summary}"'
}

help() {
	if [[ $0 == "bash" ]]; then
		builtin help -m "$@" | vipe
	else
		run-help "$@" | vipe
	fi
}

img_w3m() {
	w3m -o imgdisplay=/usr/lib/w3m/w3mimgdisplay "$1"
}

vim_prof() {
  local TMP
	TMP="$(mktemp /tmp/.profile_vim.XXXXXXXXXX)"
  pushd >/dev/null
	builtin cd /tmp
	vim --cmd "prof start ${TMP}" --cmd 'prof! file ~/.vim/vimrc' -cq
	vim "${TMP}" -c 'syn off' -c 'norm +tiE' -c 'update'
  popd >/dev/null
}

vim_startup() {
  local TMP
	TMP="$(mktemp /tmp/.startup_vim.XXXXXXXXXX)"
  pushd >/dev/null
	builtin cd /tmp
  vim --startuptime "${TMP}" \
      +'q' startup_vim_file \
      && vim +'setl bt=nofile nobl bh=wipe noswf | set ft=' \
      +'sil 7,$!sort -k2' \
      +'$' "${TMP}"
  popd >/dev/null
}

# Testing eNViRonment
tnvr() {
	builtin cd "$(mktemp -d /tmp/.tvr.XXXXXXXXXX)"
	cp -R "${OLDPWD}"/* .
}

# useful to check the contents of a value of an environment variable:
#         what_is_in_var $IFS
#
# The number which is displayed in the lower right corner seems to be a weight
# in bytes.
what_is_in_var() {
	var="$1"
	printf -- "%s" "$var" | od -t c
}

# Alias {{{1
# git {{{2

# Usage:
#     config status
#     config add /path/to/file
#     config commit -m 'my message'
#     config push
alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'

alias ga='git add'

# Do not add `rlwrap` before `git commit`.{{{
# Why?
#     1. It's not needed here.
#     2. It causes an issue.
#
# How to reproduce the issue?
#
#   1. write at the beginning of vimrc:
#
#         nno <silent> cd :sil w<cr>
#         set rtp+=~/.vim/plugged/vim-gutentags/
#         finish
#
#   2. tweak some repo
#   3. try to commit with `rlwrap git commit`
#   4. write something on the 1st line and stay on the 1st line
#   5. while the buffer is still modified, hit `cd`
#
# → the line disappears
#
# It  has nothing  to do  with  the conceal  feature. It's reproducible  without
# syntax highglighting.
#
# Solutions:
#
#         • nno          cd :sil w<cr>
#         • nno <silent> cd :w<cr>
#         • commit without `rlwrap`
#
# We have several mechanisms to save a buffer (including an autocmd).
# It's easier (and more future-proof) to just NOT use `rlwrap`.
#}}}
alias gc='git commit'
alias gp='rlwrap -H /dev/null git push'
# Git Restore Last Commit
alias grlc='git reset --hard $(git rev-parse HEAD)'

# local_testing_server {{{2

alias local_testing_server='python3 -m http.server'

# py {{{2

alias py='/usr/local/bin/python3.7'

# surfraw {{{2

alias srr='sr ixquick'
alias surfraw='surfraw -browser=w3m'

# tlmgr_gui {{{2

alias tlmgr_gui='nohup tlmgr gui -font "helvetica 20" -geometry=1920x1080-0+0 >/dev/null 2>&1 &'

# others {{{2

# TODO:
# How is it different than the `cdr` function in zsh?
# Is it useful?
# If it is, how to rename this  alias to move it into `~/.zshrc` without getting
# a name conflict?

# CD into most Recent accessed subdirectory in current directory
# alias cdr='cd "$(ls -dt */ | head -1)"'
#             │      ││ │    │
#             │      ││ │    └── only first entry
#             │      ││ └── only list directories
#             │      │└── sort by modification time, newest first
#             │      └── don't display all the contents of the directories, only their names
#             └── quote the command substitution, in case the name of the resulting directory
#                 contains a space

alias emacs='emacs -nw'

# `iotop` est un outil en cli qui permet de savoir quels processus accèdent
# (lecture / écriture) au disque:
#
#     -o    seulement les processus actifs
#     -P    seulement des processus (pas les threads)
alias iotop='iotop -o -P'

#              ┌─ --no-group in a long listing, don't print group names
#              │┌─ like -l, but do not list owner
#              ││ ┌─ --almost-all do not list implied . and ..
#              ││ │
alias lsa='ls -GghA'
#       │
#       └─ mnemonic: all

#                             ┌─ --indicator-style=slash append / indicator to directories
#                             │
alias lsf='ls --color=always -p | grep -v "/$"'
#       │
#       └─ mnemonic: files only

# -X    Sort alphabetically by extension, then by the rest.
#       Directories can't have an extension, so they always come first.
#       Handy to sort files from folders.
#
# Mnemnonic:    x for eXtension
alias lsx='ls -lX'

alias mybookmarks='vim +"setl nowrap" ~/.config/surfraw/bookmarks'

# -f, --format=FORMAT
#        Change edit format of text file.
#        Available edit formats are:
#
#        `single-column'       (or `sc')
#        `dual-column'         (or `dc')
#        `destination-only'    (or `do')
#
#        The default format is dual-column.
alias qmv='qmv --format=destination-only'

# Why?{{{
#
# Suppose you have an alias `foo`.
# You want to execute it with `sudo`:
#
#     # ✘
#     $ sudo foo
#
# It won't  work because the shell  doesn't check for an alias  beyond the first
# word.
# The solution is given in `man bash` (/^ALIASES):
#
#      If  the last  character of  the alias  value is  a blank,  then the  next
#      command word following the alias is also checked for alias expansion.
#
# By creating the alias  `alias sudo='sudo '`, we make sure  that when the shell
# will  expand  the alias  `sudo`  in  `sudo foo`,  the  last  character of  the
# expansion will be a blank.
# This  will cause the shell  to check the next  word for an alias,  and make it
# expand `foo`.
#
# See also:
#
#     https://askubuntu.com/a/22043/867754
#}}}
alias sudo='sudo '

alias vb='VBoxManage'

# `nethogs` is a utility showing  which processes are consuming bandwidth on our
# network interface.
alias net_watch='nethogs enp3s0'

# Environment Variables {{{1
# CDPATH {{{2

export CDPATH=:${HOME}:/tmp

# EDITOR {{{2

export EDITOR='vim'

# LC_TIME {{{2

# to get the name of the day/month in english
export LC_TIME=en_US.UTF-8

# LS_COLORS {{{2

eval "$(dircolors "${HOME}/.dircolors")"

# INFOPATH {{{2

# https://www.tug.org/texlive/doc/texlive-en/texlive-en.html#x1-310003.4.1
export INFOPATH=$HOME/texlive/2018/texmf-dist/doc/info:$INFOPATH

# MANPAGER / MANPATH {{{2

# Use Vim as default man pager.

#                         ┌──────── wrap the whole command in `/bin/sh -c`
#                         │         because the value of $MANPAGER can't use a pipe directly
#                         │
#                         │       ┌ remove some control characters like ^H
#                ┌────────┤  ┌────┤
export MANPAGER='/bin/sh -c "col -bx | vim --not-a-term -"'
#                                  │         │
#                                  │         └ don't display  “Vim: Reading from stdin...”
#                                  └ replace tabs with spaces

# add man pages for `texlive` and `dasht`
export MANPATH=$HOME/texlive/2018/texmf-dist/doc/man:$HOME/GitRepos/dasht/man:$MANPATH

# PARINIT {{{2

# According to `man par`, it's recommended to assign the value:
#
#         rTbgqR B=.,?_A_a Q=_s>|
#
# … to the environment variable `PARINIT`.
#
# It's useful to prevent the following kind of wrong formatting:
#
#     par <<< 'The quick brown fox jumps over the lazy dog.
#     The quick brown fox jumps over the lazy dog foo bar baz.'
#
#         The quick brown fox jumps over the lazy dog.
#         The quick brown fox jumps over the lazy dog foo bar baz                .    ✘
#
# With the right value for `PARINIT`:
#
#         The quick brown fox jumps over the lazy dog.  The quick brown fox jumps
#         over the lazy dog foo bar baz.                                              ✔

# TODO:
# Read `man par` to explain this value.
export PARINIT='rTbgqR B=.,?_A_a Q=_s>|'

# PATH {{{2

# add the `texlive` and `dasht` binaries to our path
export PATH=$HOME/texlive/2018/bin/x86_64-linux:$PATH:$HOME/GitRepos/dasht/bin

# PDFVIEWER {{{2

# Choose which program should be used to open pdf documents.
# Useful for `texdoc`.
export PDFVIEWER=zathura

# XDG {{{2

# https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html

# directories relative to  which various kinds of user-specific  files should be
# written

# data files:
#
#     • trash
#     • icons
#     • viminfo
#     • swap files
#     • .desktop files
#     • .keyring files
#     • …
export XDG_DATA_HOME=$HOME/.local/share

# configuration files
export XDG_CONFIG_HOME=$HOME/.config

# non-essential (cached) data
export XDG_CACHE_HOME=$HOME/.cache

# runtime files and other file objects
# (temporary files created by processes owned by the logged user)
export XDG_RUNTIME_DIR=/run/user/$UID
#                      └────────┤
#                               └ should exist on any OS using systemd
#                                 not sure about the others

